// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(lipalightninglibFFI)
import lipalightninglibFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_lipalightninglib_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_lipalightninglib_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(bytes: try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

fileprivate struct FfiConverterTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Date {
        let seconds: Int64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        if seconds >= 0 {
            let delta = Double(seconds) + (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        } else {
            let delta = Double(seconds) - (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        }
    }

    public static func write(_ value: Date, into buf: inout [UInt8]) {
        var delta = value.timeIntervalSince1970
        var sign: Int64 = 1
        if delta < 0 {
            // The nanoseconds portion of the epoch offset must always be
            // positive, to simplify the calculation we will use the absolute
            // value of the offset.
            sign = -1
            delta = -delta
        }
        if delta.rounded(.down) > Double(Int64.max) {
            fatalError("Timestamp overflow, exceeds max bounds supported by Uniffi")
        }
        let seconds = Int64(delta)
        let nanoseconds = UInt32((delta - Double(seconds)) * 1.0e9)
        writeInt(&buf, sign * seconds)
        writeInt(&buf, nanoseconds)
    }
}

fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}


public protocol LightningNodeProtocol {
    func `getNodeInfo`()   -> NodeInfo
    func `queryLspFee`()  throws -> LspFee
    func `getPaymentAmountLimits`()  throws -> PaymentAmountLimits
    func `calculateLspFee`(`amountSat`: UInt64)  throws -> Amount
    func `createInvoice`(`amountSat`: UInt64, `description`: String, `metadata`: String)  throws -> InvoiceDetails
    func `decodeInvoice`(`invoice`: String)  throws -> InvoiceDetails
    func `getPaymentMaxRoutingFeeMode`(`amountSat`: UInt64)   -> MaxRoutingFeeMode
    func `payInvoice`(`invoice`: String, `metadata`: String)  throws
    func `payOpenInvoice`(`invoice`: String, `amountSat`: UInt64, `metadata`: String)  throws
    func `getLatestPayments`(`numberOfPayments`: UInt32)  throws -> [Payment]
    func `getPayment`(`hash`: String)  throws -> Payment
    func `foreground`()  
    func `background`()  
    func `listCurrencyCodes`()   -> [String]
    func `getExchangeRate`()   -> ExchangeRate?
    func `changeFiatCurrency`(`fiatCurrency`: String)  
    func `changeTimezoneConfig`(`timezoneConfig`: TzConfig)  
    func `acceptPocketTermsAndConditions`()  throws
    func `registerFiatTopup`(`email`: String?, `userIban`: String, `userCurrency`: TopupCurrency)  throws -> FiatTopupInfo
    func `queryUncompletedOffers`()  throws -> [OfferInfo]
    func `requestOfferCollection`(`offer`: OfferInfo)  throws -> String
    func `registerNotificationToken`(`notificationToken`: String, `languageIso6391`: String, `countryIso31661Alpha2`: String)  throws
    func `getWalletPubkeyId`()   -> String?
    func `getPaymentUuid`(`paymentHash`: String)  throws -> String
    
}

public class LightningNode: LightningNodeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`config`: Config, `eventsCallback`: EventsCallback) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_constructor_lightningnode_new(
        FfiConverterTypeConfig.lower(`config`),
        FfiConverterCallbackInterfaceEventsCallback.lower(`eventsCallback`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_lipalightninglib_fn_free_lightningnode(pointer, $0) }
    }

    

    
    

    public func `getNodeInfo`()  -> NodeInfo {
        return try!  FfiConverterTypeNodeInfo.lift(
            try! 
    rustCall() {
    
    uniffi_lipalightninglib_fn_method_lightningnode_get_node_info(self.pointer, $0
    )
}
        )
    }

    public func `queryLspFee`() throws -> LspFee {
        return try  FfiConverterTypeLspFee.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_query_lsp_fee(self.pointer, $0
    )
}
        )
    }

    public func `getPaymentAmountLimits`() throws -> PaymentAmountLimits {
        return try  FfiConverterTypePaymentAmountLimits.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_get_payment_amount_limits(self.pointer, $0
    )
}
        )
    }

    public func `calculateLspFee`(`amountSat`: UInt64) throws -> Amount {
        return try  FfiConverterTypeAmount.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_calculate_lsp_fee(self.pointer, 
        FfiConverterUInt64.lower(`amountSat`),$0
    )
}
        )
    }

    public func `createInvoice`(`amountSat`: UInt64, `description`: String, `metadata`: String) throws -> InvoiceDetails {
        return try  FfiConverterTypeInvoiceDetails.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_create_invoice(self.pointer, 
        FfiConverterUInt64.lower(`amountSat`),
        FfiConverterString.lower(`description`),
        FfiConverterString.lower(`metadata`),$0
    )
}
        )
    }

    public func `decodeInvoice`(`invoice`: String) throws -> InvoiceDetails {
        return try  FfiConverterTypeInvoiceDetails.lift(
            try 
    rustCallWithError(FfiConverterTypeDecodeInvoiceError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_decode_invoice(self.pointer, 
        FfiConverterString.lower(`invoice`),$0
    )
}
        )
    }

    public func `getPaymentMaxRoutingFeeMode`(`amountSat`: UInt64)  -> MaxRoutingFeeMode {
        return try!  FfiConverterTypeMaxRoutingFeeMode.lift(
            try! 
    rustCall() {
    
    uniffi_lipalightninglib_fn_method_lightningnode_get_payment_max_routing_fee_mode(self.pointer, 
        FfiConverterUInt64.lower(`amountSat`),$0
    )
}
        )
    }

    public func `payInvoice`(`invoice`: String, `metadata`: String) throws {
        try 
    rustCallWithError(FfiConverterTypePayError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_pay_invoice(self.pointer, 
        FfiConverterString.lower(`invoice`),
        FfiConverterString.lower(`metadata`),$0
    )
}
    }

    public func `payOpenInvoice`(`invoice`: String, `amountSat`: UInt64, `metadata`: String) throws {
        try 
    rustCallWithError(FfiConverterTypePayError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_pay_open_invoice(self.pointer, 
        FfiConverterString.lower(`invoice`),
        FfiConverterUInt64.lower(`amountSat`),
        FfiConverterString.lower(`metadata`),$0
    )
}
    }

    public func `getLatestPayments`(`numberOfPayments`: UInt32) throws -> [Payment] {
        return try  FfiConverterSequenceTypePayment.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_get_latest_payments(self.pointer, 
        FfiConverterUInt32.lower(`numberOfPayments`),$0
    )
}
        )
    }

    public func `getPayment`(`hash`: String) throws -> Payment {
        return try  FfiConverterTypePayment.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_get_payment(self.pointer, 
        FfiConverterString.lower(`hash`),$0
    )
}
        )
    }

    public func `foreground`()  {
        try! 
    rustCall() {
    
    uniffi_lipalightninglib_fn_method_lightningnode_foreground(self.pointer, $0
    )
}
    }

    public func `background`()  {
        try! 
    rustCall() {
    
    uniffi_lipalightninglib_fn_method_lightningnode_background(self.pointer, $0
    )
}
    }

    public func `listCurrencyCodes`()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_lipalightninglib_fn_method_lightningnode_list_currency_codes(self.pointer, $0
    )
}
        )
    }

    public func `getExchangeRate`()  -> ExchangeRate? {
        return try!  FfiConverterOptionTypeExchangeRate.lift(
            try! 
    rustCall() {
    
    uniffi_lipalightninglib_fn_method_lightningnode_get_exchange_rate(self.pointer, $0
    )
}
        )
    }

    public func `changeFiatCurrency`(`fiatCurrency`: String)  {
        try! 
    rustCall() {
    
    uniffi_lipalightninglib_fn_method_lightningnode_change_fiat_currency(self.pointer, 
        FfiConverterString.lower(`fiatCurrency`),$0
    )
}
    }

    public func `changeTimezoneConfig`(`timezoneConfig`: TzConfig)  {
        try! 
    rustCall() {
    
    uniffi_lipalightninglib_fn_method_lightningnode_change_timezone_config(self.pointer, 
        FfiConverterTypeTzConfig.lower(`timezoneConfig`),$0
    )
}
    }

    public func `acceptPocketTermsAndConditions`() throws {
        try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_accept_pocket_terms_and_conditions(self.pointer, $0
    )
}
    }

    public func `registerFiatTopup`(`email`: String?, `userIban`: String, `userCurrency`: TopupCurrency) throws -> FiatTopupInfo {
        return try  FfiConverterTypeFiatTopupInfo.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_register_fiat_topup(self.pointer, 
        FfiConverterOptionString.lower(`email`),
        FfiConverterString.lower(`userIban`),
        FfiConverterTypeTopupCurrency.lower(`userCurrency`),$0
    )
}
        )
    }

    public func `queryUncompletedOffers`() throws -> [OfferInfo] {
        return try  FfiConverterSequenceTypeOfferInfo.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_query_uncompleted_offers(self.pointer, $0
    )
}
        )
    }

    public func `requestOfferCollection`(`offer`: OfferInfo) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_request_offer_collection(self.pointer, 
        FfiConverterTypeOfferInfo.lower(`offer`),$0
    )
}
        )
    }

    public func `registerNotificationToken`(`notificationToken`: String, `languageIso6391`: String, `countryIso31661Alpha2`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_register_notification_token(self.pointer, 
        FfiConverterString.lower(`notificationToken`),
        FfiConverterString.lower(`languageIso6391`),
        FfiConverterString.lower(`countryIso31661Alpha2`),$0
    )
}
    }

    public func `getWalletPubkeyId`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_lipalightninglib_fn_method_lightningnode_get_wallet_pubkey_id(self.pointer, $0
    )
}
        )
    }

    public func `getPaymentUuid`(`paymentHash`: String) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_method_lightningnode_get_payment_uuid(self.pointer, 
        FfiConverterString.lower(`paymentHash`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeLightningNode: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LightningNode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LightningNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LightningNode {
        return LightningNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LightningNode) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeLightningNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> LightningNode {
    return try FfiConverterTypeLightningNode.lift(pointer)
}

public func FfiConverterTypeLightningNode_lower(_ value: LightningNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLightningNode.lower(value)
}


public struct Amount {
    public var `sats`: UInt64
    public var `fiat`: FiatValue?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`sats`: UInt64, `fiat`: FiatValue?) {
        self.`sats` = `sats`
        self.`fiat` = `fiat`
    }
}


extension Amount: Equatable, Hashable {
    public static func ==(lhs: Amount, rhs: Amount) -> Bool {
        if lhs.`sats` != rhs.`sats` {
            return false
        }
        if lhs.`fiat` != rhs.`fiat` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`sats`)
        hasher.combine(`fiat`)
    }
}


public struct FfiConverterTypeAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        return try Amount(
            `sats`: FfiConverterUInt64.read(from: &buf), 
            `fiat`: FfiConverterOptionTypeFiatValue.read(from: &buf)
        )
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`sats`, into: &buf)
        FfiConverterOptionTypeFiatValue.write(value.`fiat`, into: &buf)
    }
}


public func FfiConverterTypeAmount_lift(_ buf: RustBuffer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(buf)
}

public func FfiConverterTypeAmount_lower(_ value: Amount) -> RustBuffer {
    return FfiConverterTypeAmount.lower(value)
}


public struct ChannelsInfo {
    public var `numChannels`: UInt16
    public var `numUsableChannels`: UInt16
    public var `localBalance`: Amount
    public var `totalChannelCapacities`: Amount
    public var `inboundCapacity`: Amount
    public var `outboundCapacity`: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`numChannels`: UInt16, `numUsableChannels`: UInt16, `localBalance`: Amount, `totalChannelCapacities`: Amount, `inboundCapacity`: Amount, `outboundCapacity`: Amount) {
        self.`numChannels` = `numChannels`
        self.`numUsableChannels` = `numUsableChannels`
        self.`localBalance` = `localBalance`
        self.`totalChannelCapacities` = `totalChannelCapacities`
        self.`inboundCapacity` = `inboundCapacity`
        self.`outboundCapacity` = `outboundCapacity`
    }
}


extension ChannelsInfo: Equatable, Hashable {
    public static func ==(lhs: ChannelsInfo, rhs: ChannelsInfo) -> Bool {
        if lhs.`numChannels` != rhs.`numChannels` {
            return false
        }
        if lhs.`numUsableChannels` != rhs.`numUsableChannels` {
            return false
        }
        if lhs.`localBalance` != rhs.`localBalance` {
            return false
        }
        if lhs.`totalChannelCapacities` != rhs.`totalChannelCapacities` {
            return false
        }
        if lhs.`inboundCapacity` != rhs.`inboundCapacity` {
            return false
        }
        if lhs.`outboundCapacity` != rhs.`outboundCapacity` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`numChannels`)
        hasher.combine(`numUsableChannels`)
        hasher.combine(`localBalance`)
        hasher.combine(`totalChannelCapacities`)
        hasher.combine(`inboundCapacity`)
        hasher.combine(`outboundCapacity`)
    }
}


public struct FfiConverterTypeChannelsInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelsInfo {
        return try ChannelsInfo(
            `numChannels`: FfiConverterUInt16.read(from: &buf), 
            `numUsableChannels`: FfiConverterUInt16.read(from: &buf), 
            `localBalance`: FfiConverterTypeAmount.read(from: &buf), 
            `totalChannelCapacities`: FfiConverterTypeAmount.read(from: &buf), 
            `inboundCapacity`: FfiConverterTypeAmount.read(from: &buf), 
            `outboundCapacity`: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: ChannelsInfo, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.`numChannels`, into: &buf)
        FfiConverterUInt16.write(value.`numUsableChannels`, into: &buf)
        FfiConverterTypeAmount.write(value.`localBalance`, into: &buf)
        FfiConverterTypeAmount.write(value.`totalChannelCapacities`, into: &buf)
        FfiConverterTypeAmount.write(value.`inboundCapacity`, into: &buf)
        FfiConverterTypeAmount.write(value.`outboundCapacity`, into: &buf)
    }
}


public func FfiConverterTypeChannelsInfo_lift(_ buf: RustBuffer) throws -> ChannelsInfo {
    return try FfiConverterTypeChannelsInfo.lift(buf)
}

public func FfiConverterTypeChannelsInfo_lower(_ value: ChannelsInfo) -> RustBuffer {
    return FfiConverterTypeChannelsInfo.lower(value)
}


public struct Config {
    public var `environment`: EnvironmentCode
    public var `seed`: Data
    public var `fiatCurrency`: String
    public var `localPersistencePath`: String
    public var `timezoneConfig`: TzConfig
    public var `enableFileLogging`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`environment`: EnvironmentCode, `seed`: Data, `fiatCurrency`: String, `localPersistencePath`: String, `timezoneConfig`: TzConfig, `enableFileLogging`: Bool) {
        self.`environment` = `environment`
        self.`seed` = `seed`
        self.`fiatCurrency` = `fiatCurrency`
        self.`localPersistencePath` = `localPersistencePath`
        self.`timezoneConfig` = `timezoneConfig`
        self.`enableFileLogging` = `enableFileLogging`
    }
}


extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.`environment` != rhs.`environment` {
            return false
        }
        if lhs.`seed` != rhs.`seed` {
            return false
        }
        if lhs.`fiatCurrency` != rhs.`fiatCurrency` {
            return false
        }
        if lhs.`localPersistencePath` != rhs.`localPersistencePath` {
            return false
        }
        if lhs.`timezoneConfig` != rhs.`timezoneConfig` {
            return false
        }
        if lhs.`enableFileLogging` != rhs.`enableFileLogging` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`environment`)
        hasher.combine(`seed`)
        hasher.combine(`fiatCurrency`)
        hasher.combine(`localPersistencePath`)
        hasher.combine(`timezoneConfig`)
        hasher.combine(`enableFileLogging`)
    }
}


public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return try Config(
            `environment`: FfiConverterTypeEnvironmentCode.read(from: &buf), 
            `seed`: FfiConverterData.read(from: &buf), 
            `fiatCurrency`: FfiConverterString.read(from: &buf), 
            `localPersistencePath`: FfiConverterString.read(from: &buf), 
            `timezoneConfig`: FfiConverterTypeTzConfig.read(from: &buf), 
            `enableFileLogging`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterTypeEnvironmentCode.write(value.`environment`, into: &buf)
        FfiConverterData.write(value.`seed`, into: &buf)
        FfiConverterString.write(value.`fiatCurrency`, into: &buf)
        FfiConverterString.write(value.`localPersistencePath`, into: &buf)
        FfiConverterTypeTzConfig.write(value.`timezoneConfig`, into: &buf)
        FfiConverterBool.write(value.`enableFileLogging`, into: &buf)
    }
}


public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}


public struct ExchangeRate {
    public var `currencyCode`: String
    public var `rate`: UInt32
    public var `updatedAt`: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`currencyCode`: String, `rate`: UInt32, `updatedAt`: Date) {
        self.`currencyCode` = `currencyCode`
        self.`rate` = `rate`
        self.`updatedAt` = `updatedAt`
    }
}


extension ExchangeRate: Equatable, Hashable {
    public static func ==(lhs: ExchangeRate, rhs: ExchangeRate) -> Bool {
        if lhs.`currencyCode` != rhs.`currencyCode` {
            return false
        }
        if lhs.`rate` != rhs.`rate` {
            return false
        }
        if lhs.`updatedAt` != rhs.`updatedAt` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`currencyCode`)
        hasher.combine(`rate`)
        hasher.combine(`updatedAt`)
    }
}


public struct FfiConverterTypeExchangeRate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExchangeRate {
        return try ExchangeRate(
            `currencyCode`: FfiConverterString.read(from: &buf), 
            `rate`: FfiConverterUInt32.read(from: &buf), 
            `updatedAt`: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: ExchangeRate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`currencyCode`, into: &buf)
        FfiConverterUInt32.write(value.`rate`, into: &buf)
        FfiConverterTimestamp.write(value.`updatedAt`, into: &buf)
    }
}


public func FfiConverterTypeExchangeRate_lift(_ buf: RustBuffer) throws -> ExchangeRate {
    return try FfiConverterTypeExchangeRate.lift(buf)
}

public func FfiConverterTypeExchangeRate_lower(_ value: ExchangeRate) -> RustBuffer {
    return FfiConverterTypeExchangeRate.lower(value)
}


public struct FiatTopupInfo {
    public var `debitorIban`: String
    public var `creditorReference`: String
    public var `creditorIban`: String
    public var `creditorBankName`: String
    public var `creditorBankStreet`: String
    public var `creditorBankPostalCode`: String
    public var `creditorBankTown`: String
    public var `creditorBankCountry`: String
    public var `creditorBankBic`: String
    public var `creditorName`: String
    public var `creditorStreet`: String
    public var `creditorPostalCode`: String
    public var `creditorTown`: String
    public var `creditorCountry`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`debitorIban`: String, `creditorReference`: String, `creditorIban`: String, `creditorBankName`: String, `creditorBankStreet`: String, `creditorBankPostalCode`: String, `creditorBankTown`: String, `creditorBankCountry`: String, `creditorBankBic`: String, `creditorName`: String, `creditorStreet`: String, `creditorPostalCode`: String, `creditorTown`: String, `creditorCountry`: String) {
        self.`debitorIban` = `debitorIban`
        self.`creditorReference` = `creditorReference`
        self.`creditorIban` = `creditorIban`
        self.`creditorBankName` = `creditorBankName`
        self.`creditorBankStreet` = `creditorBankStreet`
        self.`creditorBankPostalCode` = `creditorBankPostalCode`
        self.`creditorBankTown` = `creditorBankTown`
        self.`creditorBankCountry` = `creditorBankCountry`
        self.`creditorBankBic` = `creditorBankBic`
        self.`creditorName` = `creditorName`
        self.`creditorStreet` = `creditorStreet`
        self.`creditorPostalCode` = `creditorPostalCode`
        self.`creditorTown` = `creditorTown`
        self.`creditorCountry` = `creditorCountry`
    }
}


extension FiatTopupInfo: Equatable, Hashable {
    public static func ==(lhs: FiatTopupInfo, rhs: FiatTopupInfo) -> Bool {
        if lhs.`debitorIban` != rhs.`debitorIban` {
            return false
        }
        if lhs.`creditorReference` != rhs.`creditorReference` {
            return false
        }
        if lhs.`creditorIban` != rhs.`creditorIban` {
            return false
        }
        if lhs.`creditorBankName` != rhs.`creditorBankName` {
            return false
        }
        if lhs.`creditorBankStreet` != rhs.`creditorBankStreet` {
            return false
        }
        if lhs.`creditorBankPostalCode` != rhs.`creditorBankPostalCode` {
            return false
        }
        if lhs.`creditorBankTown` != rhs.`creditorBankTown` {
            return false
        }
        if lhs.`creditorBankCountry` != rhs.`creditorBankCountry` {
            return false
        }
        if lhs.`creditorBankBic` != rhs.`creditorBankBic` {
            return false
        }
        if lhs.`creditorName` != rhs.`creditorName` {
            return false
        }
        if lhs.`creditorStreet` != rhs.`creditorStreet` {
            return false
        }
        if lhs.`creditorPostalCode` != rhs.`creditorPostalCode` {
            return false
        }
        if lhs.`creditorTown` != rhs.`creditorTown` {
            return false
        }
        if lhs.`creditorCountry` != rhs.`creditorCountry` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`debitorIban`)
        hasher.combine(`creditorReference`)
        hasher.combine(`creditorIban`)
        hasher.combine(`creditorBankName`)
        hasher.combine(`creditorBankStreet`)
        hasher.combine(`creditorBankPostalCode`)
        hasher.combine(`creditorBankTown`)
        hasher.combine(`creditorBankCountry`)
        hasher.combine(`creditorBankBic`)
        hasher.combine(`creditorName`)
        hasher.combine(`creditorStreet`)
        hasher.combine(`creditorPostalCode`)
        hasher.combine(`creditorTown`)
        hasher.combine(`creditorCountry`)
    }
}


public struct FfiConverterTypeFiatTopupInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatTopupInfo {
        return try FiatTopupInfo(
            `debitorIban`: FfiConverterString.read(from: &buf), 
            `creditorReference`: FfiConverterString.read(from: &buf), 
            `creditorIban`: FfiConverterString.read(from: &buf), 
            `creditorBankName`: FfiConverterString.read(from: &buf), 
            `creditorBankStreet`: FfiConverterString.read(from: &buf), 
            `creditorBankPostalCode`: FfiConverterString.read(from: &buf), 
            `creditorBankTown`: FfiConverterString.read(from: &buf), 
            `creditorBankCountry`: FfiConverterString.read(from: &buf), 
            `creditorBankBic`: FfiConverterString.read(from: &buf), 
            `creditorName`: FfiConverterString.read(from: &buf), 
            `creditorStreet`: FfiConverterString.read(from: &buf), 
            `creditorPostalCode`: FfiConverterString.read(from: &buf), 
            `creditorTown`: FfiConverterString.read(from: &buf), 
            `creditorCountry`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FiatTopupInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`debitorIban`, into: &buf)
        FfiConverterString.write(value.`creditorReference`, into: &buf)
        FfiConverterString.write(value.`creditorIban`, into: &buf)
        FfiConverterString.write(value.`creditorBankName`, into: &buf)
        FfiConverterString.write(value.`creditorBankStreet`, into: &buf)
        FfiConverterString.write(value.`creditorBankPostalCode`, into: &buf)
        FfiConverterString.write(value.`creditorBankTown`, into: &buf)
        FfiConverterString.write(value.`creditorBankCountry`, into: &buf)
        FfiConverterString.write(value.`creditorBankBic`, into: &buf)
        FfiConverterString.write(value.`creditorName`, into: &buf)
        FfiConverterString.write(value.`creditorStreet`, into: &buf)
        FfiConverterString.write(value.`creditorPostalCode`, into: &buf)
        FfiConverterString.write(value.`creditorTown`, into: &buf)
        FfiConverterString.write(value.`creditorCountry`, into: &buf)
    }
}


public func FfiConverterTypeFiatTopupInfo_lift(_ buf: RustBuffer) throws -> FiatTopupInfo {
    return try FfiConverterTypeFiatTopupInfo.lift(buf)
}

public func FfiConverterTypeFiatTopupInfo_lower(_ value: FiatTopupInfo) -> RustBuffer {
    return FfiConverterTypeFiatTopupInfo.lower(value)
}


public struct FiatValue {
    public var `minorUnits`: UInt64
    public var `currencyCode`: String
    public var `rate`: UInt32
    public var `convertedAt`: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`minorUnits`: UInt64, `currencyCode`: String, `rate`: UInt32, `convertedAt`: Date) {
        self.`minorUnits` = `minorUnits`
        self.`currencyCode` = `currencyCode`
        self.`rate` = `rate`
        self.`convertedAt` = `convertedAt`
    }
}


extension FiatValue: Equatable, Hashable {
    public static func ==(lhs: FiatValue, rhs: FiatValue) -> Bool {
        if lhs.`minorUnits` != rhs.`minorUnits` {
            return false
        }
        if lhs.`currencyCode` != rhs.`currencyCode` {
            return false
        }
        if lhs.`rate` != rhs.`rate` {
            return false
        }
        if lhs.`convertedAt` != rhs.`convertedAt` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`minorUnits`)
        hasher.combine(`currencyCode`)
        hasher.combine(`rate`)
        hasher.combine(`convertedAt`)
    }
}


public struct FfiConverterTypeFiatValue: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatValue {
        return try FiatValue(
            `minorUnits`: FfiConverterUInt64.read(from: &buf), 
            `currencyCode`: FfiConverterString.read(from: &buf), 
            `rate`: FfiConverterUInt32.read(from: &buf), 
            `convertedAt`: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: FiatValue, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`minorUnits`, into: &buf)
        FfiConverterString.write(value.`currencyCode`, into: &buf)
        FfiConverterUInt32.write(value.`rate`, into: &buf)
        FfiConverterTimestamp.write(value.`convertedAt`, into: &buf)
    }
}


public func FfiConverterTypeFiatValue_lift(_ buf: RustBuffer) throws -> FiatValue {
    return try FfiConverterTypeFiatValue.lift(buf)
}

public func FfiConverterTypeFiatValue_lower(_ value: FiatValue) -> RustBuffer {
    return FfiConverterTypeFiatValue.lower(value)
}


public struct InvoiceDetails {
    public var `invoice`: String
    public var `amount`: Amount?
    public var `description`: String
    public var `paymentHash`: String
    public var `payeePubKey`: String
    public var `creationTimestamp`: Date
    public var `expiryInterval`: TimeInterval
    public var `expiryTimestamp`: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`invoice`: String, `amount`: Amount?, `description`: String, `paymentHash`: String, `payeePubKey`: String, `creationTimestamp`: Date, `expiryInterval`: TimeInterval, `expiryTimestamp`: Date) {
        self.`invoice` = `invoice`
        self.`amount` = `amount`
        self.`description` = `description`
        self.`paymentHash` = `paymentHash`
        self.`payeePubKey` = `payeePubKey`
        self.`creationTimestamp` = `creationTimestamp`
        self.`expiryInterval` = `expiryInterval`
        self.`expiryTimestamp` = `expiryTimestamp`
    }
}


extension InvoiceDetails: Equatable, Hashable {
    public static func ==(lhs: InvoiceDetails, rhs: InvoiceDetails) -> Bool {
        if lhs.`invoice` != rhs.`invoice` {
            return false
        }
        if lhs.`amount` != rhs.`amount` {
            return false
        }
        if lhs.`description` != rhs.`description` {
            return false
        }
        if lhs.`paymentHash` != rhs.`paymentHash` {
            return false
        }
        if lhs.`payeePubKey` != rhs.`payeePubKey` {
            return false
        }
        if lhs.`creationTimestamp` != rhs.`creationTimestamp` {
            return false
        }
        if lhs.`expiryInterval` != rhs.`expiryInterval` {
            return false
        }
        if lhs.`expiryTimestamp` != rhs.`expiryTimestamp` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`invoice`)
        hasher.combine(`amount`)
        hasher.combine(`description`)
        hasher.combine(`paymentHash`)
        hasher.combine(`payeePubKey`)
        hasher.combine(`creationTimestamp`)
        hasher.combine(`expiryInterval`)
        hasher.combine(`expiryTimestamp`)
    }
}


public struct FfiConverterTypeInvoiceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvoiceDetails {
        return try InvoiceDetails(
            `invoice`: FfiConverterString.read(from: &buf), 
            `amount`: FfiConverterOptionTypeAmount.read(from: &buf), 
            `description`: FfiConverterString.read(from: &buf), 
            `paymentHash`: FfiConverterString.read(from: &buf), 
            `payeePubKey`: FfiConverterString.read(from: &buf), 
            `creationTimestamp`: FfiConverterTimestamp.read(from: &buf), 
            `expiryInterval`: FfiConverterDuration.read(from: &buf), 
            `expiryTimestamp`: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: InvoiceDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`invoice`, into: &buf)
        FfiConverterOptionTypeAmount.write(value.`amount`, into: &buf)
        FfiConverterString.write(value.`description`, into: &buf)
        FfiConverterString.write(value.`paymentHash`, into: &buf)
        FfiConverterString.write(value.`payeePubKey`, into: &buf)
        FfiConverterTimestamp.write(value.`creationTimestamp`, into: &buf)
        FfiConverterDuration.write(value.`expiryInterval`, into: &buf)
        FfiConverterTimestamp.write(value.`expiryTimestamp`, into: &buf)
    }
}


public func FfiConverterTypeInvoiceDetails_lift(_ buf: RustBuffer) throws -> InvoiceDetails {
    return try FfiConverterTypeInvoiceDetails.lift(buf)
}

public func FfiConverterTypeInvoiceDetails_lower(_ value: InvoiceDetails) -> RustBuffer {
    return FfiConverterTypeInvoiceDetails.lower(value)
}


public struct LspFee {
    public var `channelMinimumFee`: Amount
    public var `channelFeePermyriad`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`channelMinimumFee`: Amount, `channelFeePermyriad`: UInt64) {
        self.`channelMinimumFee` = `channelMinimumFee`
        self.`channelFeePermyriad` = `channelFeePermyriad`
    }
}


extension LspFee: Equatable, Hashable {
    public static func ==(lhs: LspFee, rhs: LspFee) -> Bool {
        if lhs.`channelMinimumFee` != rhs.`channelMinimumFee` {
            return false
        }
        if lhs.`channelFeePermyriad` != rhs.`channelFeePermyriad` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`channelMinimumFee`)
        hasher.combine(`channelFeePermyriad`)
    }
}


public struct FfiConverterTypeLspFee: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LspFee {
        return try LspFee(
            `channelMinimumFee`: FfiConverterTypeAmount.read(from: &buf), 
            `channelFeePermyriad`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LspFee, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.`channelMinimumFee`, into: &buf)
        FfiConverterUInt64.write(value.`channelFeePermyriad`, into: &buf)
    }
}


public func FfiConverterTypeLspFee_lift(_ buf: RustBuffer) throws -> LspFee {
    return try FfiConverterTypeLspFee.lift(buf)
}

public func FfiConverterTypeLspFee_lower(_ value: LspFee) -> RustBuffer {
    return FfiConverterTypeLspFee.lower(value)
}


public struct NodeInfo {
    public var `nodePubkey`: String
    public var `peers`: [String]
    public var `channelsInfo`: ChannelsInfo

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`nodePubkey`: String, `peers`: [String], `channelsInfo`: ChannelsInfo) {
        self.`nodePubkey` = `nodePubkey`
        self.`peers` = `peers`
        self.`channelsInfo` = `channelsInfo`
    }
}


extension NodeInfo: Equatable, Hashable {
    public static func ==(lhs: NodeInfo, rhs: NodeInfo) -> Bool {
        if lhs.`nodePubkey` != rhs.`nodePubkey` {
            return false
        }
        if lhs.`peers` != rhs.`peers` {
            return false
        }
        if lhs.`channelsInfo` != rhs.`channelsInfo` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`nodePubkey`)
        hasher.combine(`peers`)
        hasher.combine(`channelsInfo`)
    }
}


public struct FfiConverterTypeNodeInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeInfo {
        return try NodeInfo(
            `nodePubkey`: FfiConverterString.read(from: &buf), 
            `peers`: FfiConverterSequenceString.read(from: &buf), 
            `channelsInfo`: FfiConverterTypeChannelsInfo.read(from: &buf)
        )
    }

    public static func write(_ value: NodeInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`nodePubkey`, into: &buf)
        FfiConverterSequenceString.write(value.`peers`, into: &buf)
        FfiConverterTypeChannelsInfo.write(value.`channelsInfo`, into: &buf)
    }
}


public func FfiConverterTypeNodeInfo_lift(_ buf: RustBuffer) throws -> NodeInfo {
    return try FfiConverterTypeNodeInfo.lift(buf)
}

public func FfiConverterTypeNodeInfo_lower(_ value: NodeInfo) -> RustBuffer {
    return FfiConverterTypeNodeInfo.lower(value)
}


public struct OfferInfo {
    public var `offerKind`: OfferKind
    public var `amount`: Amount
    public var `lnurlw`: String
    public var `createdAt`: Date
    public var `expiresAt`: Date
    public var `status`: OfferStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`offerKind`: OfferKind, `amount`: Amount, `lnurlw`: String, `createdAt`: Date, `expiresAt`: Date, `status`: OfferStatus) {
        self.`offerKind` = `offerKind`
        self.`amount` = `amount`
        self.`lnurlw` = `lnurlw`
        self.`createdAt` = `createdAt`
        self.`expiresAt` = `expiresAt`
        self.`status` = `status`
    }
}


extension OfferInfo: Equatable, Hashable {
    public static func ==(lhs: OfferInfo, rhs: OfferInfo) -> Bool {
        if lhs.`offerKind` != rhs.`offerKind` {
            return false
        }
        if lhs.`amount` != rhs.`amount` {
            return false
        }
        if lhs.`lnurlw` != rhs.`lnurlw` {
            return false
        }
        if lhs.`createdAt` != rhs.`createdAt` {
            return false
        }
        if lhs.`expiresAt` != rhs.`expiresAt` {
            return false
        }
        if lhs.`status` != rhs.`status` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`offerKind`)
        hasher.combine(`amount`)
        hasher.combine(`lnurlw`)
        hasher.combine(`createdAt`)
        hasher.combine(`expiresAt`)
        hasher.combine(`status`)
    }
}


public struct FfiConverterTypeOfferInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferInfo {
        return try OfferInfo(
            `offerKind`: FfiConverterTypeOfferKind.read(from: &buf), 
            `amount`: FfiConverterTypeAmount.read(from: &buf), 
            `lnurlw`: FfiConverterString.read(from: &buf), 
            `createdAt`: FfiConverterTimestamp.read(from: &buf), 
            `expiresAt`: FfiConverterTimestamp.read(from: &buf), 
            `status`: FfiConverterTypeOfferStatus.read(from: &buf)
        )
    }

    public static func write(_ value: OfferInfo, into buf: inout [UInt8]) {
        FfiConverterTypeOfferKind.write(value.`offerKind`, into: &buf)
        FfiConverterTypeAmount.write(value.`amount`, into: &buf)
        FfiConverterString.write(value.`lnurlw`, into: &buf)
        FfiConverterTimestamp.write(value.`createdAt`, into: &buf)
        FfiConverterTimestamp.write(value.`expiresAt`, into: &buf)
        FfiConverterTypeOfferStatus.write(value.`status`, into: &buf)
    }
}


public func FfiConverterTypeOfferInfo_lift(_ buf: RustBuffer) throws -> OfferInfo {
    return try FfiConverterTypeOfferInfo.lift(buf)
}

public func FfiConverterTypeOfferInfo_lower(_ value: OfferInfo) -> RustBuffer {
    return FfiConverterTypeOfferInfo.lower(value)
}


public struct Payment {
    public var `paymentType`: PaymentType
    public var `paymentState`: PaymentState
    public var `failReason`: PayErrorCode?
    public var `hash`: String
    public var `amount`: Amount
    public var `invoiceDetails`: InvoiceDetails
    public var `createdAt`: TzTime
    public var `latestStateChangeAt`: TzTime
    public var `description`: String
    public var `preimage`: String?
    public var `networkFees`: Amount?
    public var `lspFees`: Amount?
    public var `offer`: OfferKind?
    public var `metadata`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`paymentType`: PaymentType, `paymentState`: PaymentState, `failReason`: PayErrorCode?, `hash`: String, `amount`: Amount, `invoiceDetails`: InvoiceDetails, `createdAt`: TzTime, `latestStateChangeAt`: TzTime, `description`: String, `preimage`: String?, `networkFees`: Amount?, `lspFees`: Amount?, `offer`: OfferKind?, `metadata`: String) {
        self.`paymentType` = `paymentType`
        self.`paymentState` = `paymentState`
        self.`failReason` = `failReason`
        self.`hash` = `hash`
        self.`amount` = `amount`
        self.`invoiceDetails` = `invoiceDetails`
        self.`createdAt` = `createdAt`
        self.`latestStateChangeAt` = `latestStateChangeAt`
        self.`description` = `description`
        self.`preimage` = `preimage`
        self.`networkFees` = `networkFees`
        self.`lspFees` = `lspFees`
        self.`offer` = `offer`
        self.`metadata` = `metadata`
    }
}


extension Payment: Equatable, Hashable {
    public static func ==(lhs: Payment, rhs: Payment) -> Bool {
        if lhs.`paymentType` != rhs.`paymentType` {
            return false
        }
        if lhs.`paymentState` != rhs.`paymentState` {
            return false
        }
        if lhs.`failReason` != rhs.`failReason` {
            return false
        }
        if lhs.`hash` != rhs.`hash` {
            return false
        }
        if lhs.`amount` != rhs.`amount` {
            return false
        }
        if lhs.`invoiceDetails` != rhs.`invoiceDetails` {
            return false
        }
        if lhs.`createdAt` != rhs.`createdAt` {
            return false
        }
        if lhs.`latestStateChangeAt` != rhs.`latestStateChangeAt` {
            return false
        }
        if lhs.`description` != rhs.`description` {
            return false
        }
        if lhs.`preimage` != rhs.`preimage` {
            return false
        }
        if lhs.`networkFees` != rhs.`networkFees` {
            return false
        }
        if lhs.`lspFees` != rhs.`lspFees` {
            return false
        }
        if lhs.`offer` != rhs.`offer` {
            return false
        }
        if lhs.`metadata` != rhs.`metadata` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`paymentType`)
        hasher.combine(`paymentState`)
        hasher.combine(`failReason`)
        hasher.combine(`hash`)
        hasher.combine(`amount`)
        hasher.combine(`invoiceDetails`)
        hasher.combine(`createdAt`)
        hasher.combine(`latestStateChangeAt`)
        hasher.combine(`description`)
        hasher.combine(`preimage`)
        hasher.combine(`networkFees`)
        hasher.combine(`lspFees`)
        hasher.combine(`offer`)
        hasher.combine(`metadata`)
    }
}


public struct FfiConverterTypePayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Payment {
        return try Payment(
            `paymentType`: FfiConverterTypePaymentType.read(from: &buf), 
            `paymentState`: FfiConverterTypePaymentState.read(from: &buf), 
            `failReason`: FfiConverterOptionTypePayErrorCode.read(from: &buf), 
            `hash`: FfiConverterString.read(from: &buf), 
            `amount`: FfiConverterTypeAmount.read(from: &buf), 
            `invoiceDetails`: FfiConverterTypeInvoiceDetails.read(from: &buf), 
            `createdAt`: FfiConverterTypeTzTime.read(from: &buf), 
            `latestStateChangeAt`: FfiConverterTypeTzTime.read(from: &buf), 
            `description`: FfiConverterString.read(from: &buf), 
            `preimage`: FfiConverterOptionString.read(from: &buf), 
            `networkFees`: FfiConverterOptionTypeAmount.read(from: &buf), 
            `lspFees`: FfiConverterOptionTypeAmount.read(from: &buf), 
            `offer`: FfiConverterOptionTypeOfferKind.read(from: &buf), 
            `metadata`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Payment, into buf: inout [UInt8]) {
        FfiConverterTypePaymentType.write(value.`paymentType`, into: &buf)
        FfiConverterTypePaymentState.write(value.`paymentState`, into: &buf)
        FfiConverterOptionTypePayErrorCode.write(value.`failReason`, into: &buf)
        FfiConverterString.write(value.`hash`, into: &buf)
        FfiConverterTypeAmount.write(value.`amount`, into: &buf)
        FfiConverterTypeInvoiceDetails.write(value.`invoiceDetails`, into: &buf)
        FfiConverterTypeTzTime.write(value.`createdAt`, into: &buf)
        FfiConverterTypeTzTime.write(value.`latestStateChangeAt`, into: &buf)
        FfiConverterString.write(value.`description`, into: &buf)
        FfiConverterOptionString.write(value.`preimage`, into: &buf)
        FfiConverterOptionTypeAmount.write(value.`networkFees`, into: &buf)
        FfiConverterOptionTypeAmount.write(value.`lspFees`, into: &buf)
        FfiConverterOptionTypeOfferKind.write(value.`offer`, into: &buf)
        FfiConverterString.write(value.`metadata`, into: &buf)
    }
}


public func FfiConverterTypePayment_lift(_ buf: RustBuffer) throws -> Payment {
    return try FfiConverterTypePayment.lift(buf)
}

public func FfiConverterTypePayment_lower(_ value: Payment) -> RustBuffer {
    return FfiConverterTypePayment.lower(value)
}


public struct PaymentAmountLimits {
    public var `maxReceive`: Amount
    public var `liquidityLimit`: LiquidityLimit

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`maxReceive`: Amount, `liquidityLimit`: LiquidityLimit) {
        self.`maxReceive` = `maxReceive`
        self.`liquidityLimit` = `liquidityLimit`
    }
}


extension PaymentAmountLimits: Equatable, Hashable {
    public static func ==(lhs: PaymentAmountLimits, rhs: PaymentAmountLimits) -> Bool {
        if lhs.`maxReceive` != rhs.`maxReceive` {
            return false
        }
        if lhs.`liquidityLimit` != rhs.`liquidityLimit` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`maxReceive`)
        hasher.combine(`liquidityLimit`)
    }
}


public struct FfiConverterTypePaymentAmountLimits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentAmountLimits {
        return try PaymentAmountLimits(
            `maxReceive`: FfiConverterTypeAmount.read(from: &buf), 
            `liquidityLimit`: FfiConverterTypeLiquidityLimit.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentAmountLimits, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.`maxReceive`, into: &buf)
        FfiConverterTypeLiquidityLimit.write(value.`liquidityLimit`, into: &buf)
    }
}


public func FfiConverterTypePaymentAmountLimits_lift(_ buf: RustBuffer) throws -> PaymentAmountLimits {
    return try FfiConverterTypePaymentAmountLimits.lift(buf)
}

public func FfiConverterTypePaymentAmountLimits_lower(_ value: PaymentAmountLimits) -> RustBuffer {
    return FfiConverterTypePaymentAmountLimits.lower(value)
}


public struct Secret {
    public var `mnemonic`: [String]
    public var `passphrase`: String
    public var `seed`: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`mnemonic`: [String], `passphrase`: String, `seed`: Data) {
        self.`mnemonic` = `mnemonic`
        self.`passphrase` = `passphrase`
        self.`seed` = `seed`
    }
}


extension Secret: Equatable, Hashable {
    public static func ==(lhs: Secret, rhs: Secret) -> Bool {
        if lhs.`mnemonic` != rhs.`mnemonic` {
            return false
        }
        if lhs.`passphrase` != rhs.`passphrase` {
            return false
        }
        if lhs.`seed` != rhs.`seed` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`mnemonic`)
        hasher.combine(`passphrase`)
        hasher.combine(`seed`)
    }
}


public struct FfiConverterTypeSecret: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secret {
        return try Secret(
            `mnemonic`: FfiConverterSequenceString.read(from: &buf), 
            `passphrase`: FfiConverterString.read(from: &buf), 
            `seed`: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Secret, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.`mnemonic`, into: &buf)
        FfiConverterString.write(value.`passphrase`, into: &buf)
        FfiConverterData.write(value.`seed`, into: &buf)
    }
}


public func FfiConverterTypeSecret_lift(_ buf: RustBuffer) throws -> Secret {
    return try FfiConverterTypeSecret.lift(buf)
}

public func FfiConverterTypeSecret_lower(_ value: Secret) -> RustBuffer {
    return FfiConverterTypeSecret.lower(value)
}


public struct TzConfig {
    public var `timezoneId`: String
    public var `timezoneUtcOffsetSecs`: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`timezoneId`: String, `timezoneUtcOffsetSecs`: Int32) {
        self.`timezoneId` = `timezoneId`
        self.`timezoneUtcOffsetSecs` = `timezoneUtcOffsetSecs`
    }
}


extension TzConfig: Equatable, Hashable {
    public static func ==(lhs: TzConfig, rhs: TzConfig) -> Bool {
        if lhs.`timezoneId` != rhs.`timezoneId` {
            return false
        }
        if lhs.`timezoneUtcOffsetSecs` != rhs.`timezoneUtcOffsetSecs` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`timezoneId`)
        hasher.combine(`timezoneUtcOffsetSecs`)
    }
}


public struct FfiConverterTypeTzConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TzConfig {
        return try TzConfig(
            `timezoneId`: FfiConverterString.read(from: &buf), 
            `timezoneUtcOffsetSecs`: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: TzConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`timezoneId`, into: &buf)
        FfiConverterInt32.write(value.`timezoneUtcOffsetSecs`, into: &buf)
    }
}


public func FfiConverterTypeTzConfig_lift(_ buf: RustBuffer) throws -> TzConfig {
    return try FfiConverterTypeTzConfig.lift(buf)
}

public func FfiConverterTypeTzConfig_lower(_ value: TzConfig) -> RustBuffer {
    return FfiConverterTypeTzConfig.lower(value)
}


public struct TzTime {
    public var `time`: Date
    public var `timezoneId`: String
    public var `timezoneUtcOffsetSecs`: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`time`: Date, `timezoneId`: String, `timezoneUtcOffsetSecs`: Int32) {
        self.`time` = `time`
        self.`timezoneId` = `timezoneId`
        self.`timezoneUtcOffsetSecs` = `timezoneUtcOffsetSecs`
    }
}


extension TzTime: Equatable, Hashable {
    public static func ==(lhs: TzTime, rhs: TzTime) -> Bool {
        if lhs.`time` != rhs.`time` {
            return false
        }
        if lhs.`timezoneId` != rhs.`timezoneId` {
            return false
        }
        if lhs.`timezoneUtcOffsetSecs` != rhs.`timezoneUtcOffsetSecs` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`time`)
        hasher.combine(`timezoneId`)
        hasher.combine(`timezoneUtcOffsetSecs`)
    }
}


public struct FfiConverterTypeTzTime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TzTime {
        return try TzTime(
            `time`: FfiConverterTimestamp.read(from: &buf), 
            `timezoneId`: FfiConverterString.read(from: &buf), 
            `timezoneUtcOffsetSecs`: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: TzTime, into buf: inout [UInt8]) {
        FfiConverterTimestamp.write(value.`time`, into: &buf)
        FfiConverterString.write(value.`timezoneId`, into: &buf)
        FfiConverterInt32.write(value.`timezoneUtcOffsetSecs`, into: &buf)
    }
}


public func FfiConverterTypeTzTime_lift(_ buf: RustBuffer) throws -> TzTime {
    return try FfiConverterTypeTzTime.lift(buf)
}

public func FfiConverterTypeTzTime_lower(_ value: TzTime) -> RustBuffer {
    return FfiConverterTypeTzTime.lower(value)
}

public enum DecodeInvoiceError {

    
    
    case ParseError(`msg`: String)
    case SemanticError(`msg`: String)
    case NetworkMismatch(`expected`: Network, `found`: Network)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeDecodeInvoiceError.lift(error)
    }
}


public struct FfiConverterTypeDecodeInvoiceError: FfiConverterRustBuffer {
    typealias SwiftType = DecodeInvoiceError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecodeInvoiceError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ParseError(
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 2: return .SemanticError(
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 3: return .NetworkMismatch(
            `expected`: try FfiConverterTypeNetwork.read(from: &buf), 
            `found`: try FfiConverterTypeNetwork.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecodeInvoiceError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ParseError(`msg`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`msg`, into: &buf)
            
        
        case let .SemanticError(`msg`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`msg`, into: &buf)
            
        
        case let .NetworkMismatch(`expected`,`found`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNetwork.write(`expected`, into: &buf)
            FfiConverterTypeNetwork.write(`found`, into: &buf)
            
        }
    }
}


extension DecodeInvoiceError: Equatable, Hashable {}

extension DecodeInvoiceError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EnvironmentCode {
    
    case `local`
    case `dev`
    case `stage`
    case `prod`
}

public struct FfiConverterTypeEnvironmentCode: FfiConverterRustBuffer {
    typealias SwiftType = EnvironmentCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnvironmentCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`local`
        
        case 2: return .`dev`
        
        case 3: return .`stage`
        
        case 4: return .`prod`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EnvironmentCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`local`:
            writeInt(&buf, Int32(1))
        
        
        case .`dev`:
            writeInt(&buf, Int32(2))
        
        
        case .`stage`:
            writeInt(&buf, Int32(3))
        
        
        case .`prod`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeEnvironmentCode_lift(_ buf: RustBuffer) throws -> EnvironmentCode {
    return try FfiConverterTypeEnvironmentCode.lift(buf)
}

public func FfiConverterTypeEnvironmentCode_lower(_ value: EnvironmentCode) -> RustBuffer {
    return FfiConverterTypeEnvironmentCode.lower(value)
}


extension EnvironmentCode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LiquidityLimit {
    
    case `none`
    case `maxFreeReceive`(`amount`: Amount)
    case `minReceive`(`amount`: Amount)
}

public struct FfiConverterTypeLiquidityLimit: FfiConverterRustBuffer {
    typealias SwiftType = LiquidityLimit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiquidityLimit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`none`
        
        case 2: return .`maxFreeReceive`(
            `amount`: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        case 3: return .`minReceive`(
            `amount`: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LiquidityLimit, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`none`:
            writeInt(&buf, Int32(1))
        
        
        case let .`maxFreeReceive`(`amount`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAmount.write(`amount`, into: &buf)
            
        
        case let .`minReceive`(`amount`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAmount.write(`amount`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLiquidityLimit_lift(_ buf: RustBuffer) throws -> LiquidityLimit {
    return try FfiConverterTypeLiquidityLimit.lift(buf)
}

public func FfiConverterTypeLiquidityLimit_lower(_ value: LiquidityLimit) -> RustBuffer {
    return FfiConverterTypeLiquidityLimit.lower(value)
}


extension LiquidityLimit: Equatable, Hashable {}



public enum LnError {

    
    
    case InvalidInput(`msg`: String)
    case RuntimeError(`code`: RuntimeErrorCode, `msg`: String)
    case PermanentFailure(`msg`: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeLnError.lift(error)
    }
}


public struct FfiConverterTypeLnError: FfiConverterRustBuffer {
    typealias SwiftType = LnError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidInput(
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 2: return .RuntimeError(
            `code`: try FfiConverterTypeRuntimeErrorCode.read(from: &buf), 
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 3: return .PermanentFailure(
            `msg`: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidInput(`msg`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`msg`, into: &buf)
            
        
        case let .RuntimeError(`code`,`msg`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeRuntimeErrorCode.write(`code`, into: &buf)
            FfiConverterString.write(`msg`, into: &buf)
            
        
        case let .PermanentFailure(`msg`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`msg`, into: &buf)
            
        }
    }
}


extension LnError: Equatable, Hashable {}

extension LnError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MaxRoutingFeeMode {
    
    case `relative`(`maxFeePermyriad`: UInt16)
    case `absolute`(`maxFeeAmount`: Amount)
}

public struct FfiConverterTypeMaxRoutingFeeMode: FfiConverterRustBuffer {
    typealias SwiftType = MaxRoutingFeeMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MaxRoutingFeeMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`relative`(
            `maxFeePermyriad`: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 2: return .`absolute`(
            `maxFeeAmount`: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MaxRoutingFeeMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`relative`(`maxFeePermyriad`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt16.write(`maxFeePermyriad`, into: &buf)
            
        
        case let .`absolute`(`maxFeeAmount`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAmount.write(`maxFeeAmount`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMaxRoutingFeeMode_lift(_ buf: RustBuffer) throws -> MaxRoutingFeeMode {
    return try FfiConverterTypeMaxRoutingFeeMode.lift(buf)
}

public func FfiConverterTypeMaxRoutingFeeMode_lower(_ value: MaxRoutingFeeMode) -> RustBuffer {
    return FfiConverterTypeMaxRoutingFeeMode.lower(value)
}


extension MaxRoutingFeeMode: Equatable, Hashable {}



public enum MnemonicError {

    
    
    case BadWordCount(`count`: UInt64)
    case UnknownWord(`index`: UInt64)
    case BadEntropyBitCount
    case InvalidChecksum
    case AmbiguousLanguages

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeMnemonicError.lift(error)
    }
}


public struct FfiConverterTypeMnemonicError: FfiConverterRustBuffer {
    typealias SwiftType = MnemonicError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BadWordCount(
            `count`: try FfiConverterUInt64.read(from: &buf)
            )
        case 2: return .UnknownWord(
            `index`: try FfiConverterUInt64.read(from: &buf)
            )
        case 3: return .BadEntropyBitCount
        case 4: return .InvalidChecksum
        case 5: return .AmbiguousLanguages

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MnemonicError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .BadWordCount(`count`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(`count`, into: &buf)
            
        
        case let .UnknownWord(`index`):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(`index`, into: &buf)
            
        
        case .BadEntropyBitCount:
            writeInt(&buf, Int32(3))
        
        
        case .InvalidChecksum:
            writeInt(&buf, Int32(4))
        
        
        case .AmbiguousLanguages:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension MnemonicError: Equatable, Hashable {}

extension MnemonicError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Network {
    
    case `bitcoin`
    case `testnet`
    case `signet`
    case `regtest`
}

public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`bitcoin`
        
        case 2: return .`testnet`
        
        case 3: return .`signet`
        
        case 4: return .`regtest`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`bitcoin`:
            writeInt(&buf, Int32(1))
        
        
        case .`testnet`:
            writeInt(&buf, Int32(2))
        
        
        case .`signet`:
            writeInt(&buf, Int32(3))
        
        
        case .`regtest`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}


extension Network: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OfferKind {
    
    case `pocket`(`id`: String, `exchangeRate`: ExchangeRate, `topupValueMinorUnits`: UInt64, `exchangeFeeMinorUnits`: UInt64, `exchangeFeeRatePermyriad`: UInt16)
}

public struct FfiConverterTypeOfferKind: FfiConverterRustBuffer {
    typealias SwiftType = OfferKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`pocket`(
            `id`: try FfiConverterString.read(from: &buf), 
            `exchangeRate`: try FfiConverterTypeExchangeRate.read(from: &buf), 
            `topupValueMinorUnits`: try FfiConverterUInt64.read(from: &buf), 
            `exchangeFeeMinorUnits`: try FfiConverterUInt64.read(from: &buf), 
            `exchangeFeeRatePermyriad`: try FfiConverterUInt16.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OfferKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`pocket`(`id`,`exchangeRate`,`topupValueMinorUnits`,`exchangeFeeMinorUnits`,`exchangeFeeRatePermyriad`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`id`, into: &buf)
            FfiConverterTypeExchangeRate.write(`exchangeRate`, into: &buf)
            FfiConverterUInt64.write(`topupValueMinorUnits`, into: &buf)
            FfiConverterUInt64.write(`exchangeFeeMinorUnits`, into: &buf)
            FfiConverterUInt16.write(`exchangeFeeRatePermyriad`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOfferKind_lift(_ buf: RustBuffer) throws -> OfferKind {
    return try FfiConverterTypeOfferKind.lift(buf)
}

public func FfiConverterTypeOfferKind_lower(_ value: OfferKind) -> RustBuffer {
    return FfiConverterTypeOfferKind.lower(value)
}


extension OfferKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OfferStatus {
    
    case `ready`
    case `failed`
    case `refunded`
    case `settled`
}

public struct FfiConverterTypeOfferStatus: FfiConverterRustBuffer {
    typealias SwiftType = OfferStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`ready`
        
        case 2: return .`failed`
        
        case 3: return .`refunded`
        
        case 4: return .`settled`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OfferStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`ready`:
            writeInt(&buf, Int32(1))
        
        
        case .`failed`:
            writeInt(&buf, Int32(2))
        
        
        case .`refunded`:
            writeInt(&buf, Int32(3))
        
        
        case .`settled`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeOfferStatus_lift(_ buf: RustBuffer) throws -> OfferStatus {
    return try FfiConverterTypeOfferStatus.lift(buf)
}

public func FfiConverterTypeOfferStatus_lower(_ value: OfferStatus) -> RustBuffer {
    return FfiConverterTypeOfferStatus.lower(value)
}


extension OfferStatus: Equatable, Hashable {}



public enum PayError {

    
    
    case InvalidInput(`msg`: String)
    case RuntimeError(`code`: PayErrorCode, `msg`: String)
    case PermanentFailure(`msg`: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypePayError.lift(error)
    }
}


public struct FfiConverterTypePayError: FfiConverterRustBuffer {
    typealias SwiftType = PayError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidInput(
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 2: return .RuntimeError(
            `code`: try FfiConverterTypePayErrorCode.read(from: &buf), 
            `msg`: try FfiConverterString.read(from: &buf)
            )
        case 3: return .PermanentFailure(
            `msg`: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PayError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidInput(`msg`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`msg`, into: &buf)
            
        
        case let .RuntimeError(`code`,`msg`):
            writeInt(&buf, Int32(2))
            FfiConverterTypePayErrorCode.write(`code`, into: &buf)
            FfiConverterString.write(`msg`, into: &buf)
            
        
        case let .PermanentFailure(`msg`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`msg`, into: &buf)
            
        }
    }
}


extension PayError: Equatable, Hashable {}

extension PayError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PayErrorCode {
    
    case `invoiceExpired`
    case `alreadyUsedInvoice`
    case `payingToSelf`
    case `noRouteFound`
    case `recipientRejected`
    case `retriesExhausted`
    case `noMoreRoutes`
    case `unexpectedError`
}

public struct FfiConverterTypePayErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = PayErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`invoiceExpired`
        
        case 2: return .`alreadyUsedInvoice`
        
        case 3: return .`payingToSelf`
        
        case 4: return .`noRouteFound`
        
        case 5: return .`recipientRejected`
        
        case 6: return .`retriesExhausted`
        
        case 7: return .`noMoreRoutes`
        
        case 8: return .`unexpectedError`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PayErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`invoiceExpired`:
            writeInt(&buf, Int32(1))
        
        
        case .`alreadyUsedInvoice`:
            writeInt(&buf, Int32(2))
        
        
        case .`payingToSelf`:
            writeInt(&buf, Int32(3))
        
        
        case .`noRouteFound`:
            writeInt(&buf, Int32(4))
        
        
        case .`recipientRejected`:
            writeInt(&buf, Int32(5))
        
        
        case .`retriesExhausted`:
            writeInt(&buf, Int32(6))
        
        
        case .`noMoreRoutes`:
            writeInt(&buf, Int32(7))
        
        
        case .`unexpectedError`:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypePayErrorCode_lift(_ buf: RustBuffer) throws -> PayErrorCode {
    return try FfiConverterTypePayErrorCode.lift(buf)
}

public func FfiConverterTypePayErrorCode_lower(_ value: PayErrorCode) -> RustBuffer {
    return FfiConverterTypePayErrorCode.lower(value)
}


extension PayErrorCode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentState {
    
    case `created`
    case `succeeded`
    case `failed`
    case `retried`
    case `invoiceExpired`
}

public struct FfiConverterTypePaymentState: FfiConverterRustBuffer {
    typealias SwiftType = PaymentState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`created`
        
        case 2: return .`succeeded`
        
        case 3: return .`failed`
        
        case 4: return .`retried`
        
        case 5: return .`invoiceExpired`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`created`:
            writeInt(&buf, Int32(1))
        
        
        case .`succeeded`:
            writeInt(&buf, Int32(2))
        
        
        case .`failed`:
            writeInt(&buf, Int32(3))
        
        
        case .`retried`:
            writeInt(&buf, Int32(4))
        
        
        case .`invoiceExpired`:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypePaymentState_lift(_ buf: RustBuffer) throws -> PaymentState {
    return try FfiConverterTypePaymentState.lift(buf)
}

public func FfiConverterTypePaymentState_lower(_ value: PaymentState) -> RustBuffer {
    return FfiConverterTypePaymentState.lower(value)
}


extension PaymentState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentType {
    
    case `receiving`
    case `sending`
}

public struct FfiConverterTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = PaymentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`receiving`
        
        case 2: return .`sending`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`receiving`:
            writeInt(&buf, Int32(1))
        
        
        case .`sending`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypePaymentType_lift(_ buf: RustBuffer) throws -> PaymentType {
    return try FfiConverterTypePaymentType.lift(buf)
}

public func FfiConverterTypePaymentType_lower(_ value: PaymentType) -> RustBuffer {
    return FfiConverterTypePaymentType.lower(value)
}


extension PaymentType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RuntimeErrorCode {
    
    case `authServiceUnavailable`
    case `offerServiceUnavailable`
    case `esploraServiceUnavailable`
    case `lspServiceUnavailable`
    case `remoteStorageError`
    case `nonExistingWallet`
}

public struct FfiConverterTypeRuntimeErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = RuntimeErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RuntimeErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`authServiceUnavailable`
        
        case 2: return .`offerServiceUnavailable`
        
        case 3: return .`esploraServiceUnavailable`
        
        case 4: return .`lspServiceUnavailable`
        
        case 5: return .`remoteStorageError`
        
        case 6: return .`nonExistingWallet`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RuntimeErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`authServiceUnavailable`:
            writeInt(&buf, Int32(1))
        
        
        case .`offerServiceUnavailable`:
            writeInt(&buf, Int32(2))
        
        
        case .`esploraServiceUnavailable`:
            writeInt(&buf, Int32(3))
        
        
        case .`lspServiceUnavailable`:
            writeInt(&buf, Int32(4))
        
        
        case .`remoteStorageError`:
            writeInt(&buf, Int32(5))
        
        
        case .`nonExistingWallet`:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeRuntimeErrorCode_lift(_ buf: RustBuffer) throws -> RuntimeErrorCode {
    return try FfiConverterTypeRuntimeErrorCode.lift(buf)
}

public func FfiConverterTypeRuntimeErrorCode_lower(_ value: RuntimeErrorCode) -> RustBuffer {
    return FfiConverterTypeRuntimeErrorCode.lower(value)
}


extension RuntimeErrorCode: Equatable, Hashable {}



public enum SimpleError {

    
    
    case Simple(`msg`: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeSimpleError.lift(error)
    }
}


public struct FfiConverterTypeSimpleError: FfiConverterRustBuffer {
    typealias SwiftType = SimpleError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Simple(
            `msg`: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SimpleError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Simple(`msg`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`msg`, into: &buf)
            
        }
    }
}


extension SimpleError: Equatable, Hashable {}

extension SimpleError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TopupCurrency {
    
    case `eur`
    case `chf`
    case `gbp`
}

public struct FfiConverterTypeTopupCurrency: FfiConverterRustBuffer {
    typealias SwiftType = TopupCurrency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TopupCurrency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`eur`
        
        case 2: return .`chf`
        
        case 3: return .`gbp`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TopupCurrency, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`eur`:
            writeInt(&buf, Int32(1))
        
        
        case .`chf`:
            writeInt(&buf, Int32(2))
        
        
        case .`gbp`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeTopupCurrency_lift(_ buf: RustBuffer) throws -> TopupCurrency {
    return try FfiConverterTypeTopupCurrency.lift(buf)
}

public func FfiConverterTypeTopupCurrency_lower(_ value: TopupCurrency) -> RustBuffer {
    return FfiConverterTypeTopupCurrency.lower(value)
}


extension TopupCurrency: Equatable, Hashable {}



fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for EventsCallback Callback Interface

public protocol EventsCallback : AnyObject {
    func `paymentReceived`(`paymentHash`: String) 
    func `paymentSent`(`paymentHash`: String, `paymentPreimage`: String) 
    func `paymentFailed`(`paymentHash`: String) 
    func `channelClosed`(`channelId`: String, `reason`: String) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceEventsCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokePaymentReceived`(_ swiftCallbackInterface: EventsCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`paymentReceived`(
                    `paymentHash`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokePaymentSent`(_ swiftCallbackInterface: EventsCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`paymentSent`(
                    `paymentHash`:  try FfiConverterString.read(from: &reader), 
                    `paymentPreimage`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokePaymentFailed`(_ swiftCallbackInterface: EventsCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`paymentFailed`(
                    `paymentHash`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeChannelClosed`(_ swiftCallbackInterface: EventsCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`channelClosed`(
                    `channelId`:  try FfiConverterString.read(from: &reader), 
                    `reason`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceEventsCallback.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: EventsCallback
            do {
                cb = try FfiConverterCallbackInterfaceEventsCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("EventsCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokePaymentReceived`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: EventsCallback
            do {
                cb = try FfiConverterCallbackInterfaceEventsCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("EventsCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokePaymentSent`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: EventsCallback
            do {
                cb = try FfiConverterCallbackInterfaceEventsCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("EventsCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokePaymentFailed`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 4:
            let cb: EventsCallback
            do {
                cb = try FfiConverterCallbackInterfaceEventsCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("EventsCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeChannelClosed`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceEventsCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_lipalightninglib_fn_init_callback_eventscallback(foreignCallbackCallbackInterfaceEventsCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<EventsCallback>()
}

extension FfiConverterCallbackInterfaceEventsCallback : FfiConverter {
    typealias SwiftType = EventsCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeExchangeRate: FfiConverterRustBuffer {
    typealias SwiftType = ExchangeRate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeExchangeRate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeExchangeRate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFiatValue: FfiConverterRustBuffer {
    typealias SwiftType = FiatValue?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFiatValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFiatValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOfferKind: FfiConverterRustBuffer {
    typealias SwiftType = OfferKind?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOfferKind.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOfferKind.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePayErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = PayErrorCode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePayErrorCode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePayErrorCode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeOfferInfo: FfiConverterRustBuffer {
    typealias SwiftType = [OfferInfo]

    public static func write(_ value: [OfferInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOfferInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OfferInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [OfferInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOfferInfo.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = [Payment]

    public static func write(_ value: [Payment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Payment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Payment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayment.read(from: &buf))
        }
        return seq
    }
}

public func `generateSecret`(`passphrase`: String) throws -> Secret {
    return try  FfiConverterTypeSecret.lift(
        try rustCallWithError(FfiConverterTypeSimpleError.lift) {
    uniffi_lipalightninglib_fn_func_generate_secret(
        FfiConverterString.lower(`passphrase`),$0)
}
    )
}

public func `mnemonicToSecret`(`mnemonicString`: [String], `passphrase`: String) throws -> Secret {
    return try  FfiConverterTypeSecret.lift(
        try rustCallWithError(FfiConverterTypeMnemonicError.lift) {
    uniffi_lipalightninglib_fn_func_mnemonic_to_secret(
        FfiConverterSequenceString.lower(`mnemonicString`),
        FfiConverterString.lower(`passphrase`),$0)
}
    )
}

public func `wordsByPrefix`(`prefix`: String)  -> [String] {
    return try!  FfiConverterSequenceString.lift(
        try! rustCall() {
    uniffi_lipalightninglib_fn_func_words_by_prefix(
        FfiConverterString.lower(`prefix`),$0)
}
    )
}

public func `acceptTermsAndConditions`(`environment`: EnvironmentCode, `seed`: Data) throws {
    try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_func_accept_terms_and_conditions(
        FfiConverterTypeEnvironmentCode.lower(`environment`),
        FfiConverterData.lower(`seed`),$0)
}
}



public func `recoverLightningNode`(`environment`: EnvironmentCode, `seed`: Data, `localPersistencePath`: String, `enableFileLogging`: Bool) throws {
    try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_lipalightninglib_fn_func_recover_lightning_node(
        FfiConverterTypeEnvironmentCode.lower(`environment`),
        FfiConverterData.lower(`seed`),
        FfiConverterString.lower(`localPersistencePath`),
        FfiConverterBool.lower(`enableFileLogging`),$0)
}
}



private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 22
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_lipalightninglib_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_lipalightninglib_checksum_func_generate_secret() != 15006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lipalightninglib_checksum_func_mnemonic_to_secret() != 25762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lipalightninglib_checksum_func_words_by_prefix() != 34207) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lipalightninglib_checksum_func_accept_terms_and_conditions() != 17154) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lipalightninglib_checksum_func_recover_lightning_node() != 45132) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_get_node_info() != 55691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_query_lsp_fee() != 61148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_get_payment_amount_limits() != 53157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_calculate_lsp_fee() != 14363) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_create_invoice() != 1149) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_decode_invoice() != 60020) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_get_payment_max_routing_fee_mode() != 50733) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_pay_invoice() != 31001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_pay_open_invoice() != 11184) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_get_latest_payments() != 24636) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_get_payment() != 43694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_foreground() != 42852) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_background() != 34125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_list_currency_codes() != 13397) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_get_exchange_rate() != 41970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_change_fiat_currency() != 57000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_change_timezone_config() != 43718) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_accept_pocket_terms_and_conditions() != 46574) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_register_fiat_topup() != 54306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_query_uncompleted_offers() != 58970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_request_offer_collection() != 1522) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_register_notification_token() != 12567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_get_wallet_pubkey_id() != 62577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_method_lightningnode_get_payment_uuid() != 21036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_constructor_lightningnode_new() != 50158) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}