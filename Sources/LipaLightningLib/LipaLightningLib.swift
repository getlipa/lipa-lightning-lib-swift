// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(lipalightninglibFFI)
import lipalightninglibFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_uniffi_lipalightninglib_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_uniffi_lipalightninglib_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Date {
        let seconds: Int64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        if seconds >= 0 {
            let delta = Double(seconds) + (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        } else {
            let delta = Double(seconds) - (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        }
    }

    public static func write(_ value: Date, into buf: inout [UInt8]) {
        var delta = value.timeIntervalSince1970
        var sign: Int64 = 1
        if delta < 0 {
            // The nanoseconds portion of the epoch offset must always be
            // positive, to simplify the calculation we will use the absolute
            // value of the offset.
            sign = -1
            delta = -delta
        }
        if delta.rounded(.down) > Double(Int64.max) {
            fatalError("Timestamp overflow, exceeds max bounds supported by Uniffi")
        }
        let seconds = Int64(delta)
        let nanoseconds = UInt32((delta - Double(seconds)) * 1.0e9)
        writeInt(&buf, sign * seconds)
        writeInt(&buf, nanoseconds)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol ActionsRequiredProtocol : AnyObject {
    
    func dismissTopup(id: String) throws 
    
    func hideUnrecoverableChannelCloseFundsItem() throws 
    
    func hideUnrecoverableFailedSwapItem(failedSwapInfo: FailedSwapInfo) throws 
    
    func list() throws  -> [ActionRequiredItem]
    
}

open class ActionsRequired:
    ActionsRequiredProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_actionsrequired(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_actionsrequired(pointer, $0) }
    }

    

    
open func dismissTopup(id: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_actionsrequired_dismiss_topup(self.uniffiClonePointer(),
        FfiConverterString.lower(id),$0
    )
}
}
    
open func hideUnrecoverableChannelCloseFundsItem()throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_actionsrequired_hide_unrecoverable_channel_close_funds_item(self.uniffiClonePointer(),$0
    )
}
}
    
open func hideUnrecoverableFailedSwapItem(failedSwapInfo: FailedSwapInfo)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_actionsrequired_hide_unrecoverable_failed_swap_item(self.uniffiClonePointer(),
        FfiConverterTypeFailedSwapInfo.lower(failedSwapInfo),$0
    )
}
}
    
open func list()throws  -> [ActionRequiredItem] {
    return try  FfiConverterSequenceTypeActionRequiredItem.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_actionsrequired_list(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeActionsRequired: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ActionsRequired

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ActionsRequired {
        return ActionsRequired(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ActionsRequired) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ActionsRequired {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ActionsRequired, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActionsRequired_lift(_ pointer: UnsafeMutableRawPointer) throws -> ActionsRequired {
    return try FfiConverterTypeActionsRequired.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActionsRequired_lower(_ value: ActionsRequired) -> UnsafeMutableRawPointer {
    return FfiConverterTypeActionsRequired.lower(value)
}




public protocol ActivitiesProtocol : AnyObject {
    
    func get(hash: String) throws  -> Activity
    
    func getByReverseSwap(reverseSwapId: String) throws  -> Activity?
    
    func getIncomingPayment(hash: String) throws  -> IncomingPaymentInfo
    
    func getOutgoingPayment(hash: String) throws  -> OutgoingPaymentInfo
    
    func list(numberOfActivities: UInt32) throws  -> ListActivitiesResponse
    
    func setPersonalNote(paymentHash: String, note: String) throws 
    
}

open class Activities:
    ActivitiesProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_activities(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_activities(pointer, $0) }
    }

    

    
open func get(hash: String)throws  -> Activity {
    return try  FfiConverterTypeActivity.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_activities_get(self.uniffiClonePointer(),
        FfiConverterString.lower(hash),$0
    )
})
}
    
open func getByReverseSwap(reverseSwapId: String)throws  -> Activity? {
    return try  FfiConverterOptionTypeActivity.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_activities_get_by_reverse_swap(self.uniffiClonePointer(),
        FfiConverterString.lower(reverseSwapId),$0
    )
})
}
    
open func getIncomingPayment(hash: String)throws  -> IncomingPaymentInfo {
    return try  FfiConverterTypeIncomingPaymentInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_activities_get_incoming_payment(self.uniffiClonePointer(),
        FfiConverterString.lower(hash),$0
    )
})
}
    
open func getOutgoingPayment(hash: String)throws  -> OutgoingPaymentInfo {
    return try  FfiConverterTypeOutgoingPaymentInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_activities_get_outgoing_payment(self.uniffiClonePointer(),
        FfiConverterString.lower(hash),$0
    )
})
}
    
open func list(numberOfActivities: UInt32)throws  -> ListActivitiesResponse {
    return try  FfiConverterTypeListActivitiesResponse.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_activities_list(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(numberOfActivities),$0
    )
})
}
    
open func setPersonalNote(paymentHash: String, note: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_activities_set_personal_note(self.uniffiClonePointer(),
        FfiConverterString.lower(paymentHash),
        FfiConverterString.lower(note),$0
    )
}
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeActivities: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Activities

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Activities {
        return Activities(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Activities) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Activities {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Activities, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActivities_lift(_ pointer: UnsafeMutableRawPointer) throws -> Activities {
    return try FfiConverterTypeActivities.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActivities_lower(_ value: Activities) -> UnsafeMutableRawPointer {
    return FfiConverterTypeActivities.lower(value)
}




public protocol Bolt11Protocol : AnyObject {
    
    func create(amountSat: UInt64, lspFeeParams: OpeningFeeParams?, description: String, metadata: InvoiceCreationMetadata) throws  -> InvoiceDetails
    
    func pay(invoiceDetails: InvoiceDetails, metadata: PaymentMetadata) throws 
    
    func payOpenAmount(invoiceDetails: InvoiceDetails, amountSat: UInt64, metadata: PaymentMetadata) throws 
    
}

open class Bolt11:
    Bolt11Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_bolt11(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_bolt11(pointer, $0) }
    }

    

    
open func create(amountSat: UInt64, lspFeeParams: OpeningFeeParams?, description: String, metadata: InvoiceCreationMetadata)throws  -> InvoiceDetails {
    return try  FfiConverterTypeInvoiceDetails.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_bolt11_create(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountSat),
        FfiConverterOptionTypeOpeningFeeParams.lower(lspFeeParams),
        FfiConverterString.lower(description),
        FfiConverterTypeInvoiceCreationMetadata.lower(metadata),$0
    )
})
}
    
open func pay(invoiceDetails: InvoiceDetails, metadata: PaymentMetadata)throws  {try rustCallWithError(FfiConverterTypePayError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_bolt11_pay(self.uniffiClonePointer(),
        FfiConverterTypeInvoiceDetails.lower(invoiceDetails),
        FfiConverterTypePaymentMetadata.lower(metadata),$0
    )
}
}
    
open func payOpenAmount(invoiceDetails: InvoiceDetails, amountSat: UInt64, metadata: PaymentMetadata)throws  {try rustCallWithError(FfiConverterTypePayError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_bolt11_pay_open_amount(self.uniffiClonePointer(),
        FfiConverterTypeInvoiceDetails.lower(invoiceDetails),
        FfiConverterUInt64.lower(amountSat),
        FfiConverterTypePaymentMetadata.lower(metadata),$0
    )
}
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bolt11

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11 {
        return Bolt11(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bolt11) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bolt11, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11 {
    return try FfiConverterTypeBolt11.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11_lower(_ value: Bolt11) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBolt11.lower(value)
}




public protocol ChannelCloseProtocol : AnyObject {
    
    func determineResolvingFees() throws  -> OnchainResolvingFees?
    
    func prepareSweep(address: String) throws  -> SweepChannelCloseInfo
    
    func swap(satsPerVbyte: UInt32, lspFeeParams: OpeningFeeParams?) throws  -> String
    
    func sweep(sweepInfo: SweepChannelCloseInfo) throws  -> String
    
}

open class ChannelClose:
    ChannelCloseProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_channelclose(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_channelclose(pointer, $0) }
    }

    

    
open func determineResolvingFees()throws  -> OnchainResolvingFees? {
    return try  FfiConverterOptionTypeOnchainResolvingFees.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_channelclose_determine_resolving_fees(self.uniffiClonePointer(),$0
    )
})
}
    
open func prepareSweep(address: String)throws  -> SweepChannelCloseInfo {
    return try  FfiConverterTypeSweepChannelCloseInfo.lift(try rustCallWithError(FfiConverterTypeSweepError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_channelclose_prepare_sweep(self.uniffiClonePointer(),
        FfiConverterString.lower(address),$0
    )
})
}
    
open func swap(satsPerVbyte: UInt32, lspFeeParams: OpeningFeeParams?)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeSweepError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_channelclose_swap(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(satsPerVbyte),
        FfiConverterOptionTypeOpeningFeeParams.lower(lspFeeParams),$0
    )
})
}
    
open func sweep(sweepInfo: SweepChannelCloseInfo)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_channelclose_sweep(self.uniffiClonePointer(),
        FfiConverterTypeSweepChannelCloseInfo.lower(sweepInfo),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChannelClose: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ChannelClose

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ChannelClose {
        return ChannelClose(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ChannelClose) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelClose {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ChannelClose, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelClose_lift(_ pointer: UnsafeMutableRawPointer) throws -> ChannelClose {
    return try FfiConverterTypeChannelClose.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelClose_lower(_ value: ChannelClose) -> UnsafeMutableRawPointer {
    return FfiConverterTypeChannelClose.lower(value)
}




public protocol ConfigProtocol : AnyObject {
    
    func background() 
    
    func foreground() 
    
    func getAnalyticsConfig() throws  -> AnalyticsConfig
    
    func listCurrencies()  -> [String]
    
    func registerNotificationToken(notificationToken: String, languageIso6391: String, countryIso31661Alpha2: String) throws 
    
    func setAnalyticsConfig(config: AnalyticsConfig) throws 
    
    func setFeatureFlag(feature: FeatureFlag, flagEnabled: Bool) throws 
    
    func setFiatCurrency(fiatCurrency: String) throws 
    
    func setTimezoneConfig(timezoneConfig: TzConfig) 
    
}

open class Config:
    ConfigProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_config(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_config(pointer, $0) }
    }

    

    
open func background() {try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_config_background(self.uniffiClonePointer(),$0
    )
}
}
    
open func foreground() {try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_config_foreground(self.uniffiClonePointer(),$0
    )
}
}
    
open func getAnalyticsConfig()throws  -> AnalyticsConfig {
    return try  FfiConverterTypeAnalyticsConfig.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_config_get_analytics_config(self.uniffiClonePointer(),$0
    )
})
}
    
open func listCurrencies() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_config_list_currencies(self.uniffiClonePointer(),$0
    )
})
}
    
open func registerNotificationToken(notificationToken: String, languageIso6391: String, countryIso31661Alpha2: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_config_register_notification_token(self.uniffiClonePointer(),
        FfiConverterString.lower(notificationToken),
        FfiConverterString.lower(languageIso6391),
        FfiConverterString.lower(countryIso31661Alpha2),$0
    )
}
}
    
open func setAnalyticsConfig(config: AnalyticsConfig)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_config_set_analytics_config(self.uniffiClonePointer(),
        FfiConverterTypeAnalyticsConfig.lower(config),$0
    )
}
}
    
open func setFeatureFlag(feature: FeatureFlag, flagEnabled: Bool)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_config_set_feature_flag(self.uniffiClonePointer(),
        FfiConverterTypeFeatureFlag.lower(feature),
        FfiConverterBool.lower(flagEnabled),$0
    )
}
}
    
open func setFiatCurrency(fiatCurrency: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_config_set_fiat_currency(self.uniffiClonePointer(),
        FfiConverterString.lower(fiatCurrency),$0
    )
}
}
    
open func setTimezoneConfig(timezoneConfig: TzConfig) {try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_config_set_timezone_config(self.uniffiClonePointer(),
        FfiConverterTypeTzConfig.lower(timezoneConfig),$0
    )
}
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfig: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Config

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Config {
        return Config(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Config) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lift(_ pointer: UnsafeMutableRawPointer) throws -> Config {
    return try FfiConverterTypeConfig.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lower(_ value: Config) -> UnsafeMutableRawPointer {
    return FfiConverterTypeConfig.lower(value)
}




public protocol FiatTopupProtocol : AnyObject {
    
    func acceptTc(version: Int64, fingerprint: String) throws 
    
    func calculatePayoutFee(offer: OfferInfo) throws  -> Amount
    
    func getInfo() throws  -> FiatTopupInfo?
    
    func queryTcStatus() throws  -> TermsAndConditionsStatus
    
    func register(email: String?, userIban: String, userCurrency: String) throws  -> FiatTopupInfo
    
    func requestCollection(offer: OfferInfo) throws  -> String
    
    func reset() throws 
    
}

open class FiatTopup:
    FiatTopupProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_fiattopup(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_fiattopup(pointer, $0) }
    }

    

    
open func acceptTc(version: Int64, fingerprint: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_fiattopup_accept_tc(self.uniffiClonePointer(),
        FfiConverterInt64.lower(version),
        FfiConverterString.lower(fingerprint),$0
    )
}
}
    
open func calculatePayoutFee(offer: OfferInfo)throws  -> Amount {
    return try  FfiConverterTypeAmount.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_fiattopup_calculate_payout_fee(self.uniffiClonePointer(),
        FfiConverterTypeOfferInfo.lower(offer),$0
    )
})
}
    
open func getInfo()throws  -> FiatTopupInfo? {
    return try  FfiConverterOptionTypeFiatTopupInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_fiattopup_get_info(self.uniffiClonePointer(),$0
    )
})
}
    
open func queryTcStatus()throws  -> TermsAndConditionsStatus {
    return try  FfiConverterTypeTermsAndConditionsStatus.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_fiattopup_query_tc_status(self.uniffiClonePointer(),$0
    )
})
}
    
open func register(email: String?, userIban: String, userCurrency: String)throws  -> FiatTopupInfo {
    return try  FfiConverterTypeFiatTopupInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_fiattopup_register(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(email),
        FfiConverterString.lower(userIban),
        FfiConverterString.lower(userCurrency),$0
    )
})
}
    
open func requestCollection(offer: OfferInfo)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_fiattopup_request_collection(self.uniffiClonePointer(),
        FfiConverterTypeOfferInfo.lower(offer),$0
    )
})
}
    
open func reset()throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_fiattopup_reset(self.uniffiClonePointer(),$0
    )
}
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatTopup: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FiatTopup

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FiatTopup {
        return FiatTopup(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FiatTopup) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatTopup {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FiatTopup, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatTopup_lift(_ pointer: UnsafeMutableRawPointer) throws -> FiatTopup {
    return try FfiConverterTypeFiatTopup.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatTopup_lower(_ value: FiatTopup) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFiatTopup.lower(value)
}




public protocol LightningProtocol : AnyObject {
    
    func bolt11()  -> Bolt11
    
    func calculateLspFeeForAmount(amountSat: UInt64) throws  -> CalculateLspFeeResponse
    
    func determineMaxRoutingFeeMode(amountSat: UInt64)  -> MaxRoutingFeeMode
    
    func determinePaymentAffordability(amountSat: UInt64) throws  -> PaymentAffordability
    
    func determineReceiveAmountLimits() throws  -> ReceiveAmountLimits
    
    func getLspFee() throws  -> LspFee
    
    func lnurl()  -> Lnurl
    
}

open class Lightning:
    LightningProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_lightning(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_lightning(pointer, $0) }
    }

    

    
open func bolt11() -> Bolt11 {
    return try!  FfiConverterTypeBolt11.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightning_bolt11(self.uniffiClonePointer(),$0
    )
})
}
    
open func calculateLspFeeForAmount(amountSat: UInt64)throws  -> CalculateLspFeeResponse {
    return try  FfiConverterTypeCalculateLspFeeResponse.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightning_calculate_lsp_fee_for_amount(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountSat),$0
    )
})
}
    
open func determineMaxRoutingFeeMode(amountSat: UInt64) -> MaxRoutingFeeMode {
    return try!  FfiConverterTypeMaxRoutingFeeMode.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightning_determine_max_routing_fee_mode(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountSat),$0
    )
})
}
    
open func determinePaymentAffordability(amountSat: UInt64)throws  -> PaymentAffordability {
    return try  FfiConverterTypePaymentAffordability.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightning_determine_payment_affordability(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountSat),$0
    )
})
}
    
open func determineReceiveAmountLimits()throws  -> ReceiveAmountLimits {
    return try  FfiConverterTypeReceiveAmountLimits.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightning_determine_receive_amount_limits(self.uniffiClonePointer(),$0
    )
})
}
    
open func getLspFee()throws  -> LspFee {
    return try  FfiConverterTypeLspFee.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightning_get_lsp_fee(self.uniffiClonePointer(),$0
    )
})
}
    
open func lnurl() -> Lnurl {
    return try!  FfiConverterTypeLnurl.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightning_lnurl(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightning: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Lightning

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Lightning {
        return Lightning(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Lightning) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lightning {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Lightning, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightning_lift(_ pointer: UnsafeMutableRawPointer) throws -> Lightning {
    return try FfiConverterTypeLightning.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightning_lower(_ value: Lightning) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLightning.lower(value)
}




public protocol LightningAddressProtocol : AnyObject {
    
    func get() throws  -> String?
    
    func register() throws  -> String
    
}

open class LightningAddress:
    LightningAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_lightningaddress(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_lightningaddress(pointer, $0) }
    }

    

    
open func get()throws  -> String? {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningaddress_get(self.uniffiClonePointer(),$0
    )
})
}
    
open func register()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningaddress_register(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningAddress: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LightningAddress

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LightningAddress {
        return LightningAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LightningAddress) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LightningAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> LightningAddress {
    return try FfiConverterTypeLightningAddress.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddress_lower(_ value: LightningAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLightningAddress.lower(value)
}




public protocol LightningNodeProtocol : AnyObject {
    
    func acceptPocketTermsAndConditions(version: Int64, fingerprint: String) throws 
    
    func actionsRequired()  -> ActionsRequired
    
    func activities()  -> Activities
    
    func background() 
    
    func calculateLightningPayoutFee(offer: OfferInfo) throws  -> Amount
    
    func calculateLspFee(amountSat: UInt64) throws  -> CalculateLspFeeResponse
    
    func changeFiatCurrency(fiatCurrency: String) throws 
    
    func changeTimezoneConfig(timezoneConfig: TzConfig) 
    
    func checkClearWalletFeasibility() throws  -> RangeHit
    
    func clearWallet(clearWalletInfo: ClearWalletInfo, destinationOnchainAddressData: BitcoinAddressData) throws 
    
    func config()  -> Config
    
    func createInvoice(amountSat: UInt64, lspFeeParams: OpeningFeeParams?, description: String, metadata: InvoiceCreationMetadata) throws  -> InvoiceDetails
    
    func decodeData(data: String) throws  -> DecodedData
    
    func fiatTopup()  -> FiatTopup
    
    func foreground() 
    
    func generateSwapAddress(lspFeeParams: OpeningFeeParams?) throws  -> SwapAddressInfo
    
    func getActivity(hash: String) throws  -> Activity
    
    func getAnalyticsConfig() throws  -> AnalyticsConfig
    
    func getChannelCloseResolvingFees() throws  -> OnchainResolvingFees?
    
    func getExchangeRate()  -> ExchangeRate?
    
    func getFailedSwapResolvingFees(failedSwapInfo: FailedSwapInfo) throws  -> OnchainResolvingFees?
    
    func getHealthStatus() throws  -> BreezHealthCheckStatus
    
    func getIncomingPayment(hash: String) throws  -> IncomingPaymentInfo
    
    func getInvoiceAffordability(amountSat: UInt64) throws  -> InvoiceAffordability
    
    func getLatestActivities(numberOfActivities: UInt32) throws  -> ListActivitiesResponse
    
    func getNodeInfo() throws  -> NodeInfo
    
    func getOutgoingPayment(hash: String) throws  -> OutgoingPaymentInfo
    
    func getPaymentAmountLimits() throws  -> PaymentAmountLimits
    
    func getPaymentMaxRoutingFeeMode(amountSat: UInt64)  -> MaxRoutingFeeMode
    
    func getPaymentUuid(paymentHash: String) throws  -> String
    
    func getTermsAndConditionsStatus(termsAndConditions: TermsAndConditions) throws  -> TermsAndConditionsStatus
    
    func getUnresolvedFailedSwaps() throws  -> [FailedSwapInfo]
    
    func getWalletPubkeyId() throws  -> String
    
    func hideChannelClosesFundsAvailableActionRequiredItem() throws 
    
    func hideTopup(id: String) throws 
    
    func hideUnresolvedFailedSwapActionRequiredItem(failedSwapInfo: FailedSwapInfo) throws 
    
    func lightning()  -> Lightning
    
    func lightningAddress()  -> LightningAddress
    
    func listActionRequiredItems() throws  -> [ActionRequiredItem]
    
    func listCurrencyCodes()  -> [String]
    
    func listRecipients() throws  -> [Recipient]
    
    func logDebugInfo() throws 
    
    func onchain()  -> Onchain
    
    func parsePhoneNumberPrefix(phoneNumber: String) throws 
    
    func parsePhoneNumberToLightningAddress(phoneNumber: String) throws  -> String
    
    func payInvoice(invoiceDetails: InvoiceDetails, metadata: PaymentMetadata) throws 
    
    func payLnurlp(lnurlPayRequestData: LnUrlPayRequestData, amountSat: UInt64, comment: String?) throws  -> String
    
    func payOpenInvoice(invoiceDetails: InvoiceDetails, amountSat: UInt64, metadata: PaymentMetadata) throws 
    
    func phoneNumber()  -> PhoneNumber
    
    func prepareClearWallet() throws  -> ClearWalletInfo
    
    func prepareResolveFailedSwap(failedSwapInfo: FailedSwapInfo, toAddress: String, onchainFeeRate: UInt32) throws  -> ResolveFailedSwapInfo
    
    func prepareSweepFundsFromChannelCloses(address: String, onchainFeeRate: UInt32) throws  -> SweepInfo
    
    func queryLightningAddress() throws  -> String?
    
    func queryLspFee() throws  -> LspFee
    
    func queryOnchainFeeRate() throws  -> UInt32
    
    func queryUncompletedOffers() throws  -> [OfferInfo]
    
    func queryVerifiedPhoneNumber() throws  -> String?
    
    func registerFiatTopup(email: String?, userIban: String, userCurrency: String) throws  -> FiatTopupInfo
    
    func registerLightningAddress() throws  -> String
    
    func registerNotificationToken(notificationToken: String, languageIso6391: String, countryIso31661Alpha2: String) throws 
    
    func requestOfferCollection(offer: OfferInfo) throws  -> String
    
    func requestPhoneNumberVerification(phoneNumber: String) throws 
    
    func resetFiatTopup() throws 
    
    func resolveFailedSwap(resolveFailedSwapInfo: ResolveFailedSwapInfo) throws  -> String
    
    func retrieveLatestFiatTopupInfo() throws  -> FiatTopupInfo?
    
    func setAnalyticsConfig(config: AnalyticsConfig) throws 
    
    func setFeatureFlag(feature: FeatureFlag, flagEnabled: Bool) throws 
    
    func setPaymentPersonalNote(paymentHash: String, note: String) throws 
    
    func swapChannelCloseFundsToLightning(satsPerVbyte: UInt32, lspFeeParams: OpeningFeeParams?) throws  -> String
    
    func swapFailedSwapFundsToLightning(failedSwapInfo: FailedSwapInfo, satsPerVbyte: UInt32, lspFeeParam: OpeningFeeParams?) throws  -> String
    
    func sweepFundsFromChannelCloses(sweepInfo: SweepInfo) throws  -> String
    
    func util()  -> Util
    
    func verifyPhoneNumber(phoneNumber: String, otp: String) throws 
    
    func withdrawLnurlw(lnurlWithdrawRequestData: LnUrlWithdrawRequestData, amountSat: UInt64) throws  -> String
    
}

open class LightningNode:
    LightningNodeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_lightningnode(self.pointer, $0) }
    }
public convenience init(config: LightningNodeConfig, eventsCallback: EventsCallback)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_constructor_lightningnode_new(
        FfiConverterTypeLightningNodeConfig.lower(config),
        FfiConverterCallbackInterfaceEventsCallback.lower(eventsCallback),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_lightningnode(pointer, $0) }
    }

    

    
open func acceptPocketTermsAndConditions(version: Int64, fingerprint: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_accept_pocket_terms_and_conditions(self.uniffiClonePointer(),
        FfiConverterInt64.lower(version),
        FfiConverterString.lower(fingerprint),$0
    )
}
}
    
open func actionsRequired() -> ActionsRequired {
    return try!  FfiConverterTypeActionsRequired.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_actions_required(self.uniffiClonePointer(),$0
    )
})
}
    
open func activities() -> Activities {
    return try!  FfiConverterTypeActivities.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_activities(self.uniffiClonePointer(),$0
    )
})
}
    
open func background() {try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_background(self.uniffiClonePointer(),$0
    )
}
}
    
open func calculateLightningPayoutFee(offer: OfferInfo)throws  -> Amount {
    return try  FfiConverterTypeAmount.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_calculate_lightning_payout_fee(self.uniffiClonePointer(),
        FfiConverterTypeOfferInfo.lower(offer),$0
    )
})
}
    
open func calculateLspFee(amountSat: UInt64)throws  -> CalculateLspFeeResponse {
    return try  FfiConverterTypeCalculateLspFeeResponse.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_calculate_lsp_fee(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountSat),$0
    )
})
}
    
open func changeFiatCurrency(fiatCurrency: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_change_fiat_currency(self.uniffiClonePointer(),
        FfiConverterString.lower(fiatCurrency),$0
    )
}
}
    
open func changeTimezoneConfig(timezoneConfig: TzConfig) {try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_change_timezone_config(self.uniffiClonePointer(),
        FfiConverterTypeTzConfig.lower(timezoneConfig),$0
    )
}
}
    
open func checkClearWalletFeasibility()throws  -> RangeHit {
    return try  FfiConverterTypeRangeHit.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_check_clear_wallet_feasibility(self.uniffiClonePointer(),$0
    )
})
}
    
open func clearWallet(clearWalletInfo: ClearWalletInfo, destinationOnchainAddressData: BitcoinAddressData)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_clear_wallet(self.uniffiClonePointer(),
        FfiConverterTypeClearWalletInfo.lower(clearWalletInfo),
        FfiConverterTypeBitcoinAddressData.lower(destinationOnchainAddressData),$0
    )
}
}
    
open func config() -> Config {
    return try!  FfiConverterTypeConfig.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_config(self.uniffiClonePointer(),$0
    )
})
}
    
open func createInvoice(amountSat: UInt64, lspFeeParams: OpeningFeeParams?, description: String, metadata: InvoiceCreationMetadata)throws  -> InvoiceDetails {
    return try  FfiConverterTypeInvoiceDetails.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_create_invoice(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountSat),
        FfiConverterOptionTypeOpeningFeeParams.lower(lspFeeParams),
        FfiConverterString.lower(description),
        FfiConverterTypeInvoiceCreationMetadata.lower(metadata),$0
    )
})
}
    
open func decodeData(data: String)throws  -> DecodedData {
    return try  FfiConverterTypeDecodedData.lift(try rustCallWithError(FfiConverterTypeDecodeDataError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_decode_data(self.uniffiClonePointer(),
        FfiConverterString.lower(data),$0
    )
})
}
    
open func fiatTopup() -> FiatTopup {
    return try!  FfiConverterTypeFiatTopup.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_fiat_topup(self.uniffiClonePointer(),$0
    )
})
}
    
open func foreground() {try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_foreground(self.uniffiClonePointer(),$0
    )
}
}
    
open func generateSwapAddress(lspFeeParams: OpeningFeeParams?)throws  -> SwapAddressInfo {
    return try  FfiConverterTypeSwapAddressInfo.lift(try rustCallWithError(FfiConverterTypeSwapError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_generate_swap_address(self.uniffiClonePointer(),
        FfiConverterOptionTypeOpeningFeeParams.lower(lspFeeParams),$0
    )
})
}
    
open func getActivity(hash: String)throws  -> Activity {
    return try  FfiConverterTypeActivity.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_activity(self.uniffiClonePointer(),
        FfiConverterString.lower(hash),$0
    )
})
}
    
open func getAnalyticsConfig()throws  -> AnalyticsConfig {
    return try  FfiConverterTypeAnalyticsConfig.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_analytics_config(self.uniffiClonePointer(),$0
    )
})
}
    
open func getChannelCloseResolvingFees()throws  -> OnchainResolvingFees? {
    return try  FfiConverterOptionTypeOnchainResolvingFees.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_channel_close_resolving_fees(self.uniffiClonePointer(),$0
    )
})
}
    
open func getExchangeRate() -> ExchangeRate? {
    return try!  FfiConverterOptionTypeExchangeRate.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_exchange_rate(self.uniffiClonePointer(),$0
    )
})
}
    
open func getFailedSwapResolvingFees(failedSwapInfo: FailedSwapInfo)throws  -> OnchainResolvingFees? {
    return try  FfiConverterOptionTypeOnchainResolvingFees.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_failed_swap_resolving_fees(self.uniffiClonePointer(),
        FfiConverterTypeFailedSwapInfo.lower(failedSwapInfo),$0
    )
})
}
    
open func getHealthStatus()throws  -> BreezHealthCheckStatus {
    return try  FfiConverterTypeBreezHealthCheckStatus.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_health_status(self.uniffiClonePointer(),$0
    )
})
}
    
open func getIncomingPayment(hash: String)throws  -> IncomingPaymentInfo {
    return try  FfiConverterTypeIncomingPaymentInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_incoming_payment(self.uniffiClonePointer(),
        FfiConverterString.lower(hash),$0
    )
})
}
    
open func getInvoiceAffordability(amountSat: UInt64)throws  -> InvoiceAffordability {
    return try  FfiConverterTypeInvoiceAffordability.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_invoice_affordability(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountSat),$0
    )
})
}
    
open func getLatestActivities(numberOfActivities: UInt32)throws  -> ListActivitiesResponse {
    return try  FfiConverterTypeListActivitiesResponse.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_latest_activities(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(numberOfActivities),$0
    )
})
}
    
open func getNodeInfo()throws  -> NodeInfo {
    return try  FfiConverterTypeNodeInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_node_info(self.uniffiClonePointer(),$0
    )
})
}
    
open func getOutgoingPayment(hash: String)throws  -> OutgoingPaymentInfo {
    return try  FfiConverterTypeOutgoingPaymentInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_outgoing_payment(self.uniffiClonePointer(),
        FfiConverterString.lower(hash),$0
    )
})
}
    
open func getPaymentAmountLimits()throws  -> PaymentAmountLimits {
    return try  FfiConverterTypePaymentAmountLimits.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_payment_amount_limits(self.uniffiClonePointer(),$0
    )
})
}
    
open func getPaymentMaxRoutingFeeMode(amountSat: UInt64) -> MaxRoutingFeeMode {
    return try!  FfiConverterTypeMaxRoutingFeeMode.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_payment_max_routing_fee_mode(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountSat),$0
    )
})
}
    
open func getPaymentUuid(paymentHash: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_payment_uuid(self.uniffiClonePointer(),
        FfiConverterString.lower(paymentHash),$0
    )
})
}
    
open func getTermsAndConditionsStatus(termsAndConditions: TermsAndConditions)throws  -> TermsAndConditionsStatus {
    return try  FfiConverterTypeTermsAndConditionsStatus.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_terms_and_conditions_status(self.uniffiClonePointer(),
        FfiConverterTypeTermsAndConditions.lower(termsAndConditions),$0
    )
})
}
    
open func getUnresolvedFailedSwaps()throws  -> [FailedSwapInfo] {
    return try  FfiConverterSequenceTypeFailedSwapInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_unresolved_failed_swaps(self.uniffiClonePointer(),$0
    )
})
}
    
open func getWalletPubkeyId()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_wallet_pubkey_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func hideChannelClosesFundsAvailableActionRequiredItem()throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_hide_channel_closes_funds_available_action_required_item(self.uniffiClonePointer(),$0
    )
}
}
    
open func hideTopup(id: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_hide_topup(self.uniffiClonePointer(),
        FfiConverterString.lower(id),$0
    )
}
}
    
open func hideUnresolvedFailedSwapActionRequiredItem(failedSwapInfo: FailedSwapInfo)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_hide_unresolved_failed_swap_action_required_item(self.uniffiClonePointer(),
        FfiConverterTypeFailedSwapInfo.lower(failedSwapInfo),$0
    )
}
}
    
open func lightning() -> Lightning {
    return try!  FfiConverterTypeLightning.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_lightning(self.uniffiClonePointer(),$0
    )
})
}
    
open func lightningAddress() -> LightningAddress {
    return try!  FfiConverterTypeLightningAddress.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_lightning_address(self.uniffiClonePointer(),$0
    )
})
}
    
open func listActionRequiredItems()throws  -> [ActionRequiredItem] {
    return try  FfiConverterSequenceTypeActionRequiredItem.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_list_action_required_items(self.uniffiClonePointer(),$0
    )
})
}
    
open func listCurrencyCodes() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_list_currency_codes(self.uniffiClonePointer(),$0
    )
})
}
    
open func listRecipients()throws  -> [Recipient] {
    return try  FfiConverterSequenceTypeRecipient.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_list_recipients(self.uniffiClonePointer(),$0
    )
})
}
    
open func logDebugInfo()throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_log_debug_info(self.uniffiClonePointer(),$0
    )
}
}
    
open func onchain() -> Onchain {
    return try!  FfiConverterTypeOnchain.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_onchain(self.uniffiClonePointer(),$0
    )
})
}
    
open func parsePhoneNumberPrefix(phoneNumber: String)throws  {try rustCallWithError(FfiConverterTypeParsePhoneNumberPrefixError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_parse_phone_number_prefix(self.uniffiClonePointer(),
        FfiConverterString.lower(phoneNumber),$0
    )
}
}
    
open func parsePhoneNumberToLightningAddress(phoneNumber: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeParsePhoneNumberError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_parse_phone_number_to_lightning_address(self.uniffiClonePointer(),
        FfiConverterString.lower(phoneNumber),$0
    )
})
}
    
open func payInvoice(invoiceDetails: InvoiceDetails, metadata: PaymentMetadata)throws  {try rustCallWithError(FfiConverterTypePayError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_pay_invoice(self.uniffiClonePointer(),
        FfiConverterTypeInvoiceDetails.lower(invoiceDetails),
        FfiConverterTypePaymentMetadata.lower(metadata),$0
    )
}
}
    
open func payLnurlp(lnurlPayRequestData: LnUrlPayRequestData, amountSat: UInt64, comment: String?)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnUrlPayError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_pay_lnurlp(self.uniffiClonePointer(),
        FfiConverterTypeLnUrlPayRequestData.lower(lnurlPayRequestData),
        FfiConverterUInt64.lower(amountSat),
        FfiConverterOptionString.lower(comment),$0
    )
})
}
    
open func payOpenInvoice(invoiceDetails: InvoiceDetails, amountSat: UInt64, metadata: PaymentMetadata)throws  {try rustCallWithError(FfiConverterTypePayError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_pay_open_invoice(self.uniffiClonePointer(),
        FfiConverterTypeInvoiceDetails.lower(invoiceDetails),
        FfiConverterUInt64.lower(amountSat),
        FfiConverterTypePaymentMetadata.lower(metadata),$0
    )
}
}
    
open func phoneNumber() -> PhoneNumber {
    return try!  FfiConverterTypePhoneNumber.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_phone_number(self.uniffiClonePointer(),$0
    )
})
}
    
open func prepareClearWallet()throws  -> ClearWalletInfo {
    return try  FfiConverterTypeClearWalletInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_prepare_clear_wallet(self.uniffiClonePointer(),$0
    )
})
}
    
open func prepareResolveFailedSwap(failedSwapInfo: FailedSwapInfo, toAddress: String, onchainFeeRate: UInt32)throws  -> ResolveFailedSwapInfo {
    return try  FfiConverterTypeResolveFailedSwapInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_prepare_resolve_failed_swap(self.uniffiClonePointer(),
        FfiConverterTypeFailedSwapInfo.lower(failedSwapInfo),
        FfiConverterString.lower(toAddress),
        FfiConverterUInt32.lower(onchainFeeRate),$0
    )
})
}
    
open func prepareSweepFundsFromChannelCloses(address: String, onchainFeeRate: UInt32)throws  -> SweepInfo {
    return try  FfiConverterTypeSweepInfo.lift(try rustCallWithError(FfiConverterTypeSweepError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_prepare_sweep_funds_from_channel_closes(self.uniffiClonePointer(),
        FfiConverterString.lower(address),
        FfiConverterUInt32.lower(onchainFeeRate),$0
    )
})
}
    
open func queryLightningAddress()throws  -> String? {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_query_lightning_address(self.uniffiClonePointer(),$0
    )
})
}
    
open func queryLspFee()throws  -> LspFee {
    return try  FfiConverterTypeLspFee.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_query_lsp_fee(self.uniffiClonePointer(),$0
    )
})
}
    
open func queryOnchainFeeRate()throws  -> UInt32 {
    return try  FfiConverterUInt32.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_query_onchain_fee_rate(self.uniffiClonePointer(),$0
    )
})
}
    
open func queryUncompletedOffers()throws  -> [OfferInfo] {
    return try  FfiConverterSequenceTypeOfferInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_query_uncompleted_offers(self.uniffiClonePointer(),$0
    )
})
}
    
open func queryVerifiedPhoneNumber()throws  -> String? {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_query_verified_phone_number(self.uniffiClonePointer(),$0
    )
})
}
    
open func registerFiatTopup(email: String?, userIban: String, userCurrency: String)throws  -> FiatTopupInfo {
    return try  FfiConverterTypeFiatTopupInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_register_fiat_topup(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(email),
        FfiConverterString.lower(userIban),
        FfiConverterString.lower(userCurrency),$0
    )
})
}
    
open func registerLightningAddress()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_register_lightning_address(self.uniffiClonePointer(),$0
    )
})
}
    
open func registerNotificationToken(notificationToken: String, languageIso6391: String, countryIso31661Alpha2: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_register_notification_token(self.uniffiClonePointer(),
        FfiConverterString.lower(notificationToken),
        FfiConverterString.lower(languageIso6391),
        FfiConverterString.lower(countryIso31661Alpha2),$0
    )
}
}
    
open func requestOfferCollection(offer: OfferInfo)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_request_offer_collection(self.uniffiClonePointer(),
        FfiConverterTypeOfferInfo.lower(offer),$0
    )
})
}
    
open func requestPhoneNumberVerification(phoneNumber: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_request_phone_number_verification(self.uniffiClonePointer(),
        FfiConverterString.lower(phoneNumber),$0
    )
}
}
    
open func resetFiatTopup()throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_reset_fiat_topup(self.uniffiClonePointer(),$0
    )
}
}
    
open func resolveFailedSwap(resolveFailedSwapInfo: ResolveFailedSwapInfo)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_resolve_failed_swap(self.uniffiClonePointer(),
        FfiConverterTypeResolveFailedSwapInfo.lower(resolveFailedSwapInfo),$0
    )
})
}
    
open func retrieveLatestFiatTopupInfo()throws  -> FiatTopupInfo? {
    return try  FfiConverterOptionTypeFiatTopupInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_retrieve_latest_fiat_topup_info(self.uniffiClonePointer(),$0
    )
})
}
    
open func setAnalyticsConfig(config: AnalyticsConfig)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_set_analytics_config(self.uniffiClonePointer(),
        FfiConverterTypeAnalyticsConfig.lower(config),$0
    )
}
}
    
open func setFeatureFlag(feature: FeatureFlag, flagEnabled: Bool)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_set_feature_flag(self.uniffiClonePointer(),
        FfiConverterTypeFeatureFlag.lower(feature),
        FfiConverterBool.lower(flagEnabled),$0
    )
}
}
    
open func setPaymentPersonalNote(paymentHash: String, note: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_set_payment_personal_note(self.uniffiClonePointer(),
        FfiConverterString.lower(paymentHash),
        FfiConverterString.lower(note),$0
    )
}
}
    
open func swapChannelCloseFundsToLightning(satsPerVbyte: UInt32, lspFeeParams: OpeningFeeParams?)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeSweepError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_swap_channel_close_funds_to_lightning(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(satsPerVbyte),
        FfiConverterOptionTypeOpeningFeeParams.lower(lspFeeParams),$0
    )
})
}
    
open func swapFailedSwapFundsToLightning(failedSwapInfo: FailedSwapInfo, satsPerVbyte: UInt32, lspFeeParam: OpeningFeeParams?)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_swap_failed_swap_funds_to_lightning(self.uniffiClonePointer(),
        FfiConverterTypeFailedSwapInfo.lower(failedSwapInfo),
        FfiConverterUInt32.lower(satsPerVbyte),
        FfiConverterOptionTypeOpeningFeeParams.lower(lspFeeParam),$0
    )
})
}
    
open func sweepFundsFromChannelCloses(sweepInfo: SweepInfo)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_sweep_funds_from_channel_closes(self.uniffiClonePointer(),
        FfiConverterTypeSweepInfo.lower(sweepInfo),$0
    )
})
}
    
open func util() -> Util {
    return try!  FfiConverterTypeUtil.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_util(self.uniffiClonePointer(),$0
    )
})
}
    
open func verifyPhoneNumber(phoneNumber: String, otp: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_verify_phone_number(self.uniffiClonePointer(),
        FfiConverterString.lower(phoneNumber),
        FfiConverterString.lower(otp),$0
    )
}
}
    
open func withdrawLnurlw(lnurlWithdrawRequestData: LnUrlWithdrawRequestData, amountSat: UInt64)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnUrlWithdrawError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_withdraw_lnurlw(self.uniffiClonePointer(),
        FfiConverterTypeLnUrlWithdrawRequestData.lower(lnurlWithdrawRequestData),
        FfiConverterUInt64.lower(amountSat),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LightningNode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LightningNode {
        return LightningNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LightningNode) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LightningNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> LightningNode {
    return try FfiConverterTypeLightningNode.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningNode_lower(_ value: LightningNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLightningNode.lower(value)
}




public protocol LnurlProtocol : AnyObject {
    
    func pay(lnurlPayRequestData: LnUrlPayRequestData, amountSat: UInt64, comment: String?) throws  -> String
    
    func withdraw(lnurlWithdrawRequestData: LnUrlWithdrawRequestData, amountSat: UInt64) throws  -> String
    
}

open class Lnurl:
    LnurlProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_lnurl(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_lnurl(pointer, $0) }
    }

    

    
open func pay(lnurlPayRequestData: LnUrlPayRequestData, amountSat: UInt64, comment: String?)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnUrlPayError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lnurl_pay(self.uniffiClonePointer(),
        FfiConverterTypeLnUrlPayRequestData.lower(lnurlPayRequestData),
        FfiConverterUInt64.lower(amountSat),
        FfiConverterOptionString.lower(comment),$0
    )
})
}
    
open func withdraw(lnurlWithdrawRequestData: LnUrlWithdrawRequestData, amountSat: UInt64)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnUrlWithdrawError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lnurl_withdraw(self.uniffiClonePointer(),
        FfiConverterTypeLnUrlWithdrawRequestData.lower(lnurlWithdrawRequestData),
        FfiConverterUInt64.lower(amountSat),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurl: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Lnurl

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Lnurl {
        return Lnurl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Lnurl) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lnurl {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Lnurl, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurl_lift(_ pointer: UnsafeMutableRawPointer) throws -> Lnurl {
    return try FfiConverterTypeLnurl.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurl_lower(_ value: Lnurl) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLnurl.lower(value)
}




public protocol OnchainProtocol : AnyObject {
    
    func channelClose()  -> ChannelClose
    
    func reverseSwap()  -> ReverseSwap
    
    func swap()  -> Swap
    
}

open class Onchain:
    OnchainProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_onchain(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_onchain(pointer, $0) }
    }

    

    
open func channelClose() -> ChannelClose {
    return try!  FfiConverterTypeChannelClose.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_onchain_channel_close(self.uniffiClonePointer(),$0
    )
})
}
    
open func reverseSwap() -> ReverseSwap {
    return try!  FfiConverterTypeReverseSwap.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_onchain_reverse_swap(self.uniffiClonePointer(),$0
    )
})
}
    
open func swap() -> Swap {
    return try!  FfiConverterTypeSwap.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_onchain_swap(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOnchain: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Onchain

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Onchain {
        return Onchain(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Onchain) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Onchain {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Onchain, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchain_lift(_ pointer: UnsafeMutableRawPointer) throws -> Onchain {
    return try FfiConverterTypeOnchain.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchain_lower(_ value: Onchain) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOnchain.lower(value)
}




public protocol PhoneNumberProtocol : AnyObject {
    
    func get() throws  -> String?
    
    func parsePrefix(phoneNumber: String) throws 
    
    func parseToLightningAddress(phoneNumber: String) throws  -> String
    
    func register(phoneNumber: String) throws 
    
    func verify(phoneNumber: String, otp: String) throws 
    
}

open class PhoneNumber:
    PhoneNumberProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_phonenumber(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_phonenumber(pointer, $0) }
    }

    

    
open func get()throws  -> String? {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_phonenumber_get(self.uniffiClonePointer(),$0
    )
})
}
    
open func parsePrefix(phoneNumber: String)throws  {try rustCallWithError(FfiConverterTypeParsePhoneNumberPrefixError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_phonenumber_parse_prefix(self.uniffiClonePointer(),
        FfiConverterString.lower(phoneNumber),$0
    )
}
}
    
open func parseToLightningAddress(phoneNumber: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeParsePhoneNumberError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_phonenumber_parse_to_lightning_address(self.uniffiClonePointer(),
        FfiConverterString.lower(phoneNumber),$0
    )
})
}
    
open func register(phoneNumber: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_phonenumber_register(self.uniffiClonePointer(),
        FfiConverterString.lower(phoneNumber),$0
    )
}
}
    
open func verify(phoneNumber: String, otp: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_phonenumber_verify(self.uniffiClonePointer(),
        FfiConverterString.lower(phoneNumber),
        FfiConverterString.lower(otp),$0
    )
}
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePhoneNumber: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PhoneNumber

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PhoneNumber {
        return PhoneNumber(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PhoneNumber) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PhoneNumber {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PhoneNumber, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePhoneNumber_lift(_ pointer: UnsafeMutableRawPointer) throws -> PhoneNumber {
    return try FfiConverterTypePhoneNumber.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePhoneNumber_lower(_ value: PhoneNumber) -> UnsafeMutableRawPointer {
    return FfiConverterTypePhoneNumber.lower(value)
}




public protocol ReverseSwapProtocol : AnyObject {
    
    func clearWallet(clearWalletInfo: ClearWalletInfo, destinationOnchainAddressData: BitcoinAddressData) throws 
    
    func determineClearWalletFeasibility() throws  -> RangeHit
    
    func prepareClearWallet() throws  -> ClearWalletInfo
    
}

open class ReverseSwap:
    ReverseSwapProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_reverseswap(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_reverseswap(pointer, $0) }
    }

    

    
open func clearWallet(clearWalletInfo: ClearWalletInfo, destinationOnchainAddressData: BitcoinAddressData)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_reverseswap_clear_wallet(self.uniffiClonePointer(),
        FfiConverterTypeClearWalletInfo.lower(clearWalletInfo),
        FfiConverterTypeBitcoinAddressData.lower(destinationOnchainAddressData),$0
    )
}
}
    
open func determineClearWalletFeasibility()throws  -> RangeHit {
    return try  FfiConverterTypeRangeHit.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_reverseswap_determine_clear_wallet_feasibility(self.uniffiClonePointer(),$0
    )
})
}
    
open func prepareClearWallet()throws  -> ClearWalletInfo {
    return try  FfiConverterTypeClearWalletInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_reverseswap_prepare_clear_wallet(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReverseSwap: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ReverseSwap

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ReverseSwap {
        return ReverseSwap(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ReverseSwap) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReverseSwap {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ReverseSwap, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReverseSwap_lift(_ pointer: UnsafeMutableRawPointer) throws -> ReverseSwap {
    return try FfiConverterTypeReverseSwap.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReverseSwap_lower(_ value: ReverseSwap) -> UnsafeMutableRawPointer {
    return FfiConverterTypeReverseSwap.lower(value)
}




public protocol SwapProtocol : AnyObject {
    
    func create(lspFeeParams: OpeningFeeParams?) throws  -> SwapAddressInfo
    
    func determineResolvingFees(failedSwapInfo: FailedSwapInfo) throws  -> OnchainResolvingFees?
    
    func prepareSweep(failedSwapInfo: FailedSwapInfo, toAddress: String) throws  -> SweepFailedSwapInfo
    
    func swap(failedSwapInfo: FailedSwapInfo, satsPerVbyte: UInt32, lspFeeParam: OpeningFeeParams?) throws  -> String
    
    func sweep(sweepFailedSwapInfo: SweepFailedSwapInfo) throws  -> String
    
}

open class Swap:
    SwapProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_swap(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_swap(pointer, $0) }
    }

    

    
open func create(lspFeeParams: OpeningFeeParams?)throws  -> SwapAddressInfo {
    return try  FfiConverterTypeSwapAddressInfo.lift(try rustCallWithError(FfiConverterTypeSwapError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_swap_create(self.uniffiClonePointer(),
        FfiConverterOptionTypeOpeningFeeParams.lower(lspFeeParams),$0
    )
})
}
    
open func determineResolvingFees(failedSwapInfo: FailedSwapInfo)throws  -> OnchainResolvingFees? {
    return try  FfiConverterOptionTypeOnchainResolvingFees.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_swap_determine_resolving_fees(self.uniffiClonePointer(),
        FfiConverterTypeFailedSwapInfo.lower(failedSwapInfo),$0
    )
})
}
    
open func prepareSweep(failedSwapInfo: FailedSwapInfo, toAddress: String)throws  -> SweepFailedSwapInfo {
    return try  FfiConverterTypeSweepFailedSwapInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_swap_prepare_sweep(self.uniffiClonePointer(),
        FfiConverterTypeFailedSwapInfo.lower(failedSwapInfo),
        FfiConverterString.lower(toAddress),$0
    )
})
}
    
open func swap(failedSwapInfo: FailedSwapInfo, satsPerVbyte: UInt32, lspFeeParam: OpeningFeeParams?)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_swap_swap(self.uniffiClonePointer(),
        FfiConverterTypeFailedSwapInfo.lower(failedSwapInfo),
        FfiConverterUInt32.lower(satsPerVbyte),
        FfiConverterOptionTypeOpeningFeeParams.lower(lspFeeParam),$0
    )
})
}
    
open func sweep(sweepFailedSwapInfo: SweepFailedSwapInfo)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_swap_sweep(self.uniffiClonePointer(),
        FfiConverterTypeSweepFailedSwapInfo.lower(sweepFailedSwapInfo),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSwap: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Swap

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Swap {
        return Swap(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Swap) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Swap {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Swap, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSwap_lift(_ pointer: UnsafeMutableRawPointer) throws -> Swap {
    return try FfiConverterTypeSwap.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSwap_lower(_ value: Swap) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSwap.lower(value)
}




public protocol UtilProtocol : AnyObject {
    
    func decodeData(data: String) throws  -> DecodedData
    
    func derivePaymentUuid(paymentHash: String) throws  -> String
    
    func getExchangeRate()  -> ExchangeRate?
    
    func getNodeInfo() throws  -> NodeInfo
    
    func logDebugInfo() throws 
    
    func queryHealthStatus() throws  -> BreezHealthCheckStatus
    
    func queryWalletPubkeyId() throws  -> String
    
}

open class Util:
    UtilProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_uniffi_lipalightninglib_fn_clone_util(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_util(pointer, $0) }
    }

    

    
open func decodeData(data: String)throws  -> DecodedData {
    return try  FfiConverterTypeDecodedData.lift(try rustCallWithError(FfiConverterTypeDecodeDataError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_util_decode_data(self.uniffiClonePointer(),
        FfiConverterString.lower(data),$0
    )
})
}
    
open func derivePaymentUuid(paymentHash: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_util_derive_payment_uuid(self.uniffiClonePointer(),
        FfiConverterString.lower(paymentHash),$0
    )
})
}
    
open func getExchangeRate() -> ExchangeRate? {
    return try!  FfiConverterOptionTypeExchangeRate.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_method_util_get_exchange_rate(self.uniffiClonePointer(),$0
    )
})
}
    
open func getNodeInfo()throws  -> NodeInfo {
    return try  FfiConverterTypeNodeInfo.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_util_get_node_info(self.uniffiClonePointer(),$0
    )
})
}
    
open func logDebugInfo()throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_util_log_debug_info(self.uniffiClonePointer(),$0
    )
}
}
    
open func queryHealthStatus()throws  -> BreezHealthCheckStatus {
    return try  FfiConverterTypeBreezHealthCheckStatus.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_util_query_health_status(self.uniffiClonePointer(),$0
    )
})
}
    
open func queryWalletPubkeyId()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_util_query_wallet_pubkey_id(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUtil: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Util

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Util {
        return Util(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Util) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Util {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Util, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtil_lift(_ pointer: UnsafeMutableRawPointer) throws -> Util {
    return try FfiConverterTypeUtil.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtil_lower(_ value: Util) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUtil.lower(value)
}


public struct Amount {
    public var sats: UInt64
    public var fiat: FiatValue?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sats: UInt64, fiat: FiatValue?) {
        self.sats = sats
        self.fiat = fiat
    }
}



extension Amount: Equatable, Hashable {
    public static func ==(lhs: Amount, rhs: Amount) -> Bool {
        if lhs.sats != rhs.sats {
            return false
        }
        if lhs.fiat != rhs.fiat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sats)
        hasher.combine(fiat)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        return
            try Amount(
                sats: FfiConverterUInt64.read(from: &buf), 
                fiat: FfiConverterOptionTypeFiatValue.read(from: &buf)
        )
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.sats, into: &buf)
        FfiConverterOptionTypeFiatValue.write(value.fiat, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lift(_ buf: RustBuffer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lower(_ value: Amount) -> RustBuffer {
    return FfiConverterTypeAmount.lower(value)
}


public struct BitcoinAddressData {
    public var address: String
    public var network: Network
    public var amountSat: UInt64?
    public var label: String?
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, network: Network, amountSat: UInt64?, label: String?, message: String?) {
        self.address = address
        self.network = network
        self.amountSat = amountSat
        self.label = label
        self.message = message
    }
}



extension BitcoinAddressData: Equatable, Hashable {
    public static func ==(lhs: BitcoinAddressData, rhs: BitcoinAddressData) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.amountSat != rhs.amountSat {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(network)
        hasher.combine(amountSat)
        hasher.combine(label)
        hasher.combine(message)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinAddressData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinAddressData {
        return
            try BitcoinAddressData(
                address: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                amountSat: FfiConverterOptionUInt64.read(from: &buf), 
                label: FfiConverterOptionString.read(from: &buf), 
                message: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: BitcoinAddressData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterOptionUInt64.write(value.amountSat, into: &buf)
        FfiConverterOptionString.write(value.label, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinAddressData_lift(_ buf: RustBuffer) throws -> BitcoinAddressData {
    return try FfiConverterTypeBitcoinAddressData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinAddressData_lower(_ value: BitcoinAddressData) -> RustBuffer {
    return FfiConverterTypeBitcoinAddressData.lower(value)
}


public struct BreezSdkConfig {
    public var breezSdkApiKey: String
    public var breezSdkPartnerCertificate: String
    public var breezSdkPartnerKey: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(breezSdkApiKey: String, breezSdkPartnerCertificate: String, breezSdkPartnerKey: String) {
        self.breezSdkApiKey = breezSdkApiKey
        self.breezSdkPartnerCertificate = breezSdkPartnerCertificate
        self.breezSdkPartnerKey = breezSdkPartnerKey
    }
}



extension BreezSdkConfig: Equatable, Hashable {
    public static func ==(lhs: BreezSdkConfig, rhs: BreezSdkConfig) -> Bool {
        if lhs.breezSdkApiKey != rhs.breezSdkApiKey {
            return false
        }
        if lhs.breezSdkPartnerCertificate != rhs.breezSdkPartnerCertificate {
            return false
        }
        if lhs.breezSdkPartnerKey != rhs.breezSdkPartnerKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(breezSdkApiKey)
        hasher.combine(breezSdkPartnerCertificate)
        hasher.combine(breezSdkPartnerKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBreezSdkConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BreezSdkConfig {
        return
            try BreezSdkConfig(
                breezSdkApiKey: FfiConverterString.read(from: &buf), 
                breezSdkPartnerCertificate: FfiConverterString.read(from: &buf), 
                breezSdkPartnerKey: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: BreezSdkConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.breezSdkApiKey, into: &buf)
        FfiConverterString.write(value.breezSdkPartnerCertificate, into: &buf)
        FfiConverterString.write(value.breezSdkPartnerKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBreezSdkConfig_lift(_ buf: RustBuffer) throws -> BreezSdkConfig {
    return try FfiConverterTypeBreezSdkConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBreezSdkConfig_lower(_ value: BreezSdkConfig) -> RustBuffer {
    return FfiConverterTypeBreezSdkConfig.lower(value)
}


public struct CalculateLspFeeResponse {
    public var lspFee: Amount
    public var lspFeeParams: OpeningFeeParams?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lspFee: Amount, lspFeeParams: OpeningFeeParams?) {
        self.lspFee = lspFee
        self.lspFeeParams = lspFeeParams
    }
}



extension CalculateLspFeeResponse: Equatable, Hashable {
    public static func ==(lhs: CalculateLspFeeResponse, rhs: CalculateLspFeeResponse) -> Bool {
        if lhs.lspFee != rhs.lspFee {
            return false
        }
        if lhs.lspFeeParams != rhs.lspFeeParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lspFee)
        hasher.combine(lspFeeParams)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCalculateLspFeeResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CalculateLspFeeResponse {
        return
            try CalculateLspFeeResponse(
                lspFee: FfiConverterTypeAmount.read(from: &buf), 
                lspFeeParams: FfiConverterOptionTypeOpeningFeeParams.read(from: &buf)
        )
    }

    public static func write(_ value: CalculateLspFeeResponse, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.lspFee, into: &buf)
        FfiConverterOptionTypeOpeningFeeParams.write(value.lspFeeParams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCalculateLspFeeResponse_lift(_ buf: RustBuffer) throws -> CalculateLspFeeResponse {
    return try FfiConverterTypeCalculateLspFeeResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCalculateLspFeeResponse_lower(_ value: CalculateLspFeeResponse) -> RustBuffer {
    return FfiConverterTypeCalculateLspFeeResponse.lower(value)
}


public struct ChannelCloseInfo {
    public var amount: Amount
    public var state: ChannelCloseState
    public var closedAt: TzTime?
    public var closingTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Amount, state: ChannelCloseState, closedAt: TzTime?, closingTxId: String) {
        self.amount = amount
        self.state = state
        self.closedAt = closedAt
        self.closingTxId = closingTxId
    }
}



extension ChannelCloseInfo: Equatable, Hashable {
    public static func ==(lhs: ChannelCloseInfo, rhs: ChannelCloseInfo) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        if lhs.closedAt != rhs.closedAt {
            return false
        }
        if lhs.closingTxId != rhs.closingTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(state)
        hasher.combine(closedAt)
        hasher.combine(closingTxId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChannelCloseInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelCloseInfo {
        return
            try ChannelCloseInfo(
                amount: FfiConverterTypeAmount.read(from: &buf), 
                state: FfiConverterTypeChannelCloseState.read(from: &buf), 
                closedAt: FfiConverterOptionTypeTzTime.read(from: &buf), 
                closingTxId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ChannelCloseInfo, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.amount, into: &buf)
        FfiConverterTypeChannelCloseState.write(value.state, into: &buf)
        FfiConverterOptionTypeTzTime.write(value.closedAt, into: &buf)
        FfiConverterString.write(value.closingTxId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelCloseInfo_lift(_ buf: RustBuffer) throws -> ChannelCloseInfo {
    return try FfiConverterTypeChannelCloseInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelCloseInfo_lower(_ value: ChannelCloseInfo) -> RustBuffer {
    return FfiConverterTypeChannelCloseInfo.lower(value)
}


public struct ChannelsInfo {
    public var localBalance: Amount
    public var maxReceivableSinglePayment: Amount
    public var totalInboundCapacity: Amount
    public var outboundCapacity: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(localBalance: Amount, maxReceivableSinglePayment: Amount, totalInboundCapacity: Amount, outboundCapacity: Amount) {
        self.localBalance = localBalance
        self.maxReceivableSinglePayment = maxReceivableSinglePayment
        self.totalInboundCapacity = totalInboundCapacity
        self.outboundCapacity = outboundCapacity
    }
}



extension ChannelsInfo: Equatable, Hashable {
    public static func ==(lhs: ChannelsInfo, rhs: ChannelsInfo) -> Bool {
        if lhs.localBalance != rhs.localBalance {
            return false
        }
        if lhs.maxReceivableSinglePayment != rhs.maxReceivableSinglePayment {
            return false
        }
        if lhs.totalInboundCapacity != rhs.totalInboundCapacity {
            return false
        }
        if lhs.outboundCapacity != rhs.outboundCapacity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(localBalance)
        hasher.combine(maxReceivableSinglePayment)
        hasher.combine(totalInboundCapacity)
        hasher.combine(outboundCapacity)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChannelsInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelsInfo {
        return
            try ChannelsInfo(
                localBalance: FfiConverterTypeAmount.read(from: &buf), 
                maxReceivableSinglePayment: FfiConverterTypeAmount.read(from: &buf), 
                totalInboundCapacity: FfiConverterTypeAmount.read(from: &buf), 
                outboundCapacity: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: ChannelsInfo, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.localBalance, into: &buf)
        FfiConverterTypeAmount.write(value.maxReceivableSinglePayment, into: &buf)
        FfiConverterTypeAmount.write(value.totalInboundCapacity, into: &buf)
        FfiConverterTypeAmount.write(value.outboundCapacity, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelsInfo_lift(_ buf: RustBuffer) throws -> ChannelsInfo {
    return try FfiConverterTypeChannelsInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelsInfo_lower(_ value: ChannelsInfo) -> RustBuffer {
    return FfiConverterTypeChannelsInfo.lower(value)
}


public struct ClearWalletInfo {
    public var clearAmount: Amount
    public var totalEstimatedFees: Amount
    public var onchainFee: Amount
    public var swapFee: Amount
    public var prepareResponse: PrepareOnchainPaymentResponse

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(clearAmount: Amount, totalEstimatedFees: Amount, onchainFee: Amount, swapFee: Amount, prepareResponse: PrepareOnchainPaymentResponse) {
        self.clearAmount = clearAmount
        self.totalEstimatedFees = totalEstimatedFees
        self.onchainFee = onchainFee
        self.swapFee = swapFee
        self.prepareResponse = prepareResponse
    }
}



extension ClearWalletInfo: Equatable, Hashable {
    public static func ==(lhs: ClearWalletInfo, rhs: ClearWalletInfo) -> Bool {
        if lhs.clearAmount != rhs.clearAmount {
            return false
        }
        if lhs.totalEstimatedFees != rhs.totalEstimatedFees {
            return false
        }
        if lhs.onchainFee != rhs.onchainFee {
            return false
        }
        if lhs.swapFee != rhs.swapFee {
            return false
        }
        if lhs.prepareResponse != rhs.prepareResponse {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(clearAmount)
        hasher.combine(totalEstimatedFees)
        hasher.combine(onchainFee)
        hasher.combine(swapFee)
        hasher.combine(prepareResponse)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClearWalletInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClearWalletInfo {
        return
            try ClearWalletInfo(
                clearAmount: FfiConverterTypeAmount.read(from: &buf), 
                totalEstimatedFees: FfiConverterTypeAmount.read(from: &buf), 
                onchainFee: FfiConverterTypeAmount.read(from: &buf), 
                swapFee: FfiConverterTypeAmount.read(from: &buf), 
                prepareResponse: FfiConverterTypePrepareOnchainPaymentResponse.read(from: &buf)
        )
    }

    public static func write(_ value: ClearWalletInfo, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.clearAmount, into: &buf)
        FfiConverterTypeAmount.write(value.totalEstimatedFees, into: &buf)
        FfiConverterTypeAmount.write(value.onchainFee, into: &buf)
        FfiConverterTypeAmount.write(value.swapFee, into: &buf)
        FfiConverterTypePrepareOnchainPaymentResponse.write(value.prepareResponse, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClearWalletInfo_lift(_ buf: RustBuffer) throws -> ClearWalletInfo {
    return try FfiConverterTypeClearWalletInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClearWalletInfo_lower(_ value: ClearWalletInfo) -> RustBuffer {
    return FfiConverterTypeClearWalletInfo.lower(value)
}


public struct ExchangeRate {
    public var currencyCode: String
    public var rate: UInt32
    public var updatedAt: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(currencyCode: String, rate: UInt32, updatedAt: Date) {
        self.currencyCode = currencyCode
        self.rate = rate
        self.updatedAt = updatedAt
    }
}



extension ExchangeRate: Equatable, Hashable {
    public static func ==(lhs: ExchangeRate, rhs: ExchangeRate) -> Bool {
        if lhs.currencyCode != rhs.currencyCode {
            return false
        }
        if lhs.rate != rhs.rate {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(currencyCode)
        hasher.combine(rate)
        hasher.combine(updatedAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExchangeRate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExchangeRate {
        return
            try ExchangeRate(
                currencyCode: FfiConverterString.read(from: &buf), 
                rate: FfiConverterUInt32.read(from: &buf), 
                updatedAt: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: ExchangeRate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.currencyCode, into: &buf)
        FfiConverterUInt32.write(value.rate, into: &buf)
        FfiConverterTimestamp.write(value.updatedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExchangeRate_lift(_ buf: RustBuffer) throws -> ExchangeRate {
    return try FfiConverterTypeExchangeRate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExchangeRate_lower(_ value: ExchangeRate) -> RustBuffer {
    return FfiConverterTypeExchangeRate.lower(value)
}


public struct FailedSwapInfo {
    public var address: String
    public var amount: Amount
    public var createdAt: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, amount: Amount, createdAt: Date) {
        self.address = address
        self.amount = amount
        self.createdAt = createdAt
    }
}



extension FailedSwapInfo: Equatable, Hashable {
    public static func ==(lhs: FailedSwapInfo, rhs: FailedSwapInfo) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(amount)
        hasher.combine(createdAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFailedSwapInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FailedSwapInfo {
        return
            try FailedSwapInfo(
                address: FfiConverterString.read(from: &buf), 
                amount: FfiConverterTypeAmount.read(from: &buf), 
                createdAt: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: FailedSwapInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
        FfiConverterTimestamp.write(value.createdAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFailedSwapInfo_lift(_ buf: RustBuffer) throws -> FailedSwapInfo {
    return try FfiConverterTypeFailedSwapInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFailedSwapInfo_lower(_ value: FailedSwapInfo) -> RustBuffer {
    return FfiConverterTypeFailedSwapInfo.lower(value)
}


public struct FiatTopupInfo {
    public var orderId: String
    public var debitorIban: String
    public var creditorReference: String
    public var creditorIban: String
    public var creditorBankName: String
    public var creditorBankStreet: String
    public var creditorBankPostalCode: String
    public var creditorBankTown: String
    public var creditorBankCountry: String
    public var creditorBankBic: String
    public var creditorName: String
    public var creditorStreet: String
    public var creditorPostalCode: String
    public var creditorTown: String
    public var creditorCountry: String
    public var currency: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(orderId: String, debitorIban: String, creditorReference: String, creditorIban: String, creditorBankName: String, creditorBankStreet: String, creditorBankPostalCode: String, creditorBankTown: String, creditorBankCountry: String, creditorBankBic: String, creditorName: String, creditorStreet: String, creditorPostalCode: String, creditorTown: String, creditorCountry: String, currency: String) {
        self.orderId = orderId
        self.debitorIban = debitorIban
        self.creditorReference = creditorReference
        self.creditorIban = creditorIban
        self.creditorBankName = creditorBankName
        self.creditorBankStreet = creditorBankStreet
        self.creditorBankPostalCode = creditorBankPostalCode
        self.creditorBankTown = creditorBankTown
        self.creditorBankCountry = creditorBankCountry
        self.creditorBankBic = creditorBankBic
        self.creditorName = creditorName
        self.creditorStreet = creditorStreet
        self.creditorPostalCode = creditorPostalCode
        self.creditorTown = creditorTown
        self.creditorCountry = creditorCountry
        self.currency = currency
    }
}



extension FiatTopupInfo: Equatable, Hashable {
    public static func ==(lhs: FiatTopupInfo, rhs: FiatTopupInfo) -> Bool {
        if lhs.orderId != rhs.orderId {
            return false
        }
        if lhs.debitorIban != rhs.debitorIban {
            return false
        }
        if lhs.creditorReference != rhs.creditorReference {
            return false
        }
        if lhs.creditorIban != rhs.creditorIban {
            return false
        }
        if lhs.creditorBankName != rhs.creditorBankName {
            return false
        }
        if lhs.creditorBankStreet != rhs.creditorBankStreet {
            return false
        }
        if lhs.creditorBankPostalCode != rhs.creditorBankPostalCode {
            return false
        }
        if lhs.creditorBankTown != rhs.creditorBankTown {
            return false
        }
        if lhs.creditorBankCountry != rhs.creditorBankCountry {
            return false
        }
        if lhs.creditorBankBic != rhs.creditorBankBic {
            return false
        }
        if lhs.creditorName != rhs.creditorName {
            return false
        }
        if lhs.creditorStreet != rhs.creditorStreet {
            return false
        }
        if lhs.creditorPostalCode != rhs.creditorPostalCode {
            return false
        }
        if lhs.creditorTown != rhs.creditorTown {
            return false
        }
        if lhs.creditorCountry != rhs.creditorCountry {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(orderId)
        hasher.combine(debitorIban)
        hasher.combine(creditorReference)
        hasher.combine(creditorIban)
        hasher.combine(creditorBankName)
        hasher.combine(creditorBankStreet)
        hasher.combine(creditorBankPostalCode)
        hasher.combine(creditorBankTown)
        hasher.combine(creditorBankCountry)
        hasher.combine(creditorBankBic)
        hasher.combine(creditorName)
        hasher.combine(creditorStreet)
        hasher.combine(creditorPostalCode)
        hasher.combine(creditorTown)
        hasher.combine(creditorCountry)
        hasher.combine(currency)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatTopupInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatTopupInfo {
        return
            try FiatTopupInfo(
                orderId: FfiConverterString.read(from: &buf), 
                debitorIban: FfiConverterString.read(from: &buf), 
                creditorReference: FfiConverterString.read(from: &buf), 
                creditorIban: FfiConverterString.read(from: &buf), 
                creditorBankName: FfiConverterString.read(from: &buf), 
                creditorBankStreet: FfiConverterString.read(from: &buf), 
                creditorBankPostalCode: FfiConverterString.read(from: &buf), 
                creditorBankTown: FfiConverterString.read(from: &buf), 
                creditorBankCountry: FfiConverterString.read(from: &buf), 
                creditorBankBic: FfiConverterString.read(from: &buf), 
                creditorName: FfiConverterString.read(from: &buf), 
                creditorStreet: FfiConverterString.read(from: &buf), 
                creditorPostalCode: FfiConverterString.read(from: &buf), 
                creditorTown: FfiConverterString.read(from: &buf), 
                creditorCountry: FfiConverterString.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FiatTopupInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.orderId, into: &buf)
        FfiConverterString.write(value.debitorIban, into: &buf)
        FfiConverterString.write(value.creditorReference, into: &buf)
        FfiConverterString.write(value.creditorIban, into: &buf)
        FfiConverterString.write(value.creditorBankName, into: &buf)
        FfiConverterString.write(value.creditorBankStreet, into: &buf)
        FfiConverterString.write(value.creditorBankPostalCode, into: &buf)
        FfiConverterString.write(value.creditorBankTown, into: &buf)
        FfiConverterString.write(value.creditorBankCountry, into: &buf)
        FfiConverterString.write(value.creditorBankBic, into: &buf)
        FfiConverterString.write(value.creditorName, into: &buf)
        FfiConverterString.write(value.creditorStreet, into: &buf)
        FfiConverterString.write(value.creditorPostalCode, into: &buf)
        FfiConverterString.write(value.creditorTown, into: &buf)
        FfiConverterString.write(value.creditorCountry, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatTopupInfo_lift(_ buf: RustBuffer) throws -> FiatTopupInfo {
    return try FfiConverterTypeFiatTopupInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatTopupInfo_lower(_ value: FiatTopupInfo) -> RustBuffer {
    return FfiConverterTypeFiatTopupInfo.lower(value)
}


public struct FiatValue {
    public var minorUnits: UInt64
    public var currencyCode: String
    public var rate: UInt32
    public var convertedAt: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(minorUnits: UInt64, currencyCode: String, rate: UInt32, convertedAt: Date) {
        self.minorUnits = minorUnits
        self.currencyCode = currencyCode
        self.rate = rate
        self.convertedAt = convertedAt
    }
}



extension FiatValue: Equatable, Hashable {
    public static func ==(lhs: FiatValue, rhs: FiatValue) -> Bool {
        if lhs.minorUnits != rhs.minorUnits {
            return false
        }
        if lhs.currencyCode != rhs.currencyCode {
            return false
        }
        if lhs.rate != rhs.rate {
            return false
        }
        if lhs.convertedAt != rhs.convertedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(minorUnits)
        hasher.combine(currencyCode)
        hasher.combine(rate)
        hasher.combine(convertedAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatValue: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatValue {
        return
            try FiatValue(
                minorUnits: FfiConverterUInt64.read(from: &buf), 
                currencyCode: FfiConverterString.read(from: &buf), 
                rate: FfiConverterUInt32.read(from: &buf), 
                convertedAt: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: FiatValue, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.minorUnits, into: &buf)
        FfiConverterString.write(value.currencyCode, into: &buf)
        FfiConverterUInt32.write(value.rate, into: &buf)
        FfiConverterTimestamp.write(value.convertedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatValue_lift(_ buf: RustBuffer) throws -> FiatValue {
    return try FfiConverterTypeFiatValue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatValue_lower(_ value: FiatValue) -> RustBuffer {
    return FfiConverterTypeFiatValue.lower(value)
}


public struct IncomingPaymentInfo {
    public var paymentInfo: PaymentInfo
    public var requestedAmount: Amount
    public var lspFees: Amount
    public var receivedOn: Recipient?
    public var receivedLnurlComment: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentInfo: PaymentInfo, requestedAmount: Amount, lspFees: Amount, receivedOn: Recipient?, receivedLnurlComment: String?) {
        self.paymentInfo = paymentInfo
        self.requestedAmount = requestedAmount
        self.lspFees = lspFees
        self.receivedOn = receivedOn
        self.receivedLnurlComment = receivedLnurlComment
    }
}



extension IncomingPaymentInfo: Equatable, Hashable {
    public static func ==(lhs: IncomingPaymentInfo, rhs: IncomingPaymentInfo) -> Bool {
        if lhs.paymentInfo != rhs.paymentInfo {
            return false
        }
        if lhs.requestedAmount != rhs.requestedAmount {
            return false
        }
        if lhs.lspFees != rhs.lspFees {
            return false
        }
        if lhs.receivedOn != rhs.receivedOn {
            return false
        }
        if lhs.receivedLnurlComment != rhs.receivedLnurlComment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentInfo)
        hasher.combine(requestedAmount)
        hasher.combine(lspFees)
        hasher.combine(receivedOn)
        hasher.combine(receivedLnurlComment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIncomingPaymentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IncomingPaymentInfo {
        return
            try IncomingPaymentInfo(
                paymentInfo: FfiConverterTypePaymentInfo.read(from: &buf), 
                requestedAmount: FfiConverterTypeAmount.read(from: &buf), 
                lspFees: FfiConverterTypeAmount.read(from: &buf), 
                receivedOn: FfiConverterOptionTypeRecipient.read(from: &buf), 
                receivedLnurlComment: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: IncomingPaymentInfo, into buf: inout [UInt8]) {
        FfiConverterTypePaymentInfo.write(value.paymentInfo, into: &buf)
        FfiConverterTypeAmount.write(value.requestedAmount, into: &buf)
        FfiConverterTypeAmount.write(value.lspFees, into: &buf)
        FfiConverterOptionTypeRecipient.write(value.receivedOn, into: &buf)
        FfiConverterOptionString.write(value.receivedLnurlComment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIncomingPaymentInfo_lift(_ buf: RustBuffer) throws -> IncomingPaymentInfo {
    return try FfiConverterTypeIncomingPaymentInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIncomingPaymentInfo_lower(_ value: IncomingPaymentInfo) -> RustBuffer {
    return FfiConverterTypeIncomingPaymentInfo.lower(value)
}


public struct InvoiceCreationMetadata {
    public var requestCurrency: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(requestCurrency: String) {
        self.requestCurrency = requestCurrency
    }
}



extension InvoiceCreationMetadata: Equatable, Hashable {
    public static func ==(lhs: InvoiceCreationMetadata, rhs: InvoiceCreationMetadata) -> Bool {
        if lhs.requestCurrency != rhs.requestCurrency {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(requestCurrency)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInvoiceCreationMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvoiceCreationMetadata {
        return
            try InvoiceCreationMetadata(
                requestCurrency: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: InvoiceCreationMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.requestCurrency, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvoiceCreationMetadata_lift(_ buf: RustBuffer) throws -> InvoiceCreationMetadata {
    return try FfiConverterTypeInvoiceCreationMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvoiceCreationMetadata_lower(_ value: InvoiceCreationMetadata) -> RustBuffer {
    return FfiConverterTypeInvoiceCreationMetadata.lower(value)
}


public struct InvoiceDetails {
    public var invoice: String
    public var amount: Amount?
    public var description: String
    public var paymentHash: String
    public var payeePubKey: String
    public var creationTimestamp: Date
    public var expiryInterval: TimeInterval
    public var expiryTimestamp: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(invoice: String, amount: Amount?, description: String, paymentHash: String, payeePubKey: String, creationTimestamp: Date, expiryInterval: TimeInterval, expiryTimestamp: Date) {
        self.invoice = invoice
        self.amount = amount
        self.description = description
        self.paymentHash = paymentHash
        self.payeePubKey = payeePubKey
        self.creationTimestamp = creationTimestamp
        self.expiryInterval = expiryInterval
        self.expiryTimestamp = expiryTimestamp
    }
}



extension InvoiceDetails: Equatable, Hashable {
    public static func ==(lhs: InvoiceDetails, rhs: InvoiceDetails) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.payeePubKey != rhs.payeePubKey {
            return false
        }
        if lhs.creationTimestamp != rhs.creationTimestamp {
            return false
        }
        if lhs.expiryInterval != rhs.expiryInterval {
            return false
        }
        if lhs.expiryTimestamp != rhs.expiryTimestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(amount)
        hasher.combine(description)
        hasher.combine(paymentHash)
        hasher.combine(payeePubKey)
        hasher.combine(creationTimestamp)
        hasher.combine(expiryInterval)
        hasher.combine(expiryTimestamp)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInvoiceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvoiceDetails {
        return
            try InvoiceDetails(
                invoice: FfiConverterString.read(from: &buf), 
                amount: FfiConverterOptionTypeAmount.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf), 
                payeePubKey: FfiConverterString.read(from: &buf), 
                creationTimestamp: FfiConverterTimestamp.read(from: &buf), 
                expiryInterval: FfiConverterDuration.read(from: &buf), 
                expiryTimestamp: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: InvoiceDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterOptionTypeAmount.write(value.amount, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterString.write(value.payeePubKey, into: &buf)
        FfiConverterTimestamp.write(value.creationTimestamp, into: &buf)
        FfiConverterDuration.write(value.expiryInterval, into: &buf)
        FfiConverterTimestamp.write(value.expiryTimestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvoiceDetails_lift(_ buf: RustBuffer) throws -> InvoiceDetails {
    return try FfiConverterTypeInvoiceDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvoiceDetails_lower(_ value: InvoiceDetails) -> RustBuffer {
    return FfiConverterTypeInvoiceDetails.lower(value)
}


public struct LightningNodeConfig {
    public var seed: Data
    public var defaultFiatCurrency: String
    public var localPersistencePath: String
    public var timezoneConfig: TzConfig
    public var fileLoggingLevel: Level?
    public var phoneNumberAllowedCountriesIso31661Alpha2: [String]
    public var remoteServicesConfig: RemoteServicesConfig
    public var breezSdkConfig: BreezSdkConfig
    public var maxRoutingFeeConfig: MaxRoutingFeeConfig
    public var receiveLimitsConfig: ReceiveLimitsConfig

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(seed: Data, defaultFiatCurrency: String, localPersistencePath: String, timezoneConfig: TzConfig, fileLoggingLevel: Level?, phoneNumberAllowedCountriesIso31661Alpha2: [String], remoteServicesConfig: RemoteServicesConfig, breezSdkConfig: BreezSdkConfig, maxRoutingFeeConfig: MaxRoutingFeeConfig, receiveLimitsConfig: ReceiveLimitsConfig) {
        self.seed = seed
        self.defaultFiatCurrency = defaultFiatCurrency
        self.localPersistencePath = localPersistencePath
        self.timezoneConfig = timezoneConfig
        self.fileLoggingLevel = fileLoggingLevel
        self.phoneNumberAllowedCountriesIso31661Alpha2 = phoneNumberAllowedCountriesIso31661Alpha2
        self.remoteServicesConfig = remoteServicesConfig
        self.breezSdkConfig = breezSdkConfig
        self.maxRoutingFeeConfig = maxRoutingFeeConfig
        self.receiveLimitsConfig = receiveLimitsConfig
    }
}



extension LightningNodeConfig: Equatable, Hashable {
    public static func ==(lhs: LightningNodeConfig, rhs: LightningNodeConfig) -> Bool {
        if lhs.seed != rhs.seed {
            return false
        }
        if lhs.defaultFiatCurrency != rhs.defaultFiatCurrency {
            return false
        }
        if lhs.localPersistencePath != rhs.localPersistencePath {
            return false
        }
        if lhs.timezoneConfig != rhs.timezoneConfig {
            return false
        }
        if lhs.fileLoggingLevel != rhs.fileLoggingLevel {
            return false
        }
        if lhs.phoneNumberAllowedCountriesIso31661Alpha2 != rhs.phoneNumberAllowedCountriesIso31661Alpha2 {
            return false
        }
        if lhs.remoteServicesConfig != rhs.remoteServicesConfig {
            return false
        }
        if lhs.breezSdkConfig != rhs.breezSdkConfig {
            return false
        }
        if lhs.maxRoutingFeeConfig != rhs.maxRoutingFeeConfig {
            return false
        }
        if lhs.receiveLimitsConfig != rhs.receiveLimitsConfig {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(seed)
        hasher.combine(defaultFiatCurrency)
        hasher.combine(localPersistencePath)
        hasher.combine(timezoneConfig)
        hasher.combine(fileLoggingLevel)
        hasher.combine(phoneNumberAllowedCountriesIso31661Alpha2)
        hasher.combine(remoteServicesConfig)
        hasher.combine(breezSdkConfig)
        hasher.combine(maxRoutingFeeConfig)
        hasher.combine(receiveLimitsConfig)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningNodeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningNodeConfig {
        return
            try LightningNodeConfig(
                seed: FfiConverterData.read(from: &buf), 
                defaultFiatCurrency: FfiConverterString.read(from: &buf), 
                localPersistencePath: FfiConverterString.read(from: &buf), 
                timezoneConfig: FfiConverterTypeTzConfig.read(from: &buf), 
                fileLoggingLevel: FfiConverterOptionTypeLevel.read(from: &buf), 
                phoneNumberAllowedCountriesIso31661Alpha2: FfiConverterSequenceString.read(from: &buf), 
                remoteServicesConfig: FfiConverterTypeRemoteServicesConfig.read(from: &buf), 
                breezSdkConfig: FfiConverterTypeBreezSdkConfig.read(from: &buf), 
                maxRoutingFeeConfig: FfiConverterTypeMaxRoutingFeeConfig.read(from: &buf), 
                receiveLimitsConfig: FfiConverterTypeReceiveLimitsConfig.read(from: &buf)
        )
    }

    public static func write(_ value: LightningNodeConfig, into buf: inout [UInt8]) {
        FfiConverterData.write(value.seed, into: &buf)
        FfiConverterString.write(value.defaultFiatCurrency, into: &buf)
        FfiConverterString.write(value.localPersistencePath, into: &buf)
        FfiConverterTypeTzConfig.write(value.timezoneConfig, into: &buf)
        FfiConverterOptionTypeLevel.write(value.fileLoggingLevel, into: &buf)
        FfiConverterSequenceString.write(value.phoneNumberAllowedCountriesIso31661Alpha2, into: &buf)
        FfiConverterTypeRemoteServicesConfig.write(value.remoteServicesConfig, into: &buf)
        FfiConverterTypeBreezSdkConfig.write(value.breezSdkConfig, into: &buf)
        FfiConverterTypeMaxRoutingFeeConfig.write(value.maxRoutingFeeConfig, into: &buf)
        FfiConverterTypeReceiveLimitsConfig.write(value.receiveLimitsConfig, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningNodeConfig_lift(_ buf: RustBuffer) throws -> LightningNodeConfig {
    return try FfiConverterTypeLightningNodeConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningNodeConfig_lower(_ value: LightningNodeConfig) -> RustBuffer {
    return FfiConverterTypeLightningNodeConfig.lower(value)
}


public struct ListActivitiesResponse {
    public var pendingActivities: [Activity]
    public var completedActivities: [Activity]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pendingActivities: [Activity], completedActivities: [Activity]) {
        self.pendingActivities = pendingActivities
        self.completedActivities = completedActivities
    }
}



extension ListActivitiesResponse: Equatable, Hashable {
    public static func ==(lhs: ListActivitiesResponse, rhs: ListActivitiesResponse) -> Bool {
        if lhs.pendingActivities != rhs.pendingActivities {
            return false
        }
        if lhs.completedActivities != rhs.completedActivities {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pendingActivities)
        hasher.combine(completedActivities)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListActivitiesResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListActivitiesResponse {
        return
            try ListActivitiesResponse(
                pendingActivities: FfiConverterSequenceTypeActivity.read(from: &buf), 
                completedActivities: FfiConverterSequenceTypeActivity.read(from: &buf)
        )
    }

    public static func write(_ value: ListActivitiesResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeActivity.write(value.pendingActivities, into: &buf)
        FfiConverterSequenceTypeActivity.write(value.completedActivities, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListActivitiesResponse_lift(_ buf: RustBuffer) throws -> ListActivitiesResponse {
    return try FfiConverterTypeListActivitiesResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListActivitiesResponse_lower(_ value: ListActivitiesResponse) -> RustBuffer {
    return FfiConverterTypeListActivitiesResponse.lower(value)
}


public struct LnUrlPayDetails {
    public var domain: String
    public var shortDescription: String
    public var longDescription: String?
    public var minSendable: Amount
    public var maxSendable: Amount
    public var maxCommentLength: UInt16
    public var requestData: LnUrlPayRequestData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(domain: String, shortDescription: String, longDescription: String?, minSendable: Amount, maxSendable: Amount, maxCommentLength: UInt16, requestData: LnUrlPayRequestData) {
        self.domain = domain
        self.shortDescription = shortDescription
        self.longDescription = longDescription
        self.minSendable = minSendable
        self.maxSendable = maxSendable
        self.maxCommentLength = maxCommentLength
        self.requestData = requestData
    }
}



extension LnUrlPayDetails: Equatable, Hashable {
    public static func ==(lhs: LnUrlPayDetails, rhs: LnUrlPayDetails) -> Bool {
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.shortDescription != rhs.shortDescription {
            return false
        }
        if lhs.longDescription != rhs.longDescription {
            return false
        }
        if lhs.minSendable != rhs.minSendable {
            return false
        }
        if lhs.maxSendable != rhs.maxSendable {
            return false
        }
        if lhs.maxCommentLength != rhs.maxCommentLength {
            return false
        }
        if lhs.requestData != rhs.requestData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(domain)
        hasher.combine(shortDescription)
        hasher.combine(longDescription)
        hasher.combine(minSendable)
        hasher.combine(maxSendable)
        hasher.combine(maxCommentLength)
        hasher.combine(requestData)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnUrlPayDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayDetails {
        return
            try LnUrlPayDetails(
                domain: FfiConverterString.read(from: &buf), 
                shortDescription: FfiConverterString.read(from: &buf), 
                longDescription: FfiConverterOptionString.read(from: &buf), 
                minSendable: FfiConverterTypeAmount.read(from: &buf), 
                maxSendable: FfiConverterTypeAmount.read(from: &buf), 
                maxCommentLength: FfiConverterUInt16.read(from: &buf), 
                requestData: FfiConverterTypeLnUrlPayRequestData.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlPayDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterString.write(value.shortDescription, into: &buf)
        FfiConverterOptionString.write(value.longDescription, into: &buf)
        FfiConverterTypeAmount.write(value.minSendable, into: &buf)
        FfiConverterTypeAmount.write(value.maxSendable, into: &buf)
        FfiConverterUInt16.write(value.maxCommentLength, into: &buf)
        FfiConverterTypeLnUrlPayRequestData.write(value.requestData, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnUrlPayDetails_lift(_ buf: RustBuffer) throws -> LnUrlPayDetails {
    return try FfiConverterTypeLnUrlPayDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnUrlPayDetails_lower(_ value: LnUrlPayDetails) -> RustBuffer {
    return FfiConverterTypeLnUrlPayDetails.lower(value)
}


public struct LnUrlPayRequestData {
    public var callback: String
    public var minSendable: UInt64
    public var maxSendable: UInt64
    public var metadataStr: String
    public var commentAllowed: UInt16
    public var domain: String
    public var allowsNostr: Bool
    public var nostrPubkey: String?
    public var lnAddress: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(callback: String, minSendable: UInt64, maxSendable: UInt64, metadataStr: String, commentAllowed: UInt16, domain: String, allowsNostr: Bool, nostrPubkey: String?, lnAddress: String?) {
        self.callback = callback
        self.minSendable = minSendable
        self.maxSendable = maxSendable
        self.metadataStr = metadataStr
        self.commentAllowed = commentAllowed
        self.domain = domain
        self.allowsNostr = allowsNostr
        self.nostrPubkey = nostrPubkey
        self.lnAddress = lnAddress
    }
}



extension LnUrlPayRequestData: Equatable, Hashable {
    public static func ==(lhs: LnUrlPayRequestData, rhs: LnUrlPayRequestData) -> Bool {
        if lhs.callback != rhs.callback {
            return false
        }
        if lhs.minSendable != rhs.minSendable {
            return false
        }
        if lhs.maxSendable != rhs.maxSendable {
            return false
        }
        if lhs.metadataStr != rhs.metadataStr {
            return false
        }
        if lhs.commentAllowed != rhs.commentAllowed {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.allowsNostr != rhs.allowsNostr {
            return false
        }
        if lhs.nostrPubkey != rhs.nostrPubkey {
            return false
        }
        if lhs.lnAddress != rhs.lnAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(callback)
        hasher.combine(minSendable)
        hasher.combine(maxSendable)
        hasher.combine(metadataStr)
        hasher.combine(commentAllowed)
        hasher.combine(domain)
        hasher.combine(allowsNostr)
        hasher.combine(nostrPubkey)
        hasher.combine(lnAddress)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnUrlPayRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayRequestData {
        return
            try LnUrlPayRequestData(
                callback: FfiConverterString.read(from: &buf), 
                minSendable: FfiConverterUInt64.read(from: &buf), 
                maxSendable: FfiConverterUInt64.read(from: &buf), 
                metadataStr: FfiConverterString.read(from: &buf), 
                commentAllowed: FfiConverterUInt16.read(from: &buf), 
                domain: FfiConverterString.read(from: &buf), 
                allowsNostr: FfiConverterBool.read(from: &buf), 
                nostrPubkey: FfiConverterOptionString.read(from: &buf), 
                lnAddress: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlPayRequestData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.callback, into: &buf)
        FfiConverterUInt64.write(value.minSendable, into: &buf)
        FfiConverterUInt64.write(value.maxSendable, into: &buf)
        FfiConverterString.write(value.metadataStr, into: &buf)
        FfiConverterUInt16.write(value.commentAllowed, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterBool.write(value.allowsNostr, into: &buf)
        FfiConverterOptionString.write(value.nostrPubkey, into: &buf)
        FfiConverterOptionString.write(value.lnAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnUrlPayRequestData_lift(_ buf: RustBuffer) throws -> LnUrlPayRequestData {
    return try FfiConverterTypeLnUrlPayRequestData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnUrlPayRequestData_lower(_ value: LnUrlPayRequestData) -> RustBuffer {
    return FfiConverterTypeLnUrlPayRequestData.lower(value)
}


public struct LnUrlWithdrawDetails {
    public var minWithdrawable: Amount
    public var maxWithdrawable: Amount
    public var requestData: LnUrlWithdrawRequestData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(minWithdrawable: Amount, maxWithdrawable: Amount, requestData: LnUrlWithdrawRequestData) {
        self.minWithdrawable = minWithdrawable
        self.maxWithdrawable = maxWithdrawable
        self.requestData = requestData
    }
}



extension LnUrlWithdrawDetails: Equatable, Hashable {
    public static func ==(lhs: LnUrlWithdrawDetails, rhs: LnUrlWithdrawDetails) -> Bool {
        if lhs.minWithdrawable != rhs.minWithdrawable {
            return false
        }
        if lhs.maxWithdrawable != rhs.maxWithdrawable {
            return false
        }
        if lhs.requestData != rhs.requestData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(minWithdrawable)
        hasher.combine(maxWithdrawable)
        hasher.combine(requestData)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnUrlWithdrawDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlWithdrawDetails {
        return
            try LnUrlWithdrawDetails(
                minWithdrawable: FfiConverterTypeAmount.read(from: &buf), 
                maxWithdrawable: FfiConverterTypeAmount.read(from: &buf), 
                requestData: FfiConverterTypeLnUrlWithdrawRequestData.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlWithdrawDetails, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.minWithdrawable, into: &buf)
        FfiConverterTypeAmount.write(value.maxWithdrawable, into: &buf)
        FfiConverterTypeLnUrlWithdrawRequestData.write(value.requestData, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnUrlWithdrawDetails_lift(_ buf: RustBuffer) throws -> LnUrlWithdrawDetails {
    return try FfiConverterTypeLnUrlWithdrawDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnUrlWithdrawDetails_lower(_ value: LnUrlWithdrawDetails) -> RustBuffer {
    return FfiConverterTypeLnUrlWithdrawDetails.lower(value)
}


public struct LnUrlWithdrawRequestData {
    public var callback: String
    public var k1: String
    public var defaultDescription: String
    public var minWithdrawable: UInt64
    public var maxWithdrawable: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(callback: String, k1: String, defaultDescription: String, minWithdrawable: UInt64, maxWithdrawable: UInt64) {
        self.callback = callback
        self.k1 = k1
        self.defaultDescription = defaultDescription
        self.minWithdrawable = minWithdrawable
        self.maxWithdrawable = maxWithdrawable
    }
}



extension LnUrlWithdrawRequestData: Equatable, Hashable {
    public static func ==(lhs: LnUrlWithdrawRequestData, rhs: LnUrlWithdrawRequestData) -> Bool {
        if lhs.callback != rhs.callback {
            return false
        }
        if lhs.k1 != rhs.k1 {
            return false
        }
        if lhs.defaultDescription != rhs.defaultDescription {
            return false
        }
        if lhs.minWithdrawable != rhs.minWithdrawable {
            return false
        }
        if lhs.maxWithdrawable != rhs.maxWithdrawable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(callback)
        hasher.combine(k1)
        hasher.combine(defaultDescription)
        hasher.combine(minWithdrawable)
        hasher.combine(maxWithdrawable)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnUrlWithdrawRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlWithdrawRequestData {
        return
            try LnUrlWithdrawRequestData(
                callback: FfiConverterString.read(from: &buf), 
                k1: FfiConverterString.read(from: &buf), 
                defaultDescription: FfiConverterString.read(from: &buf), 
                minWithdrawable: FfiConverterUInt64.read(from: &buf), 
                maxWithdrawable: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlWithdrawRequestData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.callback, into: &buf)
        FfiConverterString.write(value.k1, into: &buf)
        FfiConverterString.write(value.defaultDescription, into: &buf)
        FfiConverterUInt64.write(value.minWithdrawable, into: &buf)
        FfiConverterUInt64.write(value.maxWithdrawable, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnUrlWithdrawRequestData_lift(_ buf: RustBuffer) throws -> LnUrlWithdrawRequestData {
    return try FfiConverterTypeLnUrlWithdrawRequestData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnUrlWithdrawRequestData_lower(_ value: LnUrlWithdrawRequestData) -> RustBuffer {
    return FfiConverterTypeLnUrlWithdrawRequestData.lower(value)
}


public struct LspFee {
    public var channelMinimumFee: Amount
    public var channelFeePermyriad: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(channelMinimumFee: Amount, channelFeePermyriad: UInt64) {
        self.channelMinimumFee = channelMinimumFee
        self.channelFeePermyriad = channelFeePermyriad
    }
}



extension LspFee: Equatable, Hashable {
    public static func ==(lhs: LspFee, rhs: LspFee) -> Bool {
        if lhs.channelMinimumFee != rhs.channelMinimumFee {
            return false
        }
        if lhs.channelFeePermyriad != rhs.channelFeePermyriad {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channelMinimumFee)
        hasher.combine(channelFeePermyriad)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLspFee: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LspFee {
        return
            try LspFee(
                channelMinimumFee: FfiConverterTypeAmount.read(from: &buf), 
                channelFeePermyriad: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LspFee, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.channelMinimumFee, into: &buf)
        FfiConverterUInt64.write(value.channelFeePermyriad, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLspFee_lift(_ buf: RustBuffer) throws -> LspFee {
    return try FfiConverterTypeLspFee.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLspFee_lower(_ value: LspFee) -> RustBuffer {
    return FfiConverterTypeLspFee.lower(value)
}


public struct MaxRoutingFeeConfig {
    public var maxRoutingFeePermyriad: UInt16
    public var maxRoutingFeeExemptFeeSats: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxRoutingFeePermyriad: UInt16, maxRoutingFeeExemptFeeSats: UInt64) {
        self.maxRoutingFeePermyriad = maxRoutingFeePermyriad
        self.maxRoutingFeeExemptFeeSats = maxRoutingFeeExemptFeeSats
    }
}



extension MaxRoutingFeeConfig: Equatable, Hashable {
    public static func ==(lhs: MaxRoutingFeeConfig, rhs: MaxRoutingFeeConfig) -> Bool {
        if lhs.maxRoutingFeePermyriad != rhs.maxRoutingFeePermyriad {
            return false
        }
        if lhs.maxRoutingFeeExemptFeeSats != rhs.maxRoutingFeeExemptFeeSats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxRoutingFeePermyriad)
        hasher.combine(maxRoutingFeeExemptFeeSats)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMaxRoutingFeeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MaxRoutingFeeConfig {
        return
            try MaxRoutingFeeConfig(
                maxRoutingFeePermyriad: FfiConverterUInt16.read(from: &buf), 
                maxRoutingFeeExemptFeeSats: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: MaxRoutingFeeConfig, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.maxRoutingFeePermyriad, into: &buf)
        FfiConverterUInt64.write(value.maxRoutingFeeExemptFeeSats, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMaxRoutingFeeConfig_lift(_ buf: RustBuffer) throws -> MaxRoutingFeeConfig {
    return try FfiConverterTypeMaxRoutingFeeConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMaxRoutingFeeConfig_lower(_ value: MaxRoutingFeeConfig) -> RustBuffer {
    return FfiConverterTypeMaxRoutingFeeConfig.lower(value)
}


public struct NodeInfo {
    public var nodePubkey: String
    public var peers: [String]
    public var onchainBalance: Amount
    public var channelsInfo: ChannelsInfo

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nodePubkey: String, peers: [String], onchainBalance: Amount, channelsInfo: ChannelsInfo) {
        self.nodePubkey = nodePubkey
        self.peers = peers
        self.onchainBalance = onchainBalance
        self.channelsInfo = channelsInfo
    }
}



extension NodeInfo: Equatable, Hashable {
    public static func ==(lhs: NodeInfo, rhs: NodeInfo) -> Bool {
        if lhs.nodePubkey != rhs.nodePubkey {
            return false
        }
        if lhs.peers != rhs.peers {
            return false
        }
        if lhs.onchainBalance != rhs.onchainBalance {
            return false
        }
        if lhs.channelsInfo != rhs.channelsInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodePubkey)
        hasher.combine(peers)
        hasher.combine(onchainBalance)
        hasher.combine(channelsInfo)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeInfo {
        return
            try NodeInfo(
                nodePubkey: FfiConverterString.read(from: &buf), 
                peers: FfiConverterSequenceString.read(from: &buf), 
                onchainBalance: FfiConverterTypeAmount.read(from: &buf), 
                channelsInfo: FfiConverterTypeChannelsInfo.read(from: &buf)
        )
    }

    public static func write(_ value: NodeInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.nodePubkey, into: &buf)
        FfiConverterSequenceString.write(value.peers, into: &buf)
        FfiConverterTypeAmount.write(value.onchainBalance, into: &buf)
        FfiConverterTypeChannelsInfo.write(value.channelsInfo, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeInfo_lift(_ buf: RustBuffer) throws -> NodeInfo {
    return try FfiConverterTypeNodeInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeInfo_lower(_ value: NodeInfo) -> RustBuffer {
    return FfiConverterTypeNodeInfo.lower(value)
}


public struct NotificationToggles {
    public var paymentReceivedIsEnabled: Bool
    public var addressTxsConfirmedIsEnabled: Bool
    public var lnurlPayRequestIsEnabled: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentReceivedIsEnabled: Bool, addressTxsConfirmedIsEnabled: Bool, lnurlPayRequestIsEnabled: Bool) {
        self.paymentReceivedIsEnabled = paymentReceivedIsEnabled
        self.addressTxsConfirmedIsEnabled = addressTxsConfirmedIsEnabled
        self.lnurlPayRequestIsEnabled = lnurlPayRequestIsEnabled
    }
}



extension NotificationToggles: Equatable, Hashable {
    public static func ==(lhs: NotificationToggles, rhs: NotificationToggles) -> Bool {
        if lhs.paymentReceivedIsEnabled != rhs.paymentReceivedIsEnabled {
            return false
        }
        if lhs.addressTxsConfirmedIsEnabled != rhs.addressTxsConfirmedIsEnabled {
            return false
        }
        if lhs.lnurlPayRequestIsEnabled != rhs.lnurlPayRequestIsEnabled {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentReceivedIsEnabled)
        hasher.combine(addressTxsConfirmedIsEnabled)
        hasher.combine(lnurlPayRequestIsEnabled)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationToggles: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationToggles {
        return
            try NotificationToggles(
                paymentReceivedIsEnabled: FfiConverterBool.read(from: &buf), 
                addressTxsConfirmedIsEnabled: FfiConverterBool.read(from: &buf), 
                lnurlPayRequestIsEnabled: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationToggles, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.paymentReceivedIsEnabled, into: &buf)
        FfiConverterBool.write(value.addressTxsConfirmedIsEnabled, into: &buf)
        FfiConverterBool.write(value.lnurlPayRequestIsEnabled, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationToggles_lift(_ buf: RustBuffer) throws -> NotificationToggles {
    return try FfiConverterTypeNotificationToggles.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationToggles_lower(_ value: NotificationToggles) -> RustBuffer {
    return FfiConverterTypeNotificationToggles.lower(value)
}


public struct OfferInfo {
    public var offerKind: OfferKind
    public var amount: Amount
    public var lnurlw: String?
    public var createdAt: Date
    public var expiresAt: Date?
    public var status: OfferStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(offerKind: OfferKind, amount: Amount, lnurlw: String?, createdAt: Date, expiresAt: Date?, status: OfferStatus) {
        self.offerKind = offerKind
        self.amount = amount
        self.lnurlw = lnurlw
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.status = status
    }
}



extension OfferInfo: Equatable, Hashable {
    public static func ==(lhs: OfferInfo, rhs: OfferInfo) -> Bool {
        if lhs.offerKind != rhs.offerKind {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.lnurlw != rhs.lnurlw {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(offerKind)
        hasher.combine(amount)
        hasher.combine(lnurlw)
        hasher.combine(createdAt)
        hasher.combine(expiresAt)
        hasher.combine(status)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOfferInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferInfo {
        return
            try OfferInfo(
                offerKind: FfiConverterTypeOfferKind.read(from: &buf), 
                amount: FfiConverterTypeAmount.read(from: &buf), 
                lnurlw: FfiConverterOptionString.read(from: &buf), 
                createdAt: FfiConverterTimestamp.read(from: &buf), 
                expiresAt: FfiConverterOptionTimestamp.read(from: &buf), 
                status: FfiConverterTypeOfferStatus.read(from: &buf)
        )
    }

    public static func write(_ value: OfferInfo, into buf: inout [UInt8]) {
        FfiConverterTypeOfferKind.write(value.offerKind, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.lnurlw, into: &buf)
        FfiConverterTimestamp.write(value.createdAt, into: &buf)
        FfiConverterOptionTimestamp.write(value.expiresAt, into: &buf)
        FfiConverterTypeOfferStatus.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOfferInfo_lift(_ buf: RustBuffer) throws -> OfferInfo {
    return try FfiConverterTypeOfferInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOfferInfo_lower(_ value: OfferInfo) -> RustBuffer {
    return FfiConverterTypeOfferInfo.lower(value)
}


public struct OnchainResolvingFees {
    public var swapFees: SwapToLightningFees?
    public var sweepOnchainFeeEstimate: Amount
    public var satsPerVbyte: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(swapFees: SwapToLightningFees?, sweepOnchainFeeEstimate: Amount, satsPerVbyte: UInt32) {
        self.swapFees = swapFees
        self.sweepOnchainFeeEstimate = sweepOnchainFeeEstimate
        self.satsPerVbyte = satsPerVbyte
    }
}



extension OnchainResolvingFees: Equatable, Hashable {
    public static func ==(lhs: OnchainResolvingFees, rhs: OnchainResolvingFees) -> Bool {
        if lhs.swapFees != rhs.swapFees {
            return false
        }
        if lhs.sweepOnchainFeeEstimate != rhs.sweepOnchainFeeEstimate {
            return false
        }
        if lhs.satsPerVbyte != rhs.satsPerVbyte {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(swapFees)
        hasher.combine(sweepOnchainFeeEstimate)
        hasher.combine(satsPerVbyte)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOnchainResolvingFees: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnchainResolvingFees {
        return
            try OnchainResolvingFees(
                swapFees: FfiConverterOptionTypeSwapToLightningFees.read(from: &buf), 
                sweepOnchainFeeEstimate: FfiConverterTypeAmount.read(from: &buf), 
                satsPerVbyte: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: OnchainResolvingFees, into buf: inout [UInt8]) {
        FfiConverterOptionTypeSwapToLightningFees.write(value.swapFees, into: &buf)
        FfiConverterTypeAmount.write(value.sweepOnchainFeeEstimate, into: &buf)
        FfiConverterUInt32.write(value.satsPerVbyte, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainResolvingFees_lift(_ buf: RustBuffer) throws -> OnchainResolvingFees {
    return try FfiConverterTypeOnchainResolvingFees.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainResolvingFees_lower(_ value: OnchainResolvingFees) -> RustBuffer {
    return FfiConverterTypeOnchainResolvingFees.lower(value)
}


public struct OpeningFeeParams {
    public var minMsat: UInt64
    public var proportional: UInt32
    public var validUntil: String
    public var maxIdleTime: UInt32
    public var maxClientToSelfDelay: UInt32
    public var promise: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(minMsat: UInt64, proportional: UInt32, validUntil: String, maxIdleTime: UInt32, maxClientToSelfDelay: UInt32, promise: String) {
        self.minMsat = minMsat
        self.proportional = proportional
        self.validUntil = validUntil
        self.maxIdleTime = maxIdleTime
        self.maxClientToSelfDelay = maxClientToSelfDelay
        self.promise = promise
    }
}



extension OpeningFeeParams: Equatable, Hashable {
    public static func ==(lhs: OpeningFeeParams, rhs: OpeningFeeParams) -> Bool {
        if lhs.minMsat != rhs.minMsat {
            return false
        }
        if lhs.proportional != rhs.proportional {
            return false
        }
        if lhs.validUntil != rhs.validUntil {
            return false
        }
        if lhs.maxIdleTime != rhs.maxIdleTime {
            return false
        }
        if lhs.maxClientToSelfDelay != rhs.maxClientToSelfDelay {
            return false
        }
        if lhs.promise != rhs.promise {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(minMsat)
        hasher.combine(proportional)
        hasher.combine(validUntil)
        hasher.combine(maxIdleTime)
        hasher.combine(maxClientToSelfDelay)
        hasher.combine(promise)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOpeningFeeParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpeningFeeParams {
        return
            try OpeningFeeParams(
                minMsat: FfiConverterUInt64.read(from: &buf), 
                proportional: FfiConverterUInt32.read(from: &buf), 
                validUntil: FfiConverterString.read(from: &buf), 
                maxIdleTime: FfiConverterUInt32.read(from: &buf), 
                maxClientToSelfDelay: FfiConverterUInt32.read(from: &buf), 
                promise: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: OpeningFeeParams, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.minMsat, into: &buf)
        FfiConverterUInt32.write(value.proportional, into: &buf)
        FfiConverterString.write(value.validUntil, into: &buf)
        FfiConverterUInt32.write(value.maxIdleTime, into: &buf)
        FfiConverterUInt32.write(value.maxClientToSelfDelay, into: &buf)
        FfiConverterString.write(value.promise, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpeningFeeParams_lift(_ buf: RustBuffer) throws -> OpeningFeeParams {
    return try FfiConverterTypeOpeningFeeParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpeningFeeParams_lower(_ value: OpeningFeeParams) -> RustBuffer {
    return FfiConverterTypeOpeningFeeParams.lower(value)
}


public struct OutgoingPaymentInfo {
    public var paymentInfo: PaymentInfo
    public var networkFees: Amount
    public var recipient: Recipient
    public var commentForRecipient: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentInfo: PaymentInfo, networkFees: Amount, recipient: Recipient, commentForRecipient: String?) {
        self.paymentInfo = paymentInfo
        self.networkFees = networkFees
        self.recipient = recipient
        self.commentForRecipient = commentForRecipient
    }
}



extension OutgoingPaymentInfo: Equatable, Hashable {
    public static func ==(lhs: OutgoingPaymentInfo, rhs: OutgoingPaymentInfo) -> Bool {
        if lhs.paymentInfo != rhs.paymentInfo {
            return false
        }
        if lhs.networkFees != rhs.networkFees {
            return false
        }
        if lhs.recipient != rhs.recipient {
            return false
        }
        if lhs.commentForRecipient != rhs.commentForRecipient {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentInfo)
        hasher.combine(networkFees)
        hasher.combine(recipient)
        hasher.combine(commentForRecipient)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutgoingPaymentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutgoingPaymentInfo {
        return
            try OutgoingPaymentInfo(
                paymentInfo: FfiConverterTypePaymentInfo.read(from: &buf), 
                networkFees: FfiConverterTypeAmount.read(from: &buf), 
                recipient: FfiConverterTypeRecipient.read(from: &buf), 
                commentForRecipient: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: OutgoingPaymentInfo, into buf: inout [UInt8]) {
        FfiConverterTypePaymentInfo.write(value.paymentInfo, into: &buf)
        FfiConverterTypeAmount.write(value.networkFees, into: &buf)
        FfiConverterTypeRecipient.write(value.recipient, into: &buf)
        FfiConverterOptionString.write(value.commentForRecipient, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutgoingPaymentInfo_lift(_ buf: RustBuffer) throws -> OutgoingPaymentInfo {
    return try FfiConverterTypeOutgoingPaymentInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutgoingPaymentInfo_lower(_ value: OutgoingPaymentInfo) -> RustBuffer {
    return FfiConverterTypeOutgoingPaymentInfo.lower(value)
}


public struct PaymentAmountLimits {
    public var maxReceive: Amount
    public var liquidityLimit: LiquidityLimit

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxReceive: Amount, liquidityLimit: LiquidityLimit) {
        self.maxReceive = maxReceive
        self.liquidityLimit = liquidityLimit
    }
}



extension PaymentAmountLimits: Equatable, Hashable {
    public static func ==(lhs: PaymentAmountLimits, rhs: PaymentAmountLimits) -> Bool {
        if lhs.maxReceive != rhs.maxReceive {
            return false
        }
        if lhs.liquidityLimit != rhs.liquidityLimit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxReceive)
        hasher.combine(liquidityLimit)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentAmountLimits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentAmountLimits {
        return
            try PaymentAmountLimits(
                maxReceive: FfiConverterTypeAmount.read(from: &buf), 
                liquidityLimit: FfiConverterTypeLiquidityLimit.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentAmountLimits, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.maxReceive, into: &buf)
        FfiConverterTypeLiquidityLimit.write(value.liquidityLimit, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentAmountLimits_lift(_ buf: RustBuffer) throws -> PaymentAmountLimits {
    return try FfiConverterTypePaymentAmountLimits.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentAmountLimits_lower(_ value: PaymentAmountLimits) -> RustBuffer {
    return FfiConverterTypePaymentAmountLimits.lower(value)
}


public struct PaymentInfo {
    public var paymentState: PaymentState
    public var hash: String
    public var amount: Amount
    public var invoiceDetails: InvoiceDetails
    public var createdAt: TzTime
    public var description: String
    public var preimage: String?
    public var personalNote: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentState: PaymentState, hash: String, amount: Amount, invoiceDetails: InvoiceDetails, createdAt: TzTime, description: String, preimage: String?, personalNote: String?) {
        self.paymentState = paymentState
        self.hash = hash
        self.amount = amount
        self.invoiceDetails = invoiceDetails
        self.createdAt = createdAt
        self.description = description
        self.preimage = preimage
        self.personalNote = personalNote
    }
}



extension PaymentInfo: Equatable, Hashable {
    public static func ==(lhs: PaymentInfo, rhs: PaymentInfo) -> Bool {
        if lhs.paymentState != rhs.paymentState {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.invoiceDetails != rhs.invoiceDetails {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.personalNote != rhs.personalNote {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentState)
        hasher.combine(hash)
        hasher.combine(amount)
        hasher.combine(invoiceDetails)
        hasher.combine(createdAt)
        hasher.combine(description)
        hasher.combine(preimage)
        hasher.combine(personalNote)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentInfo {
        return
            try PaymentInfo(
                paymentState: FfiConverterTypePaymentState.read(from: &buf), 
                hash: FfiConverterString.read(from: &buf), 
                amount: FfiConverterTypeAmount.read(from: &buf), 
                invoiceDetails: FfiConverterTypeInvoiceDetails.read(from: &buf), 
                createdAt: FfiConverterTypeTzTime.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                preimage: FfiConverterOptionString.read(from: &buf), 
                personalNote: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentInfo, into buf: inout [UInt8]) {
        FfiConverterTypePaymentState.write(value.paymentState, into: &buf)
        FfiConverterString.write(value.hash, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
        FfiConverterTypeInvoiceDetails.write(value.invoiceDetails, into: &buf)
        FfiConverterTypeTzTime.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.preimage, into: &buf)
        FfiConverterOptionString.write(value.personalNote, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentInfo_lift(_ buf: RustBuffer) throws -> PaymentInfo {
    return try FfiConverterTypePaymentInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentInfo_lower(_ value: PaymentInfo) -> RustBuffer {
    return FfiConverterTypePaymentInfo.lower(value)
}


public struct PaymentMetadata {
    public var source: PaymentSource
    public var processStartedAt: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(source: PaymentSource, processStartedAt: Date) {
        self.source = source
        self.processStartedAt = processStartedAt
    }
}



extension PaymentMetadata: Equatable, Hashable {
    public static func ==(lhs: PaymentMetadata, rhs: PaymentMetadata) -> Bool {
        if lhs.source != rhs.source {
            return false
        }
        if lhs.processStartedAt != rhs.processStartedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(source)
        hasher.combine(processStartedAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentMetadata {
        return
            try PaymentMetadata(
                source: FfiConverterTypePaymentSource.read(from: &buf), 
                processStartedAt: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentMetadata, into buf: inout [UInt8]) {
        FfiConverterTypePaymentSource.write(value.source, into: &buf)
        FfiConverterTimestamp.write(value.processStartedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMetadata_lift(_ buf: RustBuffer) throws -> PaymentMetadata {
    return try FfiConverterTypePaymentMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMetadata_lower(_ value: PaymentMetadata) -> RustBuffer {
    return FfiConverterTypePaymentMetadata.lower(value)
}


public struct PrepareOnchainPaymentResponse {
    public var feesHash: String
    public var feesPercentage: Double
    public var feesLockup: UInt64
    public var feesClaim: UInt64
    public var senderAmountSat: UInt64
    public var recipientAmountSat: UInt64
    public var totalFees: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(feesHash: String, feesPercentage: Double, feesLockup: UInt64, feesClaim: UInt64, senderAmountSat: UInt64, recipientAmountSat: UInt64, totalFees: UInt64) {
        self.feesHash = feesHash
        self.feesPercentage = feesPercentage
        self.feesLockup = feesLockup
        self.feesClaim = feesClaim
        self.senderAmountSat = senderAmountSat
        self.recipientAmountSat = recipientAmountSat
        self.totalFees = totalFees
    }
}



extension PrepareOnchainPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: PrepareOnchainPaymentResponse, rhs: PrepareOnchainPaymentResponse) -> Bool {
        if lhs.feesHash != rhs.feesHash {
            return false
        }
        if lhs.feesPercentage != rhs.feesPercentage {
            return false
        }
        if lhs.feesLockup != rhs.feesLockup {
            return false
        }
        if lhs.feesClaim != rhs.feesClaim {
            return false
        }
        if lhs.senderAmountSat != rhs.senderAmountSat {
            return false
        }
        if lhs.recipientAmountSat != rhs.recipientAmountSat {
            return false
        }
        if lhs.totalFees != rhs.totalFees {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(feesHash)
        hasher.combine(feesPercentage)
        hasher.combine(feesLockup)
        hasher.combine(feesClaim)
        hasher.combine(senderAmountSat)
        hasher.combine(recipientAmountSat)
        hasher.combine(totalFees)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareOnchainPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareOnchainPaymentResponse {
        return
            try PrepareOnchainPaymentResponse(
                feesHash: FfiConverterString.read(from: &buf), 
                feesPercentage: FfiConverterDouble.read(from: &buf), 
                feesLockup: FfiConverterUInt64.read(from: &buf), 
                feesClaim: FfiConverterUInt64.read(from: &buf), 
                senderAmountSat: FfiConverterUInt64.read(from: &buf), 
                recipientAmountSat: FfiConverterUInt64.read(from: &buf), 
                totalFees: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareOnchainPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.feesHash, into: &buf)
        FfiConverterDouble.write(value.feesPercentage, into: &buf)
        FfiConverterUInt64.write(value.feesLockup, into: &buf)
        FfiConverterUInt64.write(value.feesClaim, into: &buf)
        FfiConverterUInt64.write(value.senderAmountSat, into: &buf)
        FfiConverterUInt64.write(value.recipientAmountSat, into: &buf)
        FfiConverterUInt64.write(value.totalFees, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareOnchainPaymentResponse_lift(_ buf: RustBuffer) throws -> PrepareOnchainPaymentResponse {
    return try FfiConverterTypePrepareOnchainPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareOnchainPaymentResponse_lower(_ value: PrepareOnchainPaymentResponse) -> RustBuffer {
    return FfiConverterTypePrepareOnchainPaymentResponse.lower(value)
}


public struct ReceiveAmountLimits {
    public var maxReceive: Amount
    public var liquidityLimit: LiquidityLimit

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxReceive: Amount, liquidityLimit: LiquidityLimit) {
        self.maxReceive = maxReceive
        self.liquidityLimit = liquidityLimit
    }
}



extension ReceiveAmountLimits: Equatable, Hashable {
    public static func ==(lhs: ReceiveAmountLimits, rhs: ReceiveAmountLimits) -> Bool {
        if lhs.maxReceive != rhs.maxReceive {
            return false
        }
        if lhs.liquidityLimit != rhs.liquidityLimit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxReceive)
        hasher.combine(liquidityLimit)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceiveAmountLimits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiveAmountLimits {
        return
            try ReceiveAmountLimits(
                maxReceive: FfiConverterTypeAmount.read(from: &buf), 
                liquidityLimit: FfiConverterTypeLiquidityLimit.read(from: &buf)
        )
    }

    public static func write(_ value: ReceiveAmountLimits, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.maxReceive, into: &buf)
        FfiConverterTypeLiquidityLimit.write(value.liquidityLimit, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceiveAmountLimits_lift(_ buf: RustBuffer) throws -> ReceiveAmountLimits {
    return try FfiConverterTypeReceiveAmountLimits.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceiveAmountLimits_lower(_ value: ReceiveAmountLimits) -> RustBuffer {
    return FfiConverterTypeReceiveAmountLimits.lower(value)
}


public struct ReceiveLimitsConfig {
    public var maxReceiveAmountSat: UInt64
    public var minReceiveChannelOpenFeeMultiplier: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxReceiveAmountSat: UInt64, minReceiveChannelOpenFeeMultiplier: Double) {
        self.maxReceiveAmountSat = maxReceiveAmountSat
        self.minReceiveChannelOpenFeeMultiplier = minReceiveChannelOpenFeeMultiplier
    }
}



extension ReceiveLimitsConfig: Equatable, Hashable {
    public static func ==(lhs: ReceiveLimitsConfig, rhs: ReceiveLimitsConfig) -> Bool {
        if lhs.maxReceiveAmountSat != rhs.maxReceiveAmountSat {
            return false
        }
        if lhs.minReceiveChannelOpenFeeMultiplier != rhs.minReceiveChannelOpenFeeMultiplier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxReceiveAmountSat)
        hasher.combine(minReceiveChannelOpenFeeMultiplier)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceiveLimitsConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiveLimitsConfig {
        return
            try ReceiveLimitsConfig(
                maxReceiveAmountSat: FfiConverterUInt64.read(from: &buf), 
                minReceiveChannelOpenFeeMultiplier: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: ReceiveLimitsConfig, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.maxReceiveAmountSat, into: &buf)
        FfiConverterDouble.write(value.minReceiveChannelOpenFeeMultiplier, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceiveLimitsConfig_lift(_ buf: RustBuffer) throws -> ReceiveLimitsConfig {
    return try FfiConverterTypeReceiveLimitsConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceiveLimitsConfig_lower(_ value: ReceiveLimitsConfig) -> RustBuffer {
    return FfiConverterTypeReceiveLimitsConfig.lower(value)
}


public struct RemoteServicesConfig {
    public var backendUrl: String
    public var pocketUrl: String
    public var notificationWebhookBaseUrl: String
    public var notificationWebhookSecretHex: String
    public var lipaLightningDomain: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(backendUrl: String, pocketUrl: String, notificationWebhookBaseUrl: String, notificationWebhookSecretHex: String, lipaLightningDomain: String) {
        self.backendUrl = backendUrl
        self.pocketUrl = pocketUrl
        self.notificationWebhookBaseUrl = notificationWebhookBaseUrl
        self.notificationWebhookSecretHex = notificationWebhookSecretHex
        self.lipaLightningDomain = lipaLightningDomain
    }
}



extension RemoteServicesConfig: Equatable, Hashable {
    public static func ==(lhs: RemoteServicesConfig, rhs: RemoteServicesConfig) -> Bool {
        if lhs.backendUrl != rhs.backendUrl {
            return false
        }
        if lhs.pocketUrl != rhs.pocketUrl {
            return false
        }
        if lhs.notificationWebhookBaseUrl != rhs.notificationWebhookBaseUrl {
            return false
        }
        if lhs.notificationWebhookSecretHex != rhs.notificationWebhookSecretHex {
            return false
        }
        if lhs.lipaLightningDomain != rhs.lipaLightningDomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(backendUrl)
        hasher.combine(pocketUrl)
        hasher.combine(notificationWebhookBaseUrl)
        hasher.combine(notificationWebhookSecretHex)
        hasher.combine(lipaLightningDomain)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRemoteServicesConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RemoteServicesConfig {
        return
            try RemoteServicesConfig(
                backendUrl: FfiConverterString.read(from: &buf), 
                pocketUrl: FfiConverterString.read(from: &buf), 
                notificationWebhookBaseUrl: FfiConverterString.read(from: &buf), 
                notificationWebhookSecretHex: FfiConverterString.read(from: &buf), 
                lipaLightningDomain: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RemoteServicesConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.backendUrl, into: &buf)
        FfiConverterString.write(value.pocketUrl, into: &buf)
        FfiConverterString.write(value.notificationWebhookBaseUrl, into: &buf)
        FfiConverterString.write(value.notificationWebhookSecretHex, into: &buf)
        FfiConverterString.write(value.lipaLightningDomain, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRemoteServicesConfig_lift(_ buf: RustBuffer) throws -> RemoteServicesConfig {
    return try FfiConverterTypeRemoteServicesConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRemoteServicesConfig_lower(_ value: RemoteServicesConfig) -> RustBuffer {
    return FfiConverterTypeRemoteServicesConfig.lower(value)
}


public struct ResolveFailedSwapInfo {
    public var swapAddress: String
    public var recoveredAmount: Amount
    public var onchainFee: Amount
    public var toAddress: String
    public var onchainFeeRate: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(swapAddress: String, recoveredAmount: Amount, onchainFee: Amount, toAddress: String, onchainFeeRate: UInt32) {
        self.swapAddress = swapAddress
        self.recoveredAmount = recoveredAmount
        self.onchainFee = onchainFee
        self.toAddress = toAddress
        self.onchainFeeRate = onchainFeeRate
    }
}



extension ResolveFailedSwapInfo: Equatable, Hashable {
    public static func ==(lhs: ResolveFailedSwapInfo, rhs: ResolveFailedSwapInfo) -> Bool {
        if lhs.swapAddress != rhs.swapAddress {
            return false
        }
        if lhs.recoveredAmount != rhs.recoveredAmount {
            return false
        }
        if lhs.onchainFee != rhs.onchainFee {
            return false
        }
        if lhs.toAddress != rhs.toAddress {
            return false
        }
        if lhs.onchainFeeRate != rhs.onchainFeeRate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(swapAddress)
        hasher.combine(recoveredAmount)
        hasher.combine(onchainFee)
        hasher.combine(toAddress)
        hasher.combine(onchainFeeRate)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResolveFailedSwapInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResolveFailedSwapInfo {
        return
            try ResolveFailedSwapInfo(
                swapAddress: FfiConverterString.read(from: &buf), 
                recoveredAmount: FfiConverterTypeAmount.read(from: &buf), 
                onchainFee: FfiConverterTypeAmount.read(from: &buf), 
                toAddress: FfiConverterString.read(from: &buf), 
                onchainFeeRate: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ResolveFailedSwapInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.swapAddress, into: &buf)
        FfiConverterTypeAmount.write(value.recoveredAmount, into: &buf)
        FfiConverterTypeAmount.write(value.onchainFee, into: &buf)
        FfiConverterString.write(value.toAddress, into: &buf)
        FfiConverterUInt32.write(value.onchainFeeRate, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResolveFailedSwapInfo_lift(_ buf: RustBuffer) throws -> ResolveFailedSwapInfo {
    return try FfiConverterTypeResolveFailedSwapInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResolveFailedSwapInfo_lower(_ value: ResolveFailedSwapInfo) -> RustBuffer {
    return FfiConverterTypeResolveFailedSwapInfo.lower(value)
}


public struct ReverseSwapInfo {
    public var paidOnchainAmount: Amount
    public var swapFeesAmount: Amount
    public var claimTxid: String?
    public var status: ReverseSwapStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paidOnchainAmount: Amount, swapFeesAmount: Amount, claimTxid: String?, status: ReverseSwapStatus) {
        self.paidOnchainAmount = paidOnchainAmount
        self.swapFeesAmount = swapFeesAmount
        self.claimTxid = claimTxid
        self.status = status
    }
}



extension ReverseSwapInfo: Equatable, Hashable {
    public static func ==(lhs: ReverseSwapInfo, rhs: ReverseSwapInfo) -> Bool {
        if lhs.paidOnchainAmount != rhs.paidOnchainAmount {
            return false
        }
        if lhs.swapFeesAmount != rhs.swapFeesAmount {
            return false
        }
        if lhs.claimTxid != rhs.claimTxid {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paidOnchainAmount)
        hasher.combine(swapFeesAmount)
        hasher.combine(claimTxid)
        hasher.combine(status)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReverseSwapInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReverseSwapInfo {
        return
            try ReverseSwapInfo(
                paidOnchainAmount: FfiConverterTypeAmount.read(from: &buf), 
                swapFeesAmount: FfiConverterTypeAmount.read(from: &buf), 
                claimTxid: FfiConverterOptionString.read(from: &buf), 
                status: FfiConverterTypeReverseSwapStatus.read(from: &buf)
        )
    }

    public static func write(_ value: ReverseSwapInfo, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.paidOnchainAmount, into: &buf)
        FfiConverterTypeAmount.write(value.swapFeesAmount, into: &buf)
        FfiConverterOptionString.write(value.claimTxid, into: &buf)
        FfiConverterTypeReverseSwapStatus.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReverseSwapInfo_lift(_ buf: RustBuffer) throws -> ReverseSwapInfo {
    return try FfiConverterTypeReverseSwapInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReverseSwapInfo_lower(_ value: ReverseSwapInfo) -> RustBuffer {
    return FfiConverterTypeReverseSwapInfo.lower(value)
}


public struct Secret {
    public var mnemonic: [String]
    public var passphrase: String
    public var seed: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonic: [String], passphrase: String, seed: Data) {
        self.mnemonic = mnemonic
        self.passphrase = passphrase
        self.seed = seed
    }
}



extension Secret: Equatable, Hashable {
    public static func ==(lhs: Secret, rhs: Secret) -> Bool {
        if lhs.mnemonic != rhs.mnemonic {
            return false
        }
        if lhs.passphrase != rhs.passphrase {
            return false
        }
        if lhs.seed != rhs.seed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonic)
        hasher.combine(passphrase)
        hasher.combine(seed)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecret: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secret {
        return
            try Secret(
                mnemonic: FfiConverterSequenceString.read(from: &buf), 
                passphrase: FfiConverterString.read(from: &buf), 
                seed: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Secret, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.mnemonic, into: &buf)
        FfiConverterString.write(value.passphrase, into: &buf)
        FfiConverterData.write(value.seed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecret_lift(_ buf: RustBuffer) throws -> Secret {
    return try FfiConverterTypeSecret.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecret_lower(_ value: Secret) -> RustBuffer {
    return FfiConverterTypeSecret.lower(value)
}


public struct SwapAddressInfo {
    public var address: String
    public var minDeposit: Amount
    public var maxDeposit: Amount
    public var swapFee: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, minDeposit: Amount, maxDeposit: Amount, swapFee: Amount) {
        self.address = address
        self.minDeposit = minDeposit
        self.maxDeposit = maxDeposit
        self.swapFee = swapFee
    }
}



extension SwapAddressInfo: Equatable, Hashable {
    public static func ==(lhs: SwapAddressInfo, rhs: SwapAddressInfo) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.minDeposit != rhs.minDeposit {
            return false
        }
        if lhs.maxDeposit != rhs.maxDeposit {
            return false
        }
        if lhs.swapFee != rhs.swapFee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(minDeposit)
        hasher.combine(maxDeposit)
        hasher.combine(swapFee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSwapAddressInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwapAddressInfo {
        return
            try SwapAddressInfo(
                address: FfiConverterString.read(from: &buf), 
                minDeposit: FfiConverterTypeAmount.read(from: &buf), 
                maxDeposit: FfiConverterTypeAmount.read(from: &buf), 
                swapFee: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: SwapAddressInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeAmount.write(value.minDeposit, into: &buf)
        FfiConverterTypeAmount.write(value.maxDeposit, into: &buf)
        FfiConverterTypeAmount.write(value.swapFee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSwapAddressInfo_lift(_ buf: RustBuffer) throws -> SwapAddressInfo {
    return try FfiConverterTypeSwapAddressInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSwapAddressInfo_lower(_ value: SwapAddressInfo) -> RustBuffer {
    return FfiConverterTypeSwapAddressInfo.lower(value)
}


public struct SwapInfo {
    public var bitcoinAddress: String
    public var createdAt: TzTime
    public var paidAmount: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bitcoinAddress: String, createdAt: TzTime, paidAmount: Amount) {
        self.bitcoinAddress = bitcoinAddress
        self.createdAt = createdAt
        self.paidAmount = paidAmount
    }
}



extension SwapInfo: Equatable, Hashable {
    public static func ==(lhs: SwapInfo, rhs: SwapInfo) -> Bool {
        if lhs.bitcoinAddress != rhs.bitcoinAddress {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.paidAmount != rhs.paidAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bitcoinAddress)
        hasher.combine(createdAt)
        hasher.combine(paidAmount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSwapInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwapInfo {
        return
            try SwapInfo(
                bitcoinAddress: FfiConverterString.read(from: &buf), 
                createdAt: FfiConverterTypeTzTime.read(from: &buf), 
                paidAmount: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: SwapInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.bitcoinAddress, into: &buf)
        FfiConverterTypeTzTime.write(value.createdAt, into: &buf)
        FfiConverterTypeAmount.write(value.paidAmount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSwapInfo_lift(_ buf: RustBuffer) throws -> SwapInfo {
    return try FfiConverterTypeSwapInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSwapInfo_lower(_ value: SwapInfo) -> RustBuffer {
    return FfiConverterTypeSwapInfo.lower(value)
}


public struct SwapToLightningFees {
    public var swapFee: Amount
    public var onchainFee: Amount
    public var channelOpeningFee: Amount
    public var totalFees: Amount
    public var lspFeeParams: OpeningFeeParams?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(swapFee: Amount, onchainFee: Amount, channelOpeningFee: Amount, totalFees: Amount, lspFeeParams: OpeningFeeParams?) {
        self.swapFee = swapFee
        self.onchainFee = onchainFee
        self.channelOpeningFee = channelOpeningFee
        self.totalFees = totalFees
        self.lspFeeParams = lspFeeParams
    }
}



extension SwapToLightningFees: Equatable, Hashable {
    public static func ==(lhs: SwapToLightningFees, rhs: SwapToLightningFees) -> Bool {
        if lhs.swapFee != rhs.swapFee {
            return false
        }
        if lhs.onchainFee != rhs.onchainFee {
            return false
        }
        if lhs.channelOpeningFee != rhs.channelOpeningFee {
            return false
        }
        if lhs.totalFees != rhs.totalFees {
            return false
        }
        if lhs.lspFeeParams != rhs.lspFeeParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(swapFee)
        hasher.combine(onchainFee)
        hasher.combine(channelOpeningFee)
        hasher.combine(totalFees)
        hasher.combine(lspFeeParams)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSwapToLightningFees: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwapToLightningFees {
        return
            try SwapToLightningFees(
                swapFee: FfiConverterTypeAmount.read(from: &buf), 
                onchainFee: FfiConverterTypeAmount.read(from: &buf), 
                channelOpeningFee: FfiConverterTypeAmount.read(from: &buf), 
                totalFees: FfiConverterTypeAmount.read(from: &buf), 
                lspFeeParams: FfiConverterOptionTypeOpeningFeeParams.read(from: &buf)
        )
    }

    public static func write(_ value: SwapToLightningFees, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.swapFee, into: &buf)
        FfiConverterTypeAmount.write(value.onchainFee, into: &buf)
        FfiConverterTypeAmount.write(value.channelOpeningFee, into: &buf)
        FfiConverterTypeAmount.write(value.totalFees, into: &buf)
        FfiConverterOptionTypeOpeningFeeParams.write(value.lspFeeParams, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSwapToLightningFees_lift(_ buf: RustBuffer) throws -> SwapToLightningFees {
    return try FfiConverterTypeSwapToLightningFees.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSwapToLightningFees_lower(_ value: SwapToLightningFees) -> RustBuffer {
    return FfiConverterTypeSwapToLightningFees.lower(value)
}


public struct SweepChannelCloseInfo {
    public var address: String
    public var onchainFeeRate: UInt32
    public var onchainFeeAmount: Amount
    public var amount: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, onchainFeeRate: UInt32, onchainFeeAmount: Amount, amount: Amount) {
        self.address = address
        self.onchainFeeRate = onchainFeeRate
        self.onchainFeeAmount = onchainFeeAmount
        self.amount = amount
    }
}



extension SweepChannelCloseInfo: Equatable, Hashable {
    public static func ==(lhs: SweepChannelCloseInfo, rhs: SweepChannelCloseInfo) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.onchainFeeRate != rhs.onchainFeeRate {
            return false
        }
        if lhs.onchainFeeAmount != rhs.onchainFeeAmount {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(onchainFeeRate)
        hasher.combine(onchainFeeAmount)
        hasher.combine(amount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSweepChannelCloseInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SweepChannelCloseInfo {
        return
            try SweepChannelCloseInfo(
                address: FfiConverterString.read(from: &buf), 
                onchainFeeRate: FfiConverterUInt32.read(from: &buf), 
                onchainFeeAmount: FfiConverterTypeAmount.read(from: &buf), 
                amount: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: SweepChannelCloseInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterUInt32.write(value.onchainFeeRate, into: &buf)
        FfiConverterTypeAmount.write(value.onchainFeeAmount, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSweepChannelCloseInfo_lift(_ buf: RustBuffer) throws -> SweepChannelCloseInfo {
    return try FfiConverterTypeSweepChannelCloseInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSweepChannelCloseInfo_lower(_ value: SweepChannelCloseInfo) -> RustBuffer {
    return FfiConverterTypeSweepChannelCloseInfo.lower(value)
}


public struct SweepFailedSwapInfo {
    public var swapAddress: String
    public var recoveredAmount: Amount
    public var onchainFee: Amount
    public var toAddress: String
    public var onchainFeeRate: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(swapAddress: String, recoveredAmount: Amount, onchainFee: Amount, toAddress: String, onchainFeeRate: UInt32) {
        self.swapAddress = swapAddress
        self.recoveredAmount = recoveredAmount
        self.onchainFee = onchainFee
        self.toAddress = toAddress
        self.onchainFeeRate = onchainFeeRate
    }
}



extension SweepFailedSwapInfo: Equatable, Hashable {
    public static func ==(lhs: SweepFailedSwapInfo, rhs: SweepFailedSwapInfo) -> Bool {
        if lhs.swapAddress != rhs.swapAddress {
            return false
        }
        if lhs.recoveredAmount != rhs.recoveredAmount {
            return false
        }
        if lhs.onchainFee != rhs.onchainFee {
            return false
        }
        if lhs.toAddress != rhs.toAddress {
            return false
        }
        if lhs.onchainFeeRate != rhs.onchainFeeRate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(swapAddress)
        hasher.combine(recoveredAmount)
        hasher.combine(onchainFee)
        hasher.combine(toAddress)
        hasher.combine(onchainFeeRate)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSweepFailedSwapInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SweepFailedSwapInfo {
        return
            try SweepFailedSwapInfo(
                swapAddress: FfiConverterString.read(from: &buf), 
                recoveredAmount: FfiConverterTypeAmount.read(from: &buf), 
                onchainFee: FfiConverterTypeAmount.read(from: &buf), 
                toAddress: FfiConverterString.read(from: &buf), 
                onchainFeeRate: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: SweepFailedSwapInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.swapAddress, into: &buf)
        FfiConverterTypeAmount.write(value.recoveredAmount, into: &buf)
        FfiConverterTypeAmount.write(value.onchainFee, into: &buf)
        FfiConverterString.write(value.toAddress, into: &buf)
        FfiConverterUInt32.write(value.onchainFeeRate, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSweepFailedSwapInfo_lift(_ buf: RustBuffer) throws -> SweepFailedSwapInfo {
    return try FfiConverterTypeSweepFailedSwapInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSweepFailedSwapInfo_lower(_ value: SweepFailedSwapInfo) -> RustBuffer {
    return FfiConverterTypeSweepFailedSwapInfo.lower(value)
}


public struct SweepInfo {
    public var address: String
    public var onchainFeeRate: UInt32
    public var onchainFeeAmount: Amount
    public var amount: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, onchainFeeRate: UInt32, onchainFeeAmount: Amount, amount: Amount) {
        self.address = address
        self.onchainFeeRate = onchainFeeRate
        self.onchainFeeAmount = onchainFeeAmount
        self.amount = amount
    }
}



extension SweepInfo: Equatable, Hashable {
    public static func ==(lhs: SweepInfo, rhs: SweepInfo) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.onchainFeeRate != rhs.onchainFeeRate {
            return false
        }
        if lhs.onchainFeeAmount != rhs.onchainFeeAmount {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(onchainFeeRate)
        hasher.combine(onchainFeeAmount)
        hasher.combine(amount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSweepInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SweepInfo {
        return
            try SweepInfo(
                address: FfiConverterString.read(from: &buf), 
                onchainFeeRate: FfiConverterUInt32.read(from: &buf), 
                onchainFeeAmount: FfiConverterTypeAmount.read(from: &buf), 
                amount: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: SweepInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterUInt32.write(value.onchainFeeRate, into: &buf)
        FfiConverterTypeAmount.write(value.onchainFeeAmount, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSweepInfo_lift(_ buf: RustBuffer) throws -> SweepInfo {
    return try FfiConverterTypeSweepInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSweepInfo_lower(_ value: SweepInfo) -> RustBuffer {
    return FfiConverterTypeSweepInfo.lower(value)
}


public struct TermsAndConditionsStatus {
    public var acceptedAt: Date?
    public var termsAndConditions: TermsAndConditions
    public var version: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(acceptedAt: Date?, termsAndConditions: TermsAndConditions, version: Int64) {
        self.acceptedAt = acceptedAt
        self.termsAndConditions = termsAndConditions
        self.version = version
    }
}



extension TermsAndConditionsStatus: Equatable, Hashable {
    public static func ==(lhs: TermsAndConditionsStatus, rhs: TermsAndConditionsStatus) -> Bool {
        if lhs.acceptedAt != rhs.acceptedAt {
            return false
        }
        if lhs.termsAndConditions != rhs.termsAndConditions {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(acceptedAt)
        hasher.combine(termsAndConditions)
        hasher.combine(version)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTermsAndConditionsStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TermsAndConditionsStatus {
        return
            try TermsAndConditionsStatus(
                acceptedAt: FfiConverterOptionTimestamp.read(from: &buf), 
                termsAndConditions: FfiConverterTypeTermsAndConditions.read(from: &buf), 
                version: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TermsAndConditionsStatus, into buf: inout [UInt8]) {
        FfiConverterOptionTimestamp.write(value.acceptedAt, into: &buf)
        FfiConverterTypeTermsAndConditions.write(value.termsAndConditions, into: &buf)
        FfiConverterInt64.write(value.version, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTermsAndConditionsStatus_lift(_ buf: RustBuffer) throws -> TermsAndConditionsStatus {
    return try FfiConverterTypeTermsAndConditionsStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTermsAndConditionsStatus_lower(_ value: TermsAndConditionsStatus) -> RustBuffer {
    return FfiConverterTypeTermsAndConditionsStatus.lower(value)
}


public struct TzConfig {
    public var timezoneId: String
    public var timezoneUtcOffsetSecs: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(timezoneId: String, timezoneUtcOffsetSecs: Int32) {
        self.timezoneId = timezoneId
        self.timezoneUtcOffsetSecs = timezoneUtcOffsetSecs
    }
}



extension TzConfig: Equatable, Hashable {
    public static func ==(lhs: TzConfig, rhs: TzConfig) -> Bool {
        if lhs.timezoneId != rhs.timezoneId {
            return false
        }
        if lhs.timezoneUtcOffsetSecs != rhs.timezoneUtcOffsetSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(timezoneId)
        hasher.combine(timezoneUtcOffsetSecs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTzConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TzConfig {
        return
            try TzConfig(
                timezoneId: FfiConverterString.read(from: &buf), 
                timezoneUtcOffsetSecs: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: TzConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.timezoneId, into: &buf)
        FfiConverterInt32.write(value.timezoneUtcOffsetSecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTzConfig_lift(_ buf: RustBuffer) throws -> TzConfig {
    return try FfiConverterTypeTzConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTzConfig_lower(_ value: TzConfig) -> RustBuffer {
    return FfiConverterTypeTzConfig.lower(value)
}


public struct TzTime {
    public var time: Date
    public var timezoneId: String
    public var timezoneUtcOffsetSecs: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(time: Date, timezoneId: String, timezoneUtcOffsetSecs: Int32) {
        self.time = time
        self.timezoneId = timezoneId
        self.timezoneUtcOffsetSecs = timezoneUtcOffsetSecs
    }
}



extension TzTime: Equatable, Hashable {
    public static func ==(lhs: TzTime, rhs: TzTime) -> Bool {
        if lhs.time != rhs.time {
            return false
        }
        if lhs.timezoneId != rhs.timezoneId {
            return false
        }
        if lhs.timezoneUtcOffsetSecs != rhs.timezoneUtcOffsetSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(time)
        hasher.combine(timezoneId)
        hasher.combine(timezoneUtcOffsetSecs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTzTime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TzTime {
        return
            try TzTime(
                time: FfiConverterTimestamp.read(from: &buf), 
                timezoneId: FfiConverterString.read(from: &buf), 
                timezoneUtcOffsetSecs: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: TzTime, into buf: inout [UInt8]) {
        FfiConverterTimestamp.write(value.time, into: &buf)
        FfiConverterString.write(value.timezoneId, into: &buf)
        FfiConverterInt32.write(value.timezoneUtcOffsetSecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTzTime_lift(_ buf: RustBuffer) throws -> TzTime {
    return try FfiConverterTypeTzTime.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTzTime_lower(_ value: TzTime) -> RustBuffer {
    return FfiConverterTypeTzTime.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ActionRequiredItem {
    
    case uncompletedOffer(offer: OfferInfo
    )
    case unresolvedFailedSwap(failedSwap: FailedSwapInfo
    )
    case channelClosesFundsAvailable(availableFunds: Amount
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeActionRequiredItem: FfiConverterRustBuffer {
    typealias SwiftType = ActionRequiredItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ActionRequiredItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .uncompletedOffer(offer: try FfiConverterTypeOfferInfo.read(from: &buf)
        )
        
        case 2: return .unresolvedFailedSwap(failedSwap: try FfiConverterTypeFailedSwapInfo.read(from: &buf)
        )
        
        case 3: return .channelClosesFundsAvailable(availableFunds: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ActionRequiredItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .uncompletedOffer(offer):
            writeInt(&buf, Int32(1))
            FfiConverterTypeOfferInfo.write(offer, into: &buf)
            
        
        case let .unresolvedFailedSwap(failedSwap):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFailedSwapInfo.write(failedSwap, into: &buf)
            
        
        case let .channelClosesFundsAvailable(availableFunds):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAmount.write(availableFunds, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActionRequiredItem_lift(_ buf: RustBuffer) throws -> ActionRequiredItem {
    return try FfiConverterTypeActionRequiredItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActionRequiredItem_lower(_ value: ActionRequiredItem) -> RustBuffer {
    return FfiConverterTypeActionRequiredItem.lower(value)
}



extension ActionRequiredItem: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Activity {
    
    case incomingPayment(incomingPaymentInfo: IncomingPaymentInfo
    )
    case outgoingPayment(outgoingPaymentInfo: OutgoingPaymentInfo
    )
    case offerClaim(incomingPaymentInfo: IncomingPaymentInfo, offerKind: OfferKind
    )
    case swap(incomingPaymentInfo: IncomingPaymentInfo?, swapInfo: SwapInfo
    )
    case reverseSwap(outgoingPaymentInfo: OutgoingPaymentInfo, reverseSwapInfo: ReverseSwapInfo
    )
    case channelClose(channelCloseInfo: ChannelCloseInfo
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeActivity: FfiConverterRustBuffer {
    typealias SwiftType = Activity

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Activity {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .incomingPayment(incomingPaymentInfo: try FfiConverterTypeIncomingPaymentInfo.read(from: &buf)
        )
        
        case 2: return .outgoingPayment(outgoingPaymentInfo: try FfiConverterTypeOutgoingPaymentInfo.read(from: &buf)
        )
        
        case 3: return .offerClaim(incomingPaymentInfo: try FfiConverterTypeIncomingPaymentInfo.read(from: &buf), offerKind: try FfiConverterTypeOfferKind.read(from: &buf)
        )
        
        case 4: return .swap(incomingPaymentInfo: try FfiConverterOptionTypeIncomingPaymentInfo.read(from: &buf), swapInfo: try FfiConverterTypeSwapInfo.read(from: &buf)
        )
        
        case 5: return .reverseSwap(outgoingPaymentInfo: try FfiConverterTypeOutgoingPaymentInfo.read(from: &buf), reverseSwapInfo: try FfiConverterTypeReverseSwapInfo.read(from: &buf)
        )
        
        case 6: return .channelClose(channelCloseInfo: try FfiConverterTypeChannelCloseInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Activity, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .incomingPayment(incomingPaymentInfo):
            writeInt(&buf, Int32(1))
            FfiConverterTypeIncomingPaymentInfo.write(incomingPaymentInfo, into: &buf)
            
        
        case let .outgoingPayment(outgoingPaymentInfo):
            writeInt(&buf, Int32(2))
            FfiConverterTypeOutgoingPaymentInfo.write(outgoingPaymentInfo, into: &buf)
            
        
        case let .offerClaim(incomingPaymentInfo,offerKind):
            writeInt(&buf, Int32(3))
            FfiConverterTypeIncomingPaymentInfo.write(incomingPaymentInfo, into: &buf)
            FfiConverterTypeOfferKind.write(offerKind, into: &buf)
            
        
        case let .swap(incomingPaymentInfo,swapInfo):
            writeInt(&buf, Int32(4))
            FfiConverterOptionTypeIncomingPaymentInfo.write(incomingPaymentInfo, into: &buf)
            FfiConverterTypeSwapInfo.write(swapInfo, into: &buf)
            
        
        case let .reverseSwap(outgoingPaymentInfo,reverseSwapInfo):
            writeInt(&buf, Int32(5))
            FfiConverterTypeOutgoingPaymentInfo.write(outgoingPaymentInfo, into: &buf)
            FfiConverterTypeReverseSwapInfo.write(reverseSwapInfo, into: &buf)
            
        
        case let .channelClose(channelCloseInfo):
            writeInt(&buf, Int32(6))
            FfiConverterTypeChannelCloseInfo.write(channelCloseInfo, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActivity_lift(_ buf: RustBuffer) throws -> Activity {
    return try FfiConverterTypeActivity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeActivity_lower(_ value: Activity) -> RustBuffer {
    return FfiConverterTypeActivity.lower(value)
}



extension Activity: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AnalyticsConfig {
    
    case enabled
    case disabled
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnalyticsConfig: FfiConverterRustBuffer {
    typealias SwiftType = AnalyticsConfig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnalyticsConfig {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .enabled
        
        case 2: return .disabled
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AnalyticsConfig, into buf: inout [UInt8]) {
        switch value {
        
        
        case .enabled:
            writeInt(&buf, Int32(1))
        
        
        case .disabled:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnalyticsConfig_lift(_ buf: RustBuffer) throws -> AnalyticsConfig {
    return try FfiConverterTypeAnalyticsConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAnalyticsConfig_lower(_ value: AnalyticsConfig) -> RustBuffer {
    return FfiConverterTypeAnalyticsConfig.lower(value)
}



extension AnalyticsConfig: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BreezHealthCheckStatus {
    
    case operational
    case maintenance
    case serviceDisruption
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBreezHealthCheckStatus: FfiConverterRustBuffer {
    typealias SwiftType = BreezHealthCheckStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BreezHealthCheckStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .operational
        
        case 2: return .maintenance
        
        case 3: return .serviceDisruption
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BreezHealthCheckStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .operational:
            writeInt(&buf, Int32(1))
        
        
        case .maintenance:
            writeInt(&buf, Int32(2))
        
        
        case .serviceDisruption:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBreezHealthCheckStatus_lift(_ buf: RustBuffer) throws -> BreezHealthCheckStatus {
    return try FfiConverterTypeBreezHealthCheckStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBreezHealthCheckStatus_lower(_ value: BreezHealthCheckStatus) -> RustBuffer {
    return FfiConverterTypeBreezHealthCheckStatus.lower(value)
}



extension BreezHealthCheckStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ChannelCloseState {
    
    case pending
    case confirmed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChannelCloseState: FfiConverterRustBuffer {
    typealias SwiftType = ChannelCloseState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelCloseState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending
        
        case 2: return .confirmed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChannelCloseState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pending:
            writeInt(&buf, Int32(1))
        
        
        case .confirmed:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelCloseState_lift(_ buf: RustBuffer) throws -> ChannelCloseState {
    return try FfiConverterTypeChannelCloseState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelCloseState_lower(_ value: ChannelCloseState) -> RustBuffer {
    return FfiConverterTypeChannelCloseState.lower(value)
}



extension ChannelCloseState: Equatable, Hashable {}




public enum DecodeDataError {

    
    
    case LnUrlError(msg: String
    )
    case Unsupported(typ: UnsupportedDataType
    )
    case Unrecognized(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDecodeDataError: FfiConverterRustBuffer {
    typealias SwiftType = DecodeDataError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecodeDataError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .LnUrlError(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Unsupported(
            typ: try FfiConverterTypeUnsupportedDataType.read(from: &buf)
            )
        case 3: return .Unrecognized(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecodeDataError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .LnUrlError(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .Unsupported(typ):
            writeInt(&buf, Int32(2))
            FfiConverterTypeUnsupportedDataType.write(typ, into: &buf)
            
        
        case let .Unrecognized(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension DecodeDataError: Equatable, Hashable {}

extension DecodeDataError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DecodedData {
    
    case bolt11Invoice(invoiceDetails: InvoiceDetails
    )
    case lnUrlPay(lnurlPayDetails: LnUrlPayDetails
    )
    case lnUrlWithdraw(lnurlWithdrawDetails: LnUrlWithdrawDetails
    )
    case onchainAddress(onchainAddressDetails: BitcoinAddressData
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDecodedData: FfiConverterRustBuffer {
    typealias SwiftType = DecodedData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecodedData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bolt11Invoice(invoiceDetails: try FfiConverterTypeInvoiceDetails.read(from: &buf)
        )
        
        case 2: return .lnUrlPay(lnurlPayDetails: try FfiConverterTypeLnUrlPayDetails.read(from: &buf)
        )
        
        case 3: return .lnUrlWithdraw(lnurlWithdrawDetails: try FfiConverterTypeLnUrlWithdrawDetails.read(from: &buf)
        )
        
        case 4: return .onchainAddress(onchainAddressDetails: try FfiConverterTypeBitcoinAddressData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecodedData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bolt11Invoice(invoiceDetails):
            writeInt(&buf, Int32(1))
            FfiConverterTypeInvoiceDetails.write(invoiceDetails, into: &buf)
            
        
        case let .lnUrlPay(lnurlPayDetails):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnUrlPayDetails.write(lnurlPayDetails, into: &buf)
            
        
        case let .lnUrlWithdraw(lnurlWithdrawDetails):
            writeInt(&buf, Int32(3))
            FfiConverterTypeLnUrlWithdrawDetails.write(lnurlWithdrawDetails, into: &buf)
            
        
        case let .onchainAddress(onchainAddressDetails):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBitcoinAddressData.write(onchainAddressDetails, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDecodedData_lift(_ buf: RustBuffer) throws -> DecodedData {
    return try FfiConverterTypeDecodedData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDecodedData_lower(_ value: DecodedData) -> RustBuffer {
    return FfiConverterTypeDecodedData.lower(value)
}



extension DecodedData: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FeatureFlag {
    
    case lightningAddress
    case phoneNumber
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeatureFlag: FfiConverterRustBuffer {
    typealias SwiftType = FeatureFlag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeatureFlag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .lightningAddress
        
        case 2: return .phoneNumber
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FeatureFlag, into buf: inout [UInt8]) {
        switch value {
        
        
        case .lightningAddress:
            writeInt(&buf, Int32(1))
        
        
        case .phoneNumber:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeatureFlag_lift(_ buf: RustBuffer) throws -> FeatureFlag {
    return try FfiConverterTypeFeatureFlag.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeatureFlag_lower(_ value: FeatureFlag) -> RustBuffer {
    return FfiConverterTypeFeatureFlag.lower(value)
}



extension FeatureFlag: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum InvoiceAffordability {
    
    case notEnoughFunds
    case unaffordableFees
    case affordable
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInvoiceAffordability: FfiConverterRustBuffer {
    typealias SwiftType = InvoiceAffordability

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvoiceAffordability {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notEnoughFunds
        
        case 2: return .unaffordableFees
        
        case 3: return .affordable
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InvoiceAffordability, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notEnoughFunds:
            writeInt(&buf, Int32(1))
        
        
        case .unaffordableFees:
            writeInt(&buf, Int32(2))
        
        
        case .affordable:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvoiceAffordability_lift(_ buf: RustBuffer) throws -> InvoiceAffordability {
    return try FfiConverterTypeInvoiceAffordability.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvoiceAffordability_lower(_ value: InvoiceAffordability) -> RustBuffer {
    return FfiConverterTypeInvoiceAffordability.lower(value)
}



extension InvoiceAffordability: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Level {
    
    case error
    case warn
    case info
    case debug
    case trace
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLevel: FfiConverterRustBuffer {
    typealias SwiftType = Level

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Level {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warn
        
        case 3: return .info
        
        case 4: return .debug
        
        case 5: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Level, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warn:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .debug:
            writeInt(&buf, Int32(4))
        
        
        case .trace:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLevel_lift(_ buf: RustBuffer) throws -> Level {
    return try FfiConverterTypeLevel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLevel_lower(_ value: Level) -> RustBuffer {
    return FfiConverterTypeLevel.lower(value)
}



extension Level: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LiquidityLimit {
    
    case none
    case maxFreeReceive(amount: Amount
    )
    case minReceive(amount: Amount
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiquidityLimit: FfiConverterRustBuffer {
    typealias SwiftType = LiquidityLimit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiquidityLimit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .maxFreeReceive(amount: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        case 3: return .minReceive(amount: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LiquidityLimit, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case let .maxFreeReceive(amount):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAmount.write(amount, into: &buf)
            
        
        case let .minReceive(amount):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAmount.write(amount, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLiquidityLimit_lift(_ buf: RustBuffer) throws -> LiquidityLimit {
    return try FfiConverterTypeLiquidityLimit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLiquidityLimit_lower(_ value: LiquidityLimit) -> RustBuffer {
    return FfiConverterTypeLiquidityLimit.lower(value)
}



extension LiquidityLimit: Equatable, Hashable {}




public enum LnError {

    
    
    case InvalidInput(msg: String
    )
    case RuntimeError(code: RuntimeErrorCode, msg: String
    )
    case PermanentFailure(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnError: FfiConverterRustBuffer {
    typealias SwiftType = LnError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidInput(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .RuntimeError(
            code: try FfiConverterTypeRuntimeErrorCode.read(from: &buf), 
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .PermanentFailure(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidInput(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .RuntimeError(code,msg):
            writeInt(&buf, Int32(2))
            FfiConverterTypeRuntimeErrorCode.write(code, into: &buf)
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .PermanentFailure(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension LnError: Equatable, Hashable {}

extension LnError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum LnUrlPayError {

    
    
    case InvalidInput(msg: String
    )
    case RuntimeError(code: LnUrlPayErrorCode, msg: String
    )
    case PermanentFailure(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnUrlPayError: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlPayError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidInput(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .RuntimeError(
            code: try FfiConverterTypeLnUrlPayErrorCode.read(from: &buf), 
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .PermanentFailure(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlPayError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidInput(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .RuntimeError(code,msg):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnUrlPayErrorCode.write(code, into: &buf)
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .PermanentFailure(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension LnUrlPayError: Equatable, Hashable {}

extension LnUrlPayError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LnUrlPayErrorCode {
    
    case lnUrlServerError
    case noRouteFound
    case paymentFailed
    case paymentTimeout
    case routeTooExpensive
    case unexpectedError
    case serviceConnectivity
    case invalidNetwork
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnUrlPayErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlPayErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .lnUrlServerError
        
        case 2: return .noRouteFound
        
        case 3: return .paymentFailed
        
        case 4: return .paymentTimeout
        
        case 5: return .routeTooExpensive
        
        case 6: return .unexpectedError
        
        case 7: return .serviceConnectivity
        
        case 8: return .invalidNetwork
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlPayErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .lnUrlServerError:
            writeInt(&buf, Int32(1))
        
        
        case .noRouteFound:
            writeInt(&buf, Int32(2))
        
        
        case .paymentFailed:
            writeInt(&buf, Int32(3))
        
        
        case .paymentTimeout:
            writeInt(&buf, Int32(4))
        
        
        case .routeTooExpensive:
            writeInt(&buf, Int32(5))
        
        
        case .unexpectedError:
            writeInt(&buf, Int32(6))
        
        
        case .serviceConnectivity:
            writeInt(&buf, Int32(7))
        
        
        case .invalidNetwork:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnUrlPayErrorCode_lift(_ buf: RustBuffer) throws -> LnUrlPayErrorCode {
    return try FfiConverterTypeLnUrlPayErrorCode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnUrlPayErrorCode_lower(_ value: LnUrlPayErrorCode) -> RustBuffer {
    return FfiConverterTypeLnUrlPayErrorCode.lower(value)
}



extension LnUrlPayErrorCode: Equatable, Hashable {}




public enum LnUrlWithdrawError {

    
    
    case InvalidInput(msg: String
    )
    case RuntimeError(code: LnUrlWithdrawErrorCode, msg: String
    )
    case PermanentFailure(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnUrlWithdrawError: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlWithdrawError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlWithdrawError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidInput(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .RuntimeError(
            code: try FfiConverterTypeLnUrlWithdrawErrorCode.read(from: &buf), 
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .PermanentFailure(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlWithdrawError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidInput(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .RuntimeError(code,msg):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnUrlWithdrawErrorCode.write(code, into: &buf)
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .PermanentFailure(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension LnUrlWithdrawError: Equatable, Hashable {}

extension LnUrlWithdrawError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LnUrlWithdrawErrorCode {
    
    case lnUrlServerError
    case serviceConnectivity
    case unexpectedError
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnUrlWithdrawErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlWithdrawErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlWithdrawErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .lnUrlServerError
        
        case 2: return .serviceConnectivity
        
        case 3: return .unexpectedError
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlWithdrawErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .lnUrlServerError:
            writeInt(&buf, Int32(1))
        
        
        case .serviceConnectivity:
            writeInt(&buf, Int32(2))
        
        
        case .unexpectedError:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnUrlWithdrawErrorCode_lift(_ buf: RustBuffer) throws -> LnUrlWithdrawErrorCode {
    return try FfiConverterTypeLnUrlWithdrawErrorCode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnUrlWithdrawErrorCode_lower(_ value: LnUrlWithdrawErrorCode) -> RustBuffer {
    return FfiConverterTypeLnUrlWithdrawErrorCode.lower(value)
}



extension LnUrlWithdrawErrorCode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MaxRoutingFeeMode {
    
    case relative(maxFeePermyriad: UInt16
    )
    case absolute(maxFeeAmount: Amount
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMaxRoutingFeeMode: FfiConverterRustBuffer {
    typealias SwiftType = MaxRoutingFeeMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MaxRoutingFeeMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .relative(maxFeePermyriad: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 2: return .absolute(maxFeeAmount: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MaxRoutingFeeMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .relative(maxFeePermyriad):
            writeInt(&buf, Int32(1))
            FfiConverterUInt16.write(maxFeePermyriad, into: &buf)
            
        
        case let .absolute(maxFeeAmount):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAmount.write(maxFeeAmount, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMaxRoutingFeeMode_lift(_ buf: RustBuffer) throws -> MaxRoutingFeeMode {
    return try FfiConverterTypeMaxRoutingFeeMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMaxRoutingFeeMode_lower(_ value: MaxRoutingFeeMode) -> RustBuffer {
    return FfiConverterTypeMaxRoutingFeeMode.lower(value)
}



extension MaxRoutingFeeMode: Equatable, Hashable {}




public enum MnemonicError {

    
    
    case BadWordCount(count: UInt64
    )
    case UnknownWord(index: UInt64
    )
    case BadEntropyBitCount
    case InvalidChecksum
    case AmbiguousLanguages
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonicError: FfiConverterRustBuffer {
    typealias SwiftType = MnemonicError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BadWordCount(
            count: try FfiConverterUInt64.read(from: &buf)
            )
        case 2: return .UnknownWord(
            index: try FfiConverterUInt64.read(from: &buf)
            )
        case 3: return .BadEntropyBitCount
        case 4: return .InvalidChecksum
        case 5: return .AmbiguousLanguages

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MnemonicError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .BadWordCount(count):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(count, into: &buf)
            
        
        case let .UnknownWord(index):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(index, into: &buf)
            
        
        case .BadEntropyBitCount:
            writeInt(&buf, Int32(3))
        
        
        case .InvalidChecksum:
            writeInt(&buf, Int32(4))
        
        
        case .AmbiguousLanguages:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension MnemonicError: Equatable, Hashable {}

extension MnemonicError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network {
    
    case bitcoin
    case testnet
    case signet
    case regtest
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet
        
        case 3: return .signet
        
        case 4: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .signet:
            writeInt(&buf, Int32(3))
        
        
        case .regtest:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}



extension Network: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Notification {
    
    case bolt11PaymentReceived(amountSat: UInt64, paymentHash: String
    )
    case onchainPaymentSwappedIn(amountSat: UInt64, paymentHash: String
    )
    case lnurlInvoiceCreated(amountSat: UInt64
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotification: FfiConverterRustBuffer {
    typealias SwiftType = Notification

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Notification {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bolt11PaymentReceived(amountSat: try FfiConverterUInt64.read(from: &buf), paymentHash: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .onchainPaymentSwappedIn(amountSat: try FfiConverterUInt64.read(from: &buf), paymentHash: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .lnurlInvoiceCreated(amountSat: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Notification, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bolt11PaymentReceived(amountSat,paymentHash):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(amountSat, into: &buf)
            FfiConverterString.write(paymentHash, into: &buf)
            
        
        case let .onchainPaymentSwappedIn(amountSat,paymentHash):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(amountSat, into: &buf)
            FfiConverterString.write(paymentHash, into: &buf)
            
        
        case let .lnurlInvoiceCreated(amountSat):
            writeInt(&buf, Int32(3))
            FfiConverterUInt64.write(amountSat, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotification_lift(_ buf: RustBuffer) throws -> Notification {
    return try FfiConverterTypeNotification.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotification_lower(_ value: Notification) -> RustBuffer {
    return FfiConverterTypeNotification.lower(value)
}



extension Notification: Equatable, Hashable {}




public enum NotificationHandlingError {

    
    
    case InvalidInput(msg: String
    )
    case RuntimeError(code: NotificationHandlingErrorCode, msg: String
    )
    case PermanentFailure(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationHandlingError: FfiConverterRustBuffer {
    typealias SwiftType = NotificationHandlingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationHandlingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidInput(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .RuntimeError(
            code: try FfiConverterTypeNotificationHandlingErrorCode.read(from: &buf), 
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .PermanentFailure(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationHandlingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidInput(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .RuntimeError(code,msg):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNotificationHandlingErrorCode.write(code, into: &buf)
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .PermanentFailure(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension NotificationHandlingError: Equatable, Hashable {}

extension NotificationHandlingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NotificationHandlingErrorCode {
    
    case nodeUnavailable
    case inProgressSwapNotFound
    case expectedPaymentNotReceived
    case insufficientInboundLiquidity
    case lipaServiceUnavailable
    case notificationDisabledInNotificationToggles
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationHandlingErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = NotificationHandlingErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationHandlingErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nodeUnavailable
        
        case 2: return .inProgressSwapNotFound
        
        case 3: return .expectedPaymentNotReceived
        
        case 4: return .insufficientInboundLiquidity
        
        case 5: return .lipaServiceUnavailable
        
        case 6: return .notificationDisabledInNotificationToggles
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationHandlingErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nodeUnavailable:
            writeInt(&buf, Int32(1))
        
        
        case .inProgressSwapNotFound:
            writeInt(&buf, Int32(2))
        
        
        case .expectedPaymentNotReceived:
            writeInt(&buf, Int32(3))
        
        
        case .insufficientInboundLiquidity:
            writeInt(&buf, Int32(4))
        
        
        case .lipaServiceUnavailable:
            writeInt(&buf, Int32(5))
        
        
        case .notificationDisabledInNotificationToggles:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationHandlingErrorCode_lift(_ buf: RustBuffer) throws -> NotificationHandlingErrorCode {
    return try FfiConverterTypeNotificationHandlingErrorCode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationHandlingErrorCode_lower(_ value: NotificationHandlingErrorCode) -> RustBuffer {
    return FfiConverterTypeNotificationHandlingErrorCode.lower(value)
}



extension NotificationHandlingErrorCode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OfferKind {
    
    case pocket(id: String, exchangeRate: ExchangeRate, topupValueMinorUnits: UInt64, topupValueSats: UInt64?, exchangeFeeMinorUnits: UInt64, exchangeFeeRatePermyriad: UInt16, lightningPayoutFee: Amount?, error: PocketOfferError?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOfferKind: FfiConverterRustBuffer {
    typealias SwiftType = OfferKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pocket(id: try FfiConverterString.read(from: &buf), exchangeRate: try FfiConverterTypeExchangeRate.read(from: &buf), topupValueMinorUnits: try FfiConverterUInt64.read(from: &buf), topupValueSats: try FfiConverterOptionUInt64.read(from: &buf), exchangeFeeMinorUnits: try FfiConverterUInt64.read(from: &buf), exchangeFeeRatePermyriad: try FfiConverterUInt16.read(from: &buf), lightningPayoutFee: try FfiConverterOptionTypeAmount.read(from: &buf), error: try FfiConverterOptionTypePocketOfferError.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OfferKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .pocket(id,exchangeRate,topupValueMinorUnits,topupValueSats,exchangeFeeMinorUnits,exchangeFeeRatePermyriad,lightningPayoutFee,error):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(id, into: &buf)
            FfiConverterTypeExchangeRate.write(exchangeRate, into: &buf)
            FfiConverterUInt64.write(topupValueMinorUnits, into: &buf)
            FfiConverterOptionUInt64.write(topupValueSats, into: &buf)
            FfiConverterUInt64.write(exchangeFeeMinorUnits, into: &buf)
            FfiConverterUInt16.write(exchangeFeeRatePermyriad, into: &buf)
            FfiConverterOptionTypeAmount.write(lightningPayoutFee, into: &buf)
            FfiConverterOptionTypePocketOfferError.write(error, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOfferKind_lift(_ buf: RustBuffer) throws -> OfferKind {
    return try FfiConverterTypeOfferKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOfferKind_lower(_ value: OfferKind) -> RustBuffer {
    return FfiConverterTypeOfferKind.lower(value)
}



extension OfferKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OfferStatus {
    
    case ready
    case failed
    case refunded
    case settled
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOfferStatus: FfiConverterRustBuffer {
    typealias SwiftType = OfferStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ready
        
        case 2: return .failed
        
        case 3: return .refunded
        
        case 4: return .settled
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OfferStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ready:
            writeInt(&buf, Int32(1))
        
        
        case .failed:
            writeInt(&buf, Int32(2))
        
        
        case .refunded:
            writeInt(&buf, Int32(3))
        
        
        case .settled:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOfferStatus_lift(_ buf: RustBuffer) throws -> OfferStatus {
    return try FfiConverterTypeOfferStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOfferStatus_lower(_ value: OfferStatus) -> RustBuffer {
    return FfiConverterTypeOfferStatus.lower(value)
}



extension OfferStatus: Equatable, Hashable {}




public enum ParseError {

    
    
    case Incomplete
    case InvalidCharacter(at: UInt32
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParseError: FfiConverterRustBuffer {
    typealias SwiftType = ParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Incomplete
        case 2: return .InvalidCharacter(
            at: try FfiConverterUInt32.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Incomplete:
            writeInt(&buf, Int32(1))
        
        
        case let .InvalidCharacter(at):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(at, into: &buf)
            
        }
    }
}


extension ParseError: Equatable, Hashable {}

extension ParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum ParsePhoneNumberError {

    
    
    case ParsingError
    case MissingCountryCode
    case InvalidCountryCode
    case InvalidPhoneNumber
    case UnsupportedCountry
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParsePhoneNumberError: FfiConverterRustBuffer {
    typealias SwiftType = ParsePhoneNumberError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsePhoneNumberError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ParsingError
        case 2: return .MissingCountryCode
        case 3: return .InvalidCountryCode
        case 4: return .InvalidPhoneNumber
        case 5: return .UnsupportedCountry

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParsePhoneNumberError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .ParsingError:
            writeInt(&buf, Int32(1))
        
        
        case .MissingCountryCode:
            writeInt(&buf, Int32(2))
        
        
        case .InvalidCountryCode:
            writeInt(&buf, Int32(3))
        
        
        case .InvalidPhoneNumber:
            writeInt(&buf, Int32(4))
        
        
        case .UnsupportedCountry:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension ParsePhoneNumberError: Equatable, Hashable {}

extension ParsePhoneNumberError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum ParsePhoneNumberPrefixError {

    
    
    case Incomplete
    case InvalidCharacter(at: UInt32
    )
    case UnsupportedCountry
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParsePhoneNumberPrefixError: FfiConverterRustBuffer {
    typealias SwiftType = ParsePhoneNumberPrefixError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsePhoneNumberPrefixError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Incomplete
        case 2: return .InvalidCharacter(
            at: try FfiConverterUInt32.read(from: &buf)
            )
        case 3: return .UnsupportedCountry

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParsePhoneNumberPrefixError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Incomplete:
            writeInt(&buf, Int32(1))
        
        
        case let .InvalidCharacter(at):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(at, into: &buf)
            
        
        case .UnsupportedCountry:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension ParsePhoneNumberPrefixError: Equatable, Hashable {}

extension ParsePhoneNumberPrefixError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum PayError {

    
    
    case InvalidInput(msg: String
    )
    case RuntimeError(code: PayErrorCode, msg: String
    )
    case PermanentFailure(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayError: FfiConverterRustBuffer {
    typealias SwiftType = PayError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidInput(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .RuntimeError(
            code: try FfiConverterTypePayErrorCode.read(from: &buf), 
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .PermanentFailure(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PayError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidInput(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .RuntimeError(code,msg):
            writeInt(&buf, Int32(2))
            FfiConverterTypePayErrorCode.write(code, into: &buf)
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .PermanentFailure(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension PayError: Equatable, Hashable {}

extension PayError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PayErrorCode {
    
    case alreadyUsedInvoice
    case invoiceExpired
    case noRouteFound
    case payingToSelf
    case paymentFailed
    case paymentTimeout
    case routeTooExpensive
    case nodeUnavailable
    case unexpectedError
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = PayErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .alreadyUsedInvoice
        
        case 2: return .invoiceExpired
        
        case 3: return .noRouteFound
        
        case 4: return .payingToSelf
        
        case 5: return .paymentFailed
        
        case 6: return .paymentTimeout
        
        case 7: return .routeTooExpensive
        
        case 8: return .nodeUnavailable
        
        case 9: return .unexpectedError
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PayErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .alreadyUsedInvoice:
            writeInt(&buf, Int32(1))
        
        
        case .invoiceExpired:
            writeInt(&buf, Int32(2))
        
        
        case .noRouteFound:
            writeInt(&buf, Int32(3))
        
        
        case .payingToSelf:
            writeInt(&buf, Int32(4))
        
        
        case .paymentFailed:
            writeInt(&buf, Int32(5))
        
        
        case .paymentTimeout:
            writeInt(&buf, Int32(6))
        
        
        case .routeTooExpensive:
            writeInt(&buf, Int32(7))
        
        
        case .nodeUnavailable:
            writeInt(&buf, Int32(8))
        
        
        case .unexpectedError:
            writeInt(&buf, Int32(9))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayErrorCode_lift(_ buf: RustBuffer) throws -> PayErrorCode {
    return try FfiConverterTypePayErrorCode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayErrorCode_lower(_ value: PayErrorCode) -> RustBuffer {
    return FfiConverterTypePayErrorCode.lower(value)
}



extension PayErrorCode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentAffordability {
    
    case notEnoughFunds
    case unaffordableFees
    case affordable
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentAffordability: FfiConverterRustBuffer {
    typealias SwiftType = PaymentAffordability

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentAffordability {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notEnoughFunds
        
        case 2: return .unaffordableFees
        
        case 3: return .affordable
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentAffordability, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notEnoughFunds:
            writeInt(&buf, Int32(1))
        
        
        case .unaffordableFees:
            writeInt(&buf, Int32(2))
        
        
        case .affordable:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentAffordability_lift(_ buf: RustBuffer) throws -> PaymentAffordability {
    return try FfiConverterTypePaymentAffordability.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentAffordability_lower(_ value: PaymentAffordability) -> RustBuffer {
    return FfiConverterTypePaymentAffordability.lower(value)
}



extension PaymentAffordability: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentSource {
    
    case camera
    case clipboard
    case nfc
    case manual
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentSource: FfiConverterRustBuffer {
    typealias SwiftType = PaymentSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .camera
        
        case 2: return .clipboard
        
        case 3: return .nfc
        
        case 4: return .manual
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case .camera:
            writeInt(&buf, Int32(1))
        
        
        case .clipboard:
            writeInt(&buf, Int32(2))
        
        
        case .nfc:
            writeInt(&buf, Int32(3))
        
        
        case .manual:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentSource_lift(_ buf: RustBuffer) throws -> PaymentSource {
    return try FfiConverterTypePaymentSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentSource_lower(_ value: PaymentSource) -> RustBuffer {
    return FfiConverterTypePaymentSource.lower(value)
}



extension PaymentSource: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentState {
    
    case created
    case succeeded
    case failed
    case retried
    case invoiceExpired
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentState: FfiConverterRustBuffer {
    typealias SwiftType = PaymentState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .created
        
        case 2: return .succeeded
        
        case 3: return .failed
        
        case 4: return .retried
        
        case 5: return .invoiceExpired
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .created:
            writeInt(&buf, Int32(1))
        
        
        case .succeeded:
            writeInt(&buf, Int32(2))
        
        
        case .failed:
            writeInt(&buf, Int32(3))
        
        
        case .retried:
            writeInt(&buf, Int32(4))
        
        
        case .invoiceExpired:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentState_lift(_ buf: RustBuffer) throws -> PaymentState {
    return try FfiConverterTypePaymentState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentState_lower(_ value: PaymentState) -> RustBuffer {
    return FfiConverterTypePaymentState.lower(value)
}



extension PaymentState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PermanentFailureCode {
    
    case thresholdExceeded
    case orderInactive
    case companiesUnsupported
    case countryUnsupported
    case otherRiskDetected
    case customerRequested
    case accountNotMatching
    case payoutExpired
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePermanentFailureCode: FfiConverterRustBuffer {
    typealias SwiftType = PermanentFailureCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PermanentFailureCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .thresholdExceeded
        
        case 2: return .orderInactive
        
        case 3: return .companiesUnsupported
        
        case 4: return .countryUnsupported
        
        case 5: return .otherRiskDetected
        
        case 6: return .customerRequested
        
        case 7: return .accountNotMatching
        
        case 8: return .payoutExpired
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PermanentFailureCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .thresholdExceeded:
            writeInt(&buf, Int32(1))
        
        
        case .orderInactive:
            writeInt(&buf, Int32(2))
        
        
        case .companiesUnsupported:
            writeInt(&buf, Int32(3))
        
        
        case .countryUnsupported:
            writeInt(&buf, Int32(4))
        
        
        case .otherRiskDetected:
            writeInt(&buf, Int32(5))
        
        
        case .customerRequested:
            writeInt(&buf, Int32(6))
        
        
        case .accountNotMatching:
            writeInt(&buf, Int32(7))
        
        
        case .payoutExpired:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePermanentFailureCode_lift(_ buf: RustBuffer) throws -> PermanentFailureCode {
    return try FfiConverterTypePermanentFailureCode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePermanentFailureCode_lower(_ value: PermanentFailureCode) -> RustBuffer {
    return FfiConverterTypePermanentFailureCode.lower(value)
}



extension PermanentFailureCode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PocketOfferError {
    
    case temporaryFailure(code: TemporaryFailureCode
    )
    case permanentFailure(code: PermanentFailureCode
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePocketOfferError: FfiConverterRustBuffer {
    typealias SwiftType = PocketOfferError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PocketOfferError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .temporaryFailure(code: try FfiConverterTypeTemporaryFailureCode.read(from: &buf)
        )
        
        case 2: return .permanentFailure(code: try FfiConverterTypePermanentFailureCode.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PocketOfferError, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .temporaryFailure(code):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTemporaryFailureCode.write(code, into: &buf)
            
        
        case let .permanentFailure(code):
            writeInt(&buf, Int32(2))
            FfiConverterTypePermanentFailureCode.write(code, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePocketOfferError_lift(_ buf: RustBuffer) throws -> PocketOfferError {
    return try FfiConverterTypePocketOfferError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePocketOfferError_lower(_ value: PocketOfferError) -> RustBuffer {
    return FfiConverterTypePocketOfferError.lower(value)
}



extension PocketOfferError: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RangeHit {
    
    case below(min: Amount
    )
    case `in`
    case above(max: Amount
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRangeHit: FfiConverterRustBuffer {
    typealias SwiftType = RangeHit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RangeHit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .below(min: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        case 2: return .`in`
        
        case 3: return .above(max: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RangeHit, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .below(min):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAmount.write(min, into: &buf)
            
        
        case .`in`:
            writeInt(&buf, Int32(2))
        
        
        case let .above(max):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAmount.write(max, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRangeHit_lift(_ buf: RustBuffer) throws -> RangeHit {
    return try FfiConverterTypeRangeHit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRangeHit_lower(_ value: RangeHit) -> RustBuffer {
    return FfiConverterTypeRangeHit.lower(value)
}



extension RangeHit: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Recipient {
    
    case lightningAddress(address: String
    )
    case lnUrlPayDomain(domain: String
    )
    case phoneNumber(e164: String
    )
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecipient: FfiConverterRustBuffer {
    typealias SwiftType = Recipient

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Recipient {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .lightningAddress(address: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .lnUrlPayDomain(domain: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .phoneNumber(e164: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Recipient, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .lightningAddress(address):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(address, into: &buf)
            
        
        case let .lnUrlPayDomain(domain):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(domain, into: &buf)
            
        
        case let .phoneNumber(e164):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(e164, into: &buf)
            
        
        case .unknown:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecipient_lift(_ buf: RustBuffer) throws -> Recipient {
    return try FfiConverterTypeRecipient.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecipient_lower(_ value: Recipient) -> RustBuffer {
    return FfiConverterTypeRecipient.lower(value)
}



extension Recipient: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ReverseSwapStatus {
    
    case initial
    case inProgress
    case cancelled
    case completedSeen
    case completedConfirmed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReverseSwapStatus: FfiConverterRustBuffer {
    typealias SwiftType = ReverseSwapStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReverseSwapStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initial
        
        case 2: return .inProgress
        
        case 3: return .cancelled
        
        case 4: return .completedSeen
        
        case 5: return .completedConfirmed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReverseSwapStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initial:
            writeInt(&buf, Int32(1))
        
        
        case .inProgress:
            writeInt(&buf, Int32(2))
        
        
        case .cancelled:
            writeInt(&buf, Int32(3))
        
        
        case .completedSeen:
            writeInt(&buf, Int32(4))
        
        
        case .completedConfirmed:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReverseSwapStatus_lift(_ buf: RustBuffer) throws -> ReverseSwapStatus {
    return try FfiConverterTypeReverseSwapStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReverseSwapStatus_lower(_ value: ReverseSwapStatus) -> RustBuffer {
    return FfiConverterTypeReverseSwapStatus.lower(value)
}



extension ReverseSwapStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RuntimeErrorCode {
    
    case authServiceUnavailable
    case offerServiceUnavailable
    case lspServiceUnavailable
    case backupServiceUnavailable
    case backupNotFound
    case nodeUnavailable
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRuntimeErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = RuntimeErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RuntimeErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .authServiceUnavailable
        
        case 2: return .offerServiceUnavailable
        
        case 3: return .lspServiceUnavailable
        
        case 4: return .backupServiceUnavailable
        
        case 5: return .backupNotFound
        
        case 6: return .nodeUnavailable
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RuntimeErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .authServiceUnavailable:
            writeInt(&buf, Int32(1))
        
        
        case .offerServiceUnavailable:
            writeInt(&buf, Int32(2))
        
        
        case .lspServiceUnavailable:
            writeInt(&buf, Int32(3))
        
        
        case .backupServiceUnavailable:
            writeInt(&buf, Int32(4))
        
        
        case .backupNotFound:
            writeInt(&buf, Int32(5))
        
        
        case .nodeUnavailable:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRuntimeErrorCode_lift(_ buf: RustBuffer) throws -> RuntimeErrorCode {
    return try FfiConverterTypeRuntimeErrorCode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRuntimeErrorCode_lower(_ value: RuntimeErrorCode) -> RustBuffer {
    return FfiConverterTypeRuntimeErrorCode.lower(value)
}



extension RuntimeErrorCode: Equatable, Hashable {}




public enum SimpleError {

    
    
    case Simple(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSimpleError: FfiConverterRustBuffer {
    typealias SwiftType = SimpleError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Simple(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SimpleError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Simple(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension SimpleError: Equatable, Hashable {}

extension SimpleError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum SwapError {

    
    
    case Generic(err: String
    )
    case ServiceConnectivity(err: String
    )
    case SwapInProgress(err: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSwapError: FfiConverterRustBuffer {
    typealias SwiftType = SwapError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwapError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            err: try FfiConverterString.read(from: &buf)
            )
        case 2: return .ServiceConnectivity(
            err: try FfiConverterString.read(from: &buf)
            )
        case 3: return .SwapInProgress(
            err: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SwapError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(err):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(err, into: &buf)
            
        
        case let .ServiceConnectivity(err):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(err, into: &buf)
            
        
        case let .SwapInProgress(err):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(err, into: &buf)
            
        }
    }
}


extension SwapError: Equatable, Hashable {}

extension SwapError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum SweepError {

    
    
    case Generic(err: String
    )
    case ServiceConnectivity(err: String
    )
    case InsufficientFunds(err: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSweepError: FfiConverterRustBuffer {
    typealias SwiftType = SweepError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SweepError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            err: try FfiConverterString.read(from: &buf)
            )
        case 2: return .ServiceConnectivity(
            err: try FfiConverterString.read(from: &buf)
            )
        case 3: return .InsufficientFunds(
            err: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SweepError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(err):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(err, into: &buf)
            
        
        case let .ServiceConnectivity(err):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(err, into: &buf)
            
        
        case let .InsufficientFunds(err):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(err, into: &buf)
            
        }
    }
}


extension SweepError: Equatable, Hashable {}

extension SweepError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TemporaryFailureCode {
    
    case noRoute
    case invoiceExpired
    case unexpected
    case unknown(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTemporaryFailureCode: FfiConverterRustBuffer {
    typealias SwiftType = TemporaryFailureCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TemporaryFailureCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .noRoute
        
        case 2: return .invoiceExpired
        
        case 3: return .unexpected
        
        case 4: return .unknown(msg: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TemporaryFailureCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .noRoute:
            writeInt(&buf, Int32(1))
        
        
        case .invoiceExpired:
            writeInt(&buf, Int32(2))
        
        
        case .unexpected:
            writeInt(&buf, Int32(3))
        
        
        case let .unknown(msg):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTemporaryFailureCode_lift(_ buf: RustBuffer) throws -> TemporaryFailureCode {
    return try FfiConverterTypeTemporaryFailureCode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTemporaryFailureCode_lower(_ value: TemporaryFailureCode) -> RustBuffer {
    return FfiConverterTypeTemporaryFailureCode.lower(value)
}



extension TemporaryFailureCode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TermsAndConditions {
    
    case lipa
    case pocket
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTermsAndConditions: FfiConverterRustBuffer {
    typealias SwiftType = TermsAndConditions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TermsAndConditions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .lipa
        
        case 2: return .pocket
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TermsAndConditions, into buf: inout [UInt8]) {
        switch value {
        
        
        case .lipa:
            writeInt(&buf, Int32(1))
        
        
        case .pocket:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTermsAndConditions_lift(_ buf: RustBuffer) throws -> TermsAndConditions {
    return try FfiConverterTypeTermsAndConditions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTermsAndConditions_lower(_ value: TermsAndConditions) -> RustBuffer {
    return FfiConverterTypeTermsAndConditions.lower(value)
}



extension TermsAndConditions: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UnsupportedDataType {
    
    case lnUrlAuth
    case nodeId
    case url
    case network(network: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsupportedDataType: FfiConverterRustBuffer {
    typealias SwiftType = UnsupportedDataType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsupportedDataType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .lnUrlAuth
        
        case 2: return .nodeId
        
        case 3: return .url
        
        case 4: return .network(network: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UnsupportedDataType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .lnUrlAuth:
            writeInt(&buf, Int32(1))
        
        
        case .nodeId:
            writeInt(&buf, Int32(2))
        
        
        case .url:
            writeInt(&buf, Int32(3))
        
        
        case let .network(network):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(network, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsupportedDataType_lift(_ buf: RustBuffer) throws -> UnsupportedDataType {
    return try FfiConverterTypeUnsupportedDataType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsupportedDataType_lower(_ value: UnsupportedDataType) -> RustBuffer {
    return FfiConverterTypeUnsupportedDataType.lower(value)
}



extension UnsupportedDataType: Equatable, Hashable {}






public protocol EventsCallback : AnyObject {
    
    func paymentReceived(paymentHash: String) 
    
    func paymentSent(paymentHash: String, paymentPreimage: String) 
    
    func paymentFailed(paymentHash: String) 
    
    func channelClosed(channelId: String, reason: String) 
    
    func swapReceived(paymentHash: String) 
    
    func reverseSwapSent(reverseSwapId: String) 
    
    func breezHealthStatusChangedTo(status: BreezHealthCheckStatus) 
    
    func synced() 
    
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceEventsCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceEventsCallback = UniffiVTableCallbackInterfaceEventsCallback(
        paymentReceived: { (
            uniffiHandle: UInt64,
            paymentHash: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEventsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.paymentReceived(
                     paymentHash: try FfiConverterString.lift(paymentHash)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        paymentSent: { (
            uniffiHandle: UInt64,
            paymentHash: RustBuffer,
            paymentPreimage: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEventsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.paymentSent(
                     paymentHash: try FfiConverterString.lift(paymentHash),
                     paymentPreimage: try FfiConverterString.lift(paymentPreimage)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        paymentFailed: { (
            uniffiHandle: UInt64,
            paymentHash: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEventsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.paymentFailed(
                     paymentHash: try FfiConverterString.lift(paymentHash)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        channelClosed: { (
            uniffiHandle: UInt64,
            channelId: RustBuffer,
            reason: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEventsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.channelClosed(
                     channelId: try FfiConverterString.lift(channelId),
                     reason: try FfiConverterString.lift(reason)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        swapReceived: { (
            uniffiHandle: UInt64,
            paymentHash: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEventsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.swapReceived(
                     paymentHash: try FfiConverterString.lift(paymentHash)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        reverseSwapSent: { (
            uniffiHandle: UInt64,
            reverseSwapId: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEventsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reverseSwapSent(
                     reverseSwapId: try FfiConverterString.lift(reverseSwapId)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        breezHealthStatusChangedTo: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEventsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.breezHealthStatusChangedTo(
                     status: try FfiConverterTypeBreezHealthCheckStatus.lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        synced: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEventsCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.synced(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceEventsCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EventsCallback: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitEventsCallback() {
    uniffi_uniffi_lipalightninglib_fn_init_callback_vtable_eventscallback(&UniffiCallbackInterfaceEventsCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceEventsCallback {
    fileprivate static var handleMap = UniffiHandleMap<EventsCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceEventsCallback : FfiConverter {
    typealias SwiftType = EventsCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeExchangeRate: FfiConverterRustBuffer {
    typealias SwiftType = ExchangeRate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeExchangeRate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeExchangeRate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFiatTopupInfo: FfiConverterRustBuffer {
    typealias SwiftType = FiatTopupInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFiatTopupInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFiatTopupInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFiatValue: FfiConverterRustBuffer {
    typealias SwiftType = FiatValue?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFiatValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFiatValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeIncomingPaymentInfo: FfiConverterRustBuffer {
    typealias SwiftType = IncomingPaymentInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIncomingPaymentInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIncomingPaymentInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeOnchainResolvingFees: FfiConverterRustBuffer {
    typealias SwiftType = OnchainResolvingFees?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOnchainResolvingFees.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOnchainResolvingFees.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeOpeningFeeParams: FfiConverterRustBuffer {
    typealias SwiftType = OpeningFeeParams?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOpeningFeeParams.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOpeningFeeParams.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSwapToLightningFees: FfiConverterRustBuffer {
    typealias SwiftType = SwapToLightningFees?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSwapToLightningFees.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSwapToLightningFees.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTzTime: FfiConverterRustBuffer {
    typealias SwiftType = TzTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTzTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTzTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeActivity: FfiConverterRustBuffer {
    typealias SwiftType = Activity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeActivity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeActivity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLevel: FfiConverterRustBuffer {
    typealias SwiftType = Level?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLevel.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLevel.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePocketOfferError: FfiConverterRustBuffer {
    typealias SwiftType = PocketOfferError?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePocketOfferError.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePocketOfferError.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRecipient: FfiConverterRustBuffer {
    typealias SwiftType = Recipient?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRecipient.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRecipient.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFailedSwapInfo: FfiConverterRustBuffer {
    typealias SwiftType = [FailedSwapInfo]

    public static func write(_ value: [FailedSwapInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFailedSwapInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FailedSwapInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [FailedSwapInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFailedSwapInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeOfferInfo: FfiConverterRustBuffer {
    typealias SwiftType = [OfferInfo]

    public static func write(_ value: [OfferInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOfferInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OfferInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [OfferInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOfferInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeActionRequiredItem: FfiConverterRustBuffer {
    typealias SwiftType = [ActionRequiredItem]

    public static func write(_ value: [ActionRequiredItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeActionRequiredItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ActionRequiredItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [ActionRequiredItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeActionRequiredItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeActivity: FfiConverterRustBuffer {
    typealias SwiftType = [Activity]

    public static func write(_ value: [Activity], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeActivity.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Activity] {
        let len: Int32 = try readInt(&buf)
        var seq = [Activity]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeActivity.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRecipient: FfiConverterRustBuffer {
    typealias SwiftType = [Recipient]

    public static func write(_ value: [Recipient], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRecipient.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Recipient] {
        let len: Int32 = try readInt(&buf)
        var seq = [Recipient]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRecipient.read(from: &buf))
        }
        return seq
    }
}
public func acceptTermsAndConditions(backendUrl: String, seed: Data, version: Int64, fingerprint: String)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_func_accept_terms_and_conditions(
        FfiConverterString.lower(backendUrl),
        FfiConverterData.lower(seed),
        FfiConverterInt64.lower(version),
        FfiConverterString.lower(fingerprint),$0
    )
}
}
public func generateSecret(passphrase: String)throws  -> Secret {
    return try  FfiConverterTypeSecret.lift(try rustCallWithError(FfiConverterTypeSimpleError.lift) {
    uniffi_uniffi_lipalightninglib_fn_func_generate_secret(
        FfiConverterString.lower(passphrase),$0
    )
})
}
public func getTermsAndConditionsStatus(backendUrl: String, seed: Data, termsAndConditions: TermsAndConditions)throws  -> TermsAndConditionsStatus {
    return try  FfiConverterTypeTermsAndConditionsStatus.lift(try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_func_get_terms_and_conditions_status(
        FfiConverterString.lower(backendUrl),
        FfiConverterData.lower(seed),
        FfiConverterTypeTermsAndConditions.lower(termsAndConditions),$0
    )
})
}
public func handleNotification(config: LightningNodeConfig, notificationPayload: String, notificationToggles: NotificationToggles, timeout: TimeInterval)throws  -> Notification {
    return try  FfiConverterTypeNotification.lift(try rustCallWithError(FfiConverterTypeNotificationHandlingError.lift) {
    uniffi_uniffi_lipalightninglib_fn_func_handle_notification(
        FfiConverterTypeLightningNodeConfig.lower(config),
        FfiConverterString.lower(notificationPayload),
        FfiConverterTypeNotificationToggles.lower(notificationToggles),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
public func mnemonicToSecret(mnemonicString: [String], passphrase: String)throws  -> Secret {
    return try  FfiConverterTypeSecret.lift(try rustCallWithError(FfiConverterTypeMnemonicError.lift) {
    uniffi_uniffi_lipalightninglib_fn_func_mnemonic_to_secret(
        FfiConverterSequenceString.lower(mnemonicString),
        FfiConverterString.lower(passphrase),$0
    )
})
}
public func parseLightningAddress(address: String)throws  {try rustCallWithError(FfiConverterTypeParseError.lift) {
    uniffi_uniffi_lipalightninglib_fn_func_parse_lightning_address(
        FfiConverterString.lower(address),$0
    )
}
}
public func recoverLightningNode(backendUrl: String, seed: Data, localPersistencePath: String, fileLoggingLevel: Level?)throws  {try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_func_recover_lightning_node(
        FfiConverterString.lower(backendUrl),
        FfiConverterData.lower(seed),
        FfiConverterString.lower(localPersistencePath),
        FfiConverterOptionTypeLevel.lower(fileLoggingLevel),$0
    )
}
}
public func wordsByPrefix(prefix: String) -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_func_words_by_prefix(
        FfiConverterString.lower(prefix),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_uniffi_lipalightninglib_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_accept_terms_and_conditions() != 11801) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_generate_secret() != 27916) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_get_terms_and_conditions_status() != 65178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_handle_notification() != 27529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_mnemonic_to_secret() != 23900) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_parse_lightning_address() != 40400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_recover_lightning_node() != 64552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_words_by_prefix() != 18339) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_actionsrequired_dismiss_topup() != 60616) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_actionsrequired_hide_unrecoverable_channel_close_funds_item() != 20833) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_actionsrequired_hide_unrecoverable_failed_swap_item() != 25796) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_actionsrequired_list() != 50235) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_activities_get() != 57920) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_activities_get_by_reverse_swap() != 62360) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_activities_get_incoming_payment() != 52578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_activities_get_outgoing_payment() != 59419) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_activities_list() != 5217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_activities_set_personal_note() != 42000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_bolt11_create() != 1035) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_bolt11_pay() != 6682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_bolt11_pay_open_amount() != 49363) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_channelclose_determine_resolving_fees() != 21525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_channelclose_prepare_sweep() != 21435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_channelclose_swap() != 13343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_channelclose_sweep() != 3534) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_config_background() != 3896) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_config_foreground() != 57183) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_config_get_analytics_config() != 56514) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_config_list_currencies() != 27075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_config_register_notification_token() != 57954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_config_set_analytics_config() != 58647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_config_set_feature_flag() != 32595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_config_set_fiat_currency() != 28125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_config_set_timezone_config() != 25187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_fiattopup_accept_tc() != 42345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_fiattopup_calculate_payout_fee() != 23167) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_fiattopup_get_info() != 62428) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_fiattopup_query_tc_status() != 17404) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_fiattopup_register() != 17799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_fiattopup_request_collection() != 4275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_fiattopup_reset() != 34939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightning_bolt11() != 3635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightning_calculate_lsp_fee_for_amount() != 58652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightning_determine_max_routing_fee_mode() != 2981) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightning_determine_payment_affordability() != 40404) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightning_determine_receive_amount_limits() != 59145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightning_get_lsp_fee() != 21001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightning_lnurl() != 50401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningaddress_get() != 26745) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningaddress_register() != 1206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_accept_pocket_terms_and_conditions() != 25155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_actions_required() != 19551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_activities() != 23299) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_background() != 28178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_calculate_lightning_payout_fee() != 47099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_calculate_lsp_fee() != 41445) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_change_fiat_currency() != 3943) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_change_timezone_config() != 21160) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_check_clear_wallet_feasibility() != 8958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_clear_wallet() != 22211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_config() != 58674) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_create_invoice() != 6856) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_decode_data() != 11730) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_fiat_topup() != 11833) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_foreground() != 21792) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_generate_swap_address() != 19541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_activity() != 53526) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_analytics_config() != 15582) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_channel_close_resolving_fees() != 20341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_exchange_rate() != 15675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_failed_swap_resolving_fees() != 398) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_health_status() != 64525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_incoming_payment() != 6206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_invoice_affordability() != 10343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_latest_activities() != 8716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_node_info() != 8992) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_outgoing_payment() != 17986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_payment_amount_limits() != 38114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_payment_max_routing_fee_mode() != 46434) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_payment_uuid() != 55382) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_terms_and_conditions_status() != 53895) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_unresolved_failed_swaps() != 55743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_wallet_pubkey_id() != 64850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_hide_channel_closes_funds_available_action_required_item() != 40997) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_hide_topup() != 9954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_hide_unresolved_failed_swap_action_required_item() != 22326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_lightning() != 11450) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_lightning_address() != 63205) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_list_action_required_items() != 17350) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_list_currency_codes() != 24404) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_list_recipients() != 10482) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_log_debug_info() != 60092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_onchain() != 55255) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_parse_phone_number_prefix() != 63325) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_parse_phone_number_to_lightning_address() != 44470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_pay_invoice() != 55741) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_pay_lnurlp() != 19853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_pay_open_invoice() != 20722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_phone_number() != 40512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_prepare_clear_wallet() != 19083) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_prepare_resolve_failed_swap() != 48057) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_prepare_sweep_funds_from_channel_closes() != 4648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_query_lightning_address() != 22893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_query_lsp_fee() != 32663) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_query_onchain_fee_rate() != 169) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_query_uncompleted_offers() != 16092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_query_verified_phone_number() != 38376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_register_fiat_topup() != 12958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_register_lightning_address() != 46966) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_register_notification_token() != 23769) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_request_offer_collection() != 9125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_request_phone_number_verification() != 25416) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_reset_fiat_topup() != 23479) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_resolve_failed_swap() != 11475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_retrieve_latest_fiat_topup_info() != 55765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_set_analytics_config() != 38927) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_set_feature_flag() != 11828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_set_payment_personal_note() != 48745) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_swap_channel_close_funds_to_lightning() != 37915) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_swap_failed_swap_funds_to_lightning() != 3439) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_sweep_funds_from_channel_closes() != 53207) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_util() != 18468) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_verify_phone_number() != 57506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_withdraw_lnurlw() != 52161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lnurl_pay() != 38665) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lnurl_withdraw() != 19605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_onchain_channel_close() != 55056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_onchain_reverse_swap() != 26842) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_onchain_swap() != 34743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_phonenumber_get() != 53005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_phonenumber_parse_prefix() != 52452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_phonenumber_parse_to_lightning_address() != 29117) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_phonenumber_register() != 48201) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_phonenumber_verify() != 24882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_reverseswap_clear_wallet() != 5945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_reverseswap_determine_clear_wallet_feasibility() != 40903) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_reverseswap_prepare_clear_wallet() != 16256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_swap_create() != 19186) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_swap_determine_resolving_fees() != 43015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_swap_prepare_sweep() != 47233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_swap_swap() != 22862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_swap_sweep() != 44251) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_util_decode_data() != 9974) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_util_derive_payment_uuid() != 22797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_util_get_exchange_rate() != 24506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_util_get_node_info() != 36095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_util_log_debug_info() != 33177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_util_query_health_status() != 19195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_util_query_wallet_pubkey_id() != 18812) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_constructor_lightningnode_new() != 17310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_eventscallback_payment_received() != 64243) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_eventscallback_payment_sent() != 26372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_eventscallback_payment_failed() != 7221) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_eventscallback_channel_closed() != 22287) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_eventscallback_swap_received() != 19106) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_eventscallback_reverse_swap_sent() != 61435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_eventscallback_breez_health_status_changed_to() != 40320) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_eventscallback_synced() != 49179) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitEventsCallback()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all