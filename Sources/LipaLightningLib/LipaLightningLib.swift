// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(lipalightninglibFFI)
import lipalightninglibFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_uniffi_lipalightninglib_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_uniffi_lipalightninglib_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
                throw CancellationError()

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

fileprivate struct FfiConverterTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Date {
        let seconds: Int64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        if seconds >= 0 {
            let delta = Double(seconds) + (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        } else {
            let delta = Double(seconds) - (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        }
    }

    public static func write(_ value: Date, into buf: inout [UInt8]) {
        var delta = value.timeIntervalSince1970
        var sign: Int64 = 1
        if delta < 0 {
            // The nanoseconds portion of the epoch offset must always be
            // positive, to simplify the calculation we will use the absolute
            // value of the offset.
            sign = -1
            delta = -delta
        }
        if delta.rounded(.down) > Double(Int64.max) {
            fatalError("Timestamp overflow, exceeds max bounds supported by Uniffi")
        }
        let seconds = Int64(delta)
        let nanoseconds = UInt32((delta - Double(seconds)) * 1.0e9)
        writeInt(&buf, sign * seconds)
        writeInt(&buf, nanoseconds)
    }
}

fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}


public protocol LightningNodeProtocol {
    func acceptPocketTermsAndConditions()  throws
    func background()  
    func calculateLspFee(amountSat: UInt64)  throws -> CalculateLspFeeResponse
    func changeFiatCurrency(fiatCurrency: String)  
    func changeTimezoneConfig(timezoneConfig: TzConfig)  
    func createInvoice(amountSat: UInt64, lspFeeParams: OpeningFeeParams?, description: String, metadata: String)  throws -> InvoiceDetails
    func decodeData(data: String)  throws -> DecodedData
    func decodeInvoice(invoice: String)  throws -> InvoiceDetails
    func foreground()  
    func generateSwapAddress(lspFeeParams: OpeningFeeParams?)  throws -> SwapAddressInfo
    func getExchangeRate()   -> ExchangeRate?
    func getLatestPayments(numberOfPayments: UInt32)  throws -> [Payment]
    func getNodeInfo()  throws -> NodeInfo
    func getPayment(hash: String)  throws -> Payment
    func getPaymentAmountLimits()  throws -> PaymentAmountLimits
    func getPaymentMaxRoutingFeeMode(amountSat: UInt64)   -> MaxRoutingFeeMode
    func getPaymentUuid(paymentHash: String)  throws -> String
    func getUnresolvedFailedSwaps()  throws -> [FailedSwapInfo]
    func getWalletPubkeyId()   -> String?
    func hideTopup(id: String)  throws
    func listCurrencyCodes()   -> [String]
    func logDebugInfo()  throws
    func payInvoice(invoiceDetails: InvoiceDetails, metadata: String)  throws
    func payLnurlp(amountSat: UInt64, lnurlPayRequestData: LnUrlPayRequestData)  throws -> String
    func payOpenInvoice(invoiceDetails: InvoiceDetails, amountSat: UInt64, metadata: String)  throws
    func queryLspFee()  throws -> LspFee
    func queryOnchainFeeRate()  throws -> UInt32
    func queryUncompletedOffers()  throws -> [OfferInfo]
    func registerFiatTopup(email: String?, userIban: String, userCurrency: String)  throws -> FiatTopupInfo
    func registerNotificationToken(notificationToken: String, languageIso6391: String, countryIso31661Alpha2: String)  throws
    func requestOfferCollection(offer: OfferInfo)  throws -> String
    func resolveFailedSwap(failedSwapAddress: String, toAddress: String, onchainFeeRate: UInt32)  throws -> String
    func sweep(address: String, onchainFeeRate: UInt32)  throws -> String
    
}

public class LightningNode: LightningNodeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(config: Config, eventsCallback: EventsCallback) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_constructor_lightningnode_new(
        FfiConverterTypeConfig.lower(config),
        FfiConverterCallbackInterfaceEventsCallback.lower(eventsCallback),$0)
})
    }

    deinit {
        try! rustCall { uniffi_uniffi_lipalightninglib_fn_free_lightningnode(pointer, $0) }
    }

    

    
    

    public func acceptPocketTermsAndConditions() throws {
        try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_accept_pocket_terms_and_conditions(self.pointer, $0
    )
}
    }

    public func background()  {
        try! 
    rustCall() {
    
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_background(self.pointer, $0
    )
}
    }

    public func calculateLspFee(amountSat: UInt64) throws -> CalculateLspFeeResponse {
        return try  FfiConverterTypeCalculateLspFeeResponse.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_calculate_lsp_fee(self.pointer, 
        FfiConverterUInt64.lower(amountSat),$0
    )
}
        )
    }

    public func changeFiatCurrency(fiatCurrency: String)  {
        try! 
    rustCall() {
    
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_change_fiat_currency(self.pointer, 
        FfiConverterString.lower(fiatCurrency),$0
    )
}
    }

    public func changeTimezoneConfig(timezoneConfig: TzConfig)  {
        try! 
    rustCall() {
    
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_change_timezone_config(self.pointer, 
        FfiConverterTypeTzConfig.lower(timezoneConfig),$0
    )
}
    }

    public func createInvoice(amountSat: UInt64, lspFeeParams: OpeningFeeParams?, description: String, metadata: String) throws -> InvoiceDetails {
        return try  FfiConverterTypeInvoiceDetails.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_create_invoice(self.pointer, 
        FfiConverterUInt64.lower(amountSat),
        FfiConverterOptionTypeOpeningFeeParams.lower(lspFeeParams),
        FfiConverterString.lower(description),
        FfiConverterString.lower(metadata),$0
    )
}
        )
    }

    public func decodeData(data: String) throws -> DecodedData {
        return try  FfiConverterTypeDecodedData.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_decode_data(self.pointer, 
        FfiConverterString.lower(data),$0
    )
}
        )
    }

    public func decodeInvoice(invoice: String) throws -> InvoiceDetails {
        return try  FfiConverterTypeInvoiceDetails.lift(
            try 
    rustCallWithError(FfiConverterTypeDecodeInvoiceError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_decode_invoice(self.pointer, 
        FfiConverterString.lower(invoice),$0
    )
}
        )
    }

    public func foreground()  {
        try! 
    rustCall() {
    
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_foreground(self.pointer, $0
    )
}
    }

    public func generateSwapAddress(lspFeeParams: OpeningFeeParams?) throws -> SwapAddressInfo {
        return try  FfiConverterTypeSwapAddressInfo.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_generate_swap_address(self.pointer, 
        FfiConverterOptionTypeOpeningFeeParams.lower(lspFeeParams),$0
    )
}
        )
    }

    public func getExchangeRate()  -> ExchangeRate? {
        return try!  FfiConverterOptionTypeExchangeRate.lift(
            try! 
    rustCall() {
    
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_exchange_rate(self.pointer, $0
    )
}
        )
    }

    public func getLatestPayments(numberOfPayments: UInt32) throws -> [Payment] {
        return try  FfiConverterSequenceTypePayment.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_latest_payments(self.pointer, 
        FfiConverterUInt32.lower(numberOfPayments),$0
    )
}
        )
    }

    public func getNodeInfo() throws -> NodeInfo {
        return try  FfiConverterTypeNodeInfo.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_node_info(self.pointer, $0
    )
}
        )
    }

    public func getPayment(hash: String) throws -> Payment {
        return try  FfiConverterTypePayment.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_payment(self.pointer, 
        FfiConverterString.lower(hash),$0
    )
}
        )
    }

    public func getPaymentAmountLimits() throws -> PaymentAmountLimits {
        return try  FfiConverterTypePaymentAmountLimits.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_payment_amount_limits(self.pointer, $0
    )
}
        )
    }

    public func getPaymentMaxRoutingFeeMode(amountSat: UInt64)  -> MaxRoutingFeeMode {
        return try!  FfiConverterTypeMaxRoutingFeeMode.lift(
            try! 
    rustCall() {
    
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_payment_max_routing_fee_mode(self.pointer, 
        FfiConverterUInt64.lower(amountSat),$0
    )
}
        )
    }

    public func getPaymentUuid(paymentHash: String) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_payment_uuid(self.pointer, 
        FfiConverterString.lower(paymentHash),$0
    )
}
        )
    }

    public func getUnresolvedFailedSwaps() throws -> [FailedSwapInfo] {
        return try  FfiConverterSequenceTypeFailedSwapInfo.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_unresolved_failed_swaps(self.pointer, $0
    )
}
        )
    }

    public func getWalletPubkeyId()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_get_wallet_pubkey_id(self.pointer, $0
    )
}
        )
    }

    public func hideTopup(id: String) throws {
        try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_hide_topup(self.pointer, 
        FfiConverterString.lower(id),$0
    )
}
    }

    public func listCurrencyCodes()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_list_currency_codes(self.pointer, $0
    )
}
        )
    }

    public func logDebugInfo() throws {
        try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_log_debug_info(self.pointer, $0
    )
}
    }

    public func payInvoice(invoiceDetails: InvoiceDetails, metadata: String) throws {
        try 
    rustCallWithError(FfiConverterTypePayError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_pay_invoice(self.pointer, 
        FfiConverterTypeInvoiceDetails.lower(invoiceDetails),
        FfiConverterString.lower(metadata),$0
    )
}
    }

    public func payLnurlp(amountSat: UInt64, lnurlPayRequestData: LnUrlPayRequestData) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_pay_lnurlp(self.pointer, 
        FfiConverterUInt64.lower(amountSat),
        FfiConverterTypeLnUrlPayRequestData.lower(lnurlPayRequestData),$0
    )
}
        )
    }

    public func payOpenInvoice(invoiceDetails: InvoiceDetails, amountSat: UInt64, metadata: String) throws {
        try 
    rustCallWithError(FfiConverterTypePayError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_pay_open_invoice(self.pointer, 
        FfiConverterTypeInvoiceDetails.lower(invoiceDetails),
        FfiConverterUInt64.lower(amountSat),
        FfiConverterString.lower(metadata),$0
    )
}
    }

    public func queryLspFee() throws -> LspFee {
        return try  FfiConverterTypeLspFee.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_query_lsp_fee(self.pointer, $0
    )
}
        )
    }

    public func queryOnchainFeeRate() throws -> UInt32 {
        return try  FfiConverterUInt32.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_query_onchain_fee_rate(self.pointer, $0
    )
}
        )
    }

    public func queryUncompletedOffers() throws -> [OfferInfo] {
        return try  FfiConverterSequenceTypeOfferInfo.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_query_uncompleted_offers(self.pointer, $0
    )
}
        )
    }

    public func registerFiatTopup(email: String?, userIban: String, userCurrency: String) throws -> FiatTopupInfo {
        return try  FfiConverterTypeFiatTopupInfo.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_register_fiat_topup(self.pointer, 
        FfiConverterOptionString.lower(email),
        FfiConverterString.lower(userIban),
        FfiConverterString.lower(userCurrency),$0
    )
}
        )
    }

    public func registerNotificationToken(notificationToken: String, languageIso6391: String, countryIso31661Alpha2: String) throws {
        try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_register_notification_token(self.pointer, 
        FfiConverterString.lower(notificationToken),
        FfiConverterString.lower(languageIso6391),
        FfiConverterString.lower(countryIso31661Alpha2),$0
    )
}
    }

    public func requestOfferCollection(offer: OfferInfo) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_request_offer_collection(self.pointer, 
        FfiConverterTypeOfferInfo.lower(offer),$0
    )
}
        )
    }

    public func resolveFailedSwap(failedSwapAddress: String, toAddress: String, onchainFeeRate: UInt32) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_resolve_failed_swap(self.pointer, 
        FfiConverterString.lower(failedSwapAddress),
        FfiConverterString.lower(toAddress),
        FfiConverterUInt32.lower(onchainFeeRate),$0
    )
}
        )
    }

    public func sweep(address: String, onchainFeeRate: UInt32) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_method_lightningnode_sweep(self.pointer, 
        FfiConverterString.lower(address),
        FfiConverterUInt32.lower(onchainFeeRate),$0
    )
}
        )
    }
}

public struct FfiConverterTypeLightningNode: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LightningNode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LightningNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LightningNode {
        return LightningNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LightningNode) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeLightningNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> LightningNode {
    return try FfiConverterTypeLightningNode.lift(pointer)
}

public func FfiConverterTypeLightningNode_lower(_ value: LightningNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLightningNode.lower(value)
}


public struct Amount {
    public var sats: UInt64
    public var fiat: FiatValue?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sats: UInt64, fiat: FiatValue?) {
        self.sats = sats
        self.fiat = fiat
    }
}


extension Amount: Equatable, Hashable {
    public static func ==(lhs: Amount, rhs: Amount) -> Bool {
        if lhs.sats != rhs.sats {
            return false
        }
        if lhs.fiat != rhs.fiat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sats)
        hasher.combine(fiat)
    }
}


public struct FfiConverterTypeAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        return try Amount(
            sats: FfiConverterUInt64.read(from: &buf), 
            fiat: FfiConverterOptionTypeFiatValue.read(from: &buf)
        )
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.sats, into: &buf)
        FfiConverterOptionTypeFiatValue.write(value.fiat, into: &buf)
    }
}


public func FfiConverterTypeAmount_lift(_ buf: RustBuffer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(buf)
}

public func FfiConverterTypeAmount_lower(_ value: Amount) -> RustBuffer {
    return FfiConverterTypeAmount.lower(value)
}


public struct CalculateLspFeeResponse {
    public var lspFee: Amount
    public var lspFeeParams: OpeningFeeParams?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lspFee: Amount, lspFeeParams: OpeningFeeParams?) {
        self.lspFee = lspFee
        self.lspFeeParams = lspFeeParams
    }
}


extension CalculateLspFeeResponse: Equatable, Hashable {
    public static func ==(lhs: CalculateLspFeeResponse, rhs: CalculateLspFeeResponse) -> Bool {
        if lhs.lspFee != rhs.lspFee {
            return false
        }
        if lhs.lspFeeParams != rhs.lspFeeParams {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lspFee)
        hasher.combine(lspFeeParams)
    }
}


public struct FfiConverterTypeCalculateLspFeeResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CalculateLspFeeResponse {
        return try CalculateLspFeeResponse(
            lspFee: FfiConverterTypeAmount.read(from: &buf), 
            lspFeeParams: FfiConverterOptionTypeOpeningFeeParams.read(from: &buf)
        )
    }

    public static func write(_ value: CalculateLspFeeResponse, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.lspFee, into: &buf)
        FfiConverterOptionTypeOpeningFeeParams.write(value.lspFeeParams, into: &buf)
    }
}


public func FfiConverterTypeCalculateLspFeeResponse_lift(_ buf: RustBuffer) throws -> CalculateLspFeeResponse {
    return try FfiConverterTypeCalculateLspFeeResponse.lift(buf)
}

public func FfiConverterTypeCalculateLspFeeResponse_lower(_ value: CalculateLspFeeResponse) -> RustBuffer {
    return FfiConverterTypeCalculateLspFeeResponse.lower(value)
}


public struct ChannelsInfo {
    public var localBalance: Amount
    public var inboundCapacity: Amount
    public var outboundCapacity: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(localBalance: Amount, inboundCapacity: Amount, outboundCapacity: Amount) {
        self.localBalance = localBalance
        self.inboundCapacity = inboundCapacity
        self.outboundCapacity = outboundCapacity
    }
}


extension ChannelsInfo: Equatable, Hashable {
    public static func ==(lhs: ChannelsInfo, rhs: ChannelsInfo) -> Bool {
        if lhs.localBalance != rhs.localBalance {
            return false
        }
        if lhs.inboundCapacity != rhs.inboundCapacity {
            return false
        }
        if lhs.outboundCapacity != rhs.outboundCapacity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(localBalance)
        hasher.combine(inboundCapacity)
        hasher.combine(outboundCapacity)
    }
}


public struct FfiConverterTypeChannelsInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelsInfo {
        return try ChannelsInfo(
            localBalance: FfiConverterTypeAmount.read(from: &buf), 
            inboundCapacity: FfiConverterTypeAmount.read(from: &buf), 
            outboundCapacity: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: ChannelsInfo, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.localBalance, into: &buf)
        FfiConverterTypeAmount.write(value.inboundCapacity, into: &buf)
        FfiConverterTypeAmount.write(value.outboundCapacity, into: &buf)
    }
}


public func FfiConverterTypeChannelsInfo_lift(_ buf: RustBuffer) throws -> ChannelsInfo {
    return try FfiConverterTypeChannelsInfo.lift(buf)
}

public func FfiConverterTypeChannelsInfo_lower(_ value: ChannelsInfo) -> RustBuffer {
    return FfiConverterTypeChannelsInfo.lower(value)
}


public struct Config {
    public var environment: EnvironmentCode
    public var seed: Data
    public var fiatCurrency: String
    public var localPersistencePath: String
    public var timezoneConfig: TzConfig
    public var enableFileLogging: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(environment: EnvironmentCode, seed: Data, fiatCurrency: String, localPersistencePath: String, timezoneConfig: TzConfig, enableFileLogging: Bool) {
        self.environment = environment
        self.seed = seed
        self.fiatCurrency = fiatCurrency
        self.localPersistencePath = localPersistencePath
        self.timezoneConfig = timezoneConfig
        self.enableFileLogging = enableFileLogging
    }
}


extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.environment != rhs.environment {
            return false
        }
        if lhs.seed != rhs.seed {
            return false
        }
        if lhs.fiatCurrency != rhs.fiatCurrency {
            return false
        }
        if lhs.localPersistencePath != rhs.localPersistencePath {
            return false
        }
        if lhs.timezoneConfig != rhs.timezoneConfig {
            return false
        }
        if lhs.enableFileLogging != rhs.enableFileLogging {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(environment)
        hasher.combine(seed)
        hasher.combine(fiatCurrency)
        hasher.combine(localPersistencePath)
        hasher.combine(timezoneConfig)
        hasher.combine(enableFileLogging)
    }
}


public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return try Config(
            environment: FfiConverterTypeEnvironmentCode.read(from: &buf), 
            seed: FfiConverterData.read(from: &buf), 
            fiatCurrency: FfiConverterString.read(from: &buf), 
            localPersistencePath: FfiConverterString.read(from: &buf), 
            timezoneConfig: FfiConverterTypeTzConfig.read(from: &buf), 
            enableFileLogging: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterTypeEnvironmentCode.write(value.environment, into: &buf)
        FfiConverterData.write(value.seed, into: &buf)
        FfiConverterString.write(value.fiatCurrency, into: &buf)
        FfiConverterString.write(value.localPersistencePath, into: &buf)
        FfiConverterTypeTzConfig.write(value.timezoneConfig, into: &buf)
        FfiConverterBool.write(value.enableFileLogging, into: &buf)
    }
}


public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}


public struct ExchangeRate {
    public var currencyCode: String
    public var rate: UInt32
    public var updatedAt: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(currencyCode: String, rate: UInt32, updatedAt: Date) {
        self.currencyCode = currencyCode
        self.rate = rate
        self.updatedAt = updatedAt
    }
}


extension ExchangeRate: Equatable, Hashable {
    public static func ==(lhs: ExchangeRate, rhs: ExchangeRate) -> Bool {
        if lhs.currencyCode != rhs.currencyCode {
            return false
        }
        if lhs.rate != rhs.rate {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(currencyCode)
        hasher.combine(rate)
        hasher.combine(updatedAt)
    }
}


public struct FfiConverterTypeExchangeRate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExchangeRate {
        return try ExchangeRate(
            currencyCode: FfiConverterString.read(from: &buf), 
            rate: FfiConverterUInt32.read(from: &buf), 
            updatedAt: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: ExchangeRate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.currencyCode, into: &buf)
        FfiConverterUInt32.write(value.rate, into: &buf)
        FfiConverterTimestamp.write(value.updatedAt, into: &buf)
    }
}


public func FfiConverterTypeExchangeRate_lift(_ buf: RustBuffer) throws -> ExchangeRate {
    return try FfiConverterTypeExchangeRate.lift(buf)
}

public func FfiConverterTypeExchangeRate_lower(_ value: ExchangeRate) -> RustBuffer {
    return FfiConverterTypeExchangeRate.lower(value)
}


public struct FailedSwapInfo {
    public var address: String
    public var amount: Amount
    public var createdAt: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, amount: Amount, createdAt: Date) {
        self.address = address
        self.amount = amount
        self.createdAt = createdAt
    }
}


extension FailedSwapInfo: Equatable, Hashable {
    public static func ==(lhs: FailedSwapInfo, rhs: FailedSwapInfo) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(amount)
        hasher.combine(createdAt)
    }
}


public struct FfiConverterTypeFailedSwapInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FailedSwapInfo {
        return try FailedSwapInfo(
            address: FfiConverterString.read(from: &buf), 
            amount: FfiConverterTypeAmount.read(from: &buf), 
            createdAt: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: FailedSwapInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
        FfiConverterTimestamp.write(value.createdAt, into: &buf)
    }
}


public func FfiConverterTypeFailedSwapInfo_lift(_ buf: RustBuffer) throws -> FailedSwapInfo {
    return try FfiConverterTypeFailedSwapInfo.lift(buf)
}

public func FfiConverterTypeFailedSwapInfo_lower(_ value: FailedSwapInfo) -> RustBuffer {
    return FfiConverterTypeFailedSwapInfo.lower(value)
}


public struct FiatTopupInfo {
    public var orderId: String
    public var debitorIban: String
    public var creditorReference: String
    public var creditorIban: String
    public var creditorBankName: String
    public var creditorBankStreet: String
    public var creditorBankPostalCode: String
    public var creditorBankTown: String
    public var creditorBankCountry: String
    public var creditorBankBic: String
    public var creditorName: String
    public var creditorStreet: String
    public var creditorPostalCode: String
    public var creditorTown: String
    public var creditorCountry: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(orderId: String, debitorIban: String, creditorReference: String, creditorIban: String, creditorBankName: String, creditorBankStreet: String, creditorBankPostalCode: String, creditorBankTown: String, creditorBankCountry: String, creditorBankBic: String, creditorName: String, creditorStreet: String, creditorPostalCode: String, creditorTown: String, creditorCountry: String) {
        self.orderId = orderId
        self.debitorIban = debitorIban
        self.creditorReference = creditorReference
        self.creditorIban = creditorIban
        self.creditorBankName = creditorBankName
        self.creditorBankStreet = creditorBankStreet
        self.creditorBankPostalCode = creditorBankPostalCode
        self.creditorBankTown = creditorBankTown
        self.creditorBankCountry = creditorBankCountry
        self.creditorBankBic = creditorBankBic
        self.creditorName = creditorName
        self.creditorStreet = creditorStreet
        self.creditorPostalCode = creditorPostalCode
        self.creditorTown = creditorTown
        self.creditorCountry = creditorCountry
    }
}


extension FiatTopupInfo: Equatable, Hashable {
    public static func ==(lhs: FiatTopupInfo, rhs: FiatTopupInfo) -> Bool {
        if lhs.orderId != rhs.orderId {
            return false
        }
        if lhs.debitorIban != rhs.debitorIban {
            return false
        }
        if lhs.creditorReference != rhs.creditorReference {
            return false
        }
        if lhs.creditorIban != rhs.creditorIban {
            return false
        }
        if lhs.creditorBankName != rhs.creditorBankName {
            return false
        }
        if lhs.creditorBankStreet != rhs.creditorBankStreet {
            return false
        }
        if lhs.creditorBankPostalCode != rhs.creditorBankPostalCode {
            return false
        }
        if lhs.creditorBankTown != rhs.creditorBankTown {
            return false
        }
        if lhs.creditorBankCountry != rhs.creditorBankCountry {
            return false
        }
        if lhs.creditorBankBic != rhs.creditorBankBic {
            return false
        }
        if lhs.creditorName != rhs.creditorName {
            return false
        }
        if lhs.creditorStreet != rhs.creditorStreet {
            return false
        }
        if lhs.creditorPostalCode != rhs.creditorPostalCode {
            return false
        }
        if lhs.creditorTown != rhs.creditorTown {
            return false
        }
        if lhs.creditorCountry != rhs.creditorCountry {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(orderId)
        hasher.combine(debitorIban)
        hasher.combine(creditorReference)
        hasher.combine(creditorIban)
        hasher.combine(creditorBankName)
        hasher.combine(creditorBankStreet)
        hasher.combine(creditorBankPostalCode)
        hasher.combine(creditorBankTown)
        hasher.combine(creditorBankCountry)
        hasher.combine(creditorBankBic)
        hasher.combine(creditorName)
        hasher.combine(creditorStreet)
        hasher.combine(creditorPostalCode)
        hasher.combine(creditorTown)
        hasher.combine(creditorCountry)
    }
}


public struct FfiConverterTypeFiatTopupInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatTopupInfo {
        return try FiatTopupInfo(
            orderId: FfiConverterString.read(from: &buf), 
            debitorIban: FfiConverterString.read(from: &buf), 
            creditorReference: FfiConverterString.read(from: &buf), 
            creditorIban: FfiConverterString.read(from: &buf), 
            creditorBankName: FfiConverterString.read(from: &buf), 
            creditorBankStreet: FfiConverterString.read(from: &buf), 
            creditorBankPostalCode: FfiConverterString.read(from: &buf), 
            creditorBankTown: FfiConverterString.read(from: &buf), 
            creditorBankCountry: FfiConverterString.read(from: &buf), 
            creditorBankBic: FfiConverterString.read(from: &buf), 
            creditorName: FfiConverterString.read(from: &buf), 
            creditorStreet: FfiConverterString.read(from: &buf), 
            creditorPostalCode: FfiConverterString.read(from: &buf), 
            creditorTown: FfiConverterString.read(from: &buf), 
            creditorCountry: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FiatTopupInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.orderId, into: &buf)
        FfiConverterString.write(value.debitorIban, into: &buf)
        FfiConverterString.write(value.creditorReference, into: &buf)
        FfiConverterString.write(value.creditorIban, into: &buf)
        FfiConverterString.write(value.creditorBankName, into: &buf)
        FfiConverterString.write(value.creditorBankStreet, into: &buf)
        FfiConverterString.write(value.creditorBankPostalCode, into: &buf)
        FfiConverterString.write(value.creditorBankTown, into: &buf)
        FfiConverterString.write(value.creditorBankCountry, into: &buf)
        FfiConverterString.write(value.creditorBankBic, into: &buf)
        FfiConverterString.write(value.creditorName, into: &buf)
        FfiConverterString.write(value.creditorStreet, into: &buf)
        FfiConverterString.write(value.creditorPostalCode, into: &buf)
        FfiConverterString.write(value.creditorTown, into: &buf)
        FfiConverterString.write(value.creditorCountry, into: &buf)
    }
}


public func FfiConverterTypeFiatTopupInfo_lift(_ buf: RustBuffer) throws -> FiatTopupInfo {
    return try FfiConverterTypeFiatTopupInfo.lift(buf)
}

public func FfiConverterTypeFiatTopupInfo_lower(_ value: FiatTopupInfo) -> RustBuffer {
    return FfiConverterTypeFiatTopupInfo.lower(value)
}


public struct FiatValue {
    public var minorUnits: UInt64
    public var currencyCode: String
    public var rate: UInt32
    public var convertedAt: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(minorUnits: UInt64, currencyCode: String, rate: UInt32, convertedAt: Date) {
        self.minorUnits = minorUnits
        self.currencyCode = currencyCode
        self.rate = rate
        self.convertedAt = convertedAt
    }
}


extension FiatValue: Equatable, Hashable {
    public static func ==(lhs: FiatValue, rhs: FiatValue) -> Bool {
        if lhs.minorUnits != rhs.minorUnits {
            return false
        }
        if lhs.currencyCode != rhs.currencyCode {
            return false
        }
        if lhs.rate != rhs.rate {
            return false
        }
        if lhs.convertedAt != rhs.convertedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(minorUnits)
        hasher.combine(currencyCode)
        hasher.combine(rate)
        hasher.combine(convertedAt)
    }
}


public struct FfiConverterTypeFiatValue: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatValue {
        return try FiatValue(
            minorUnits: FfiConverterUInt64.read(from: &buf), 
            currencyCode: FfiConverterString.read(from: &buf), 
            rate: FfiConverterUInt32.read(from: &buf), 
            convertedAt: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: FiatValue, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.minorUnits, into: &buf)
        FfiConverterString.write(value.currencyCode, into: &buf)
        FfiConverterUInt32.write(value.rate, into: &buf)
        FfiConverterTimestamp.write(value.convertedAt, into: &buf)
    }
}


public func FfiConverterTypeFiatValue_lift(_ buf: RustBuffer) throws -> FiatValue {
    return try FfiConverterTypeFiatValue.lift(buf)
}

public func FfiConverterTypeFiatValue_lower(_ value: FiatValue) -> RustBuffer {
    return FfiConverterTypeFiatValue.lower(value)
}


public struct InvoiceDetails {
    public var invoice: String
    public var amount: Amount?
    public var description: String
    public var paymentHash: String
    public var payeePubKey: String
    public var creationTimestamp: Date
    public var expiryInterval: TimeInterval
    public var expiryTimestamp: Date

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(invoice: String, amount: Amount?, description: String, paymentHash: String, payeePubKey: String, creationTimestamp: Date, expiryInterval: TimeInterval, expiryTimestamp: Date) {
        self.invoice = invoice
        self.amount = amount
        self.description = description
        self.paymentHash = paymentHash
        self.payeePubKey = payeePubKey
        self.creationTimestamp = creationTimestamp
        self.expiryInterval = expiryInterval
        self.expiryTimestamp = expiryTimestamp
    }
}


extension InvoiceDetails: Equatable, Hashable {
    public static func ==(lhs: InvoiceDetails, rhs: InvoiceDetails) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.payeePubKey != rhs.payeePubKey {
            return false
        }
        if lhs.creationTimestamp != rhs.creationTimestamp {
            return false
        }
        if lhs.expiryInterval != rhs.expiryInterval {
            return false
        }
        if lhs.expiryTimestamp != rhs.expiryTimestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(amount)
        hasher.combine(description)
        hasher.combine(paymentHash)
        hasher.combine(payeePubKey)
        hasher.combine(creationTimestamp)
        hasher.combine(expiryInterval)
        hasher.combine(expiryTimestamp)
    }
}


public struct FfiConverterTypeInvoiceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvoiceDetails {
        return try InvoiceDetails(
            invoice: FfiConverterString.read(from: &buf), 
            amount: FfiConverterOptionTypeAmount.read(from: &buf), 
            description: FfiConverterString.read(from: &buf), 
            paymentHash: FfiConverterString.read(from: &buf), 
            payeePubKey: FfiConverterString.read(from: &buf), 
            creationTimestamp: FfiConverterTimestamp.read(from: &buf), 
            expiryInterval: FfiConverterDuration.read(from: &buf), 
            expiryTimestamp: FfiConverterTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: InvoiceDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterOptionTypeAmount.write(value.amount, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterString.write(value.payeePubKey, into: &buf)
        FfiConverterTimestamp.write(value.creationTimestamp, into: &buf)
        FfiConverterDuration.write(value.expiryInterval, into: &buf)
        FfiConverterTimestamp.write(value.expiryTimestamp, into: &buf)
    }
}


public func FfiConverterTypeInvoiceDetails_lift(_ buf: RustBuffer) throws -> InvoiceDetails {
    return try FfiConverterTypeInvoiceDetails.lift(buf)
}

public func FfiConverterTypeInvoiceDetails_lower(_ value: InvoiceDetails) -> RustBuffer {
    return FfiConverterTypeInvoiceDetails.lower(value)
}


public struct LnUrlPayDetails {
    public var minSendable: Amount
    public var maxSendable: Amount
    public var requestData: LnUrlPayRequestData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(minSendable: Amount, maxSendable: Amount, requestData: LnUrlPayRequestData) {
        self.minSendable = minSendable
        self.maxSendable = maxSendable
        self.requestData = requestData
    }
}


extension LnUrlPayDetails: Equatable, Hashable {
    public static func ==(lhs: LnUrlPayDetails, rhs: LnUrlPayDetails) -> Bool {
        if lhs.minSendable != rhs.minSendable {
            return false
        }
        if lhs.maxSendable != rhs.maxSendable {
            return false
        }
        if lhs.requestData != rhs.requestData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(minSendable)
        hasher.combine(maxSendable)
        hasher.combine(requestData)
    }
}


public struct FfiConverterTypeLnUrlPayDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayDetails {
        return try LnUrlPayDetails(
            minSendable: FfiConverterTypeAmount.read(from: &buf), 
            maxSendable: FfiConverterTypeAmount.read(from: &buf), 
            requestData: FfiConverterTypeLnUrlPayRequestData.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlPayDetails, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.minSendable, into: &buf)
        FfiConverterTypeAmount.write(value.maxSendable, into: &buf)
        FfiConverterTypeLnUrlPayRequestData.write(value.requestData, into: &buf)
    }
}


public func FfiConverterTypeLnUrlPayDetails_lift(_ buf: RustBuffer) throws -> LnUrlPayDetails {
    return try FfiConverterTypeLnUrlPayDetails.lift(buf)
}

public func FfiConverterTypeLnUrlPayDetails_lower(_ value: LnUrlPayDetails) -> RustBuffer {
    return FfiConverterTypeLnUrlPayDetails.lower(value)
}


public struct LnUrlPayRequestData {
    public var callback: String
    public var minSendable: UInt64
    public var maxSendable: UInt64
    public var metadataStr: String
    public var commentAllowed: UInt16
    public var domain: String
    public var lnAddress: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(callback: String, minSendable: UInt64, maxSendable: UInt64, metadataStr: String, commentAllowed: UInt16, domain: String, lnAddress: String?) {
        self.callback = callback
        self.minSendable = minSendable
        self.maxSendable = maxSendable
        self.metadataStr = metadataStr
        self.commentAllowed = commentAllowed
        self.domain = domain
        self.lnAddress = lnAddress
    }
}


extension LnUrlPayRequestData: Equatable, Hashable {
    public static func ==(lhs: LnUrlPayRequestData, rhs: LnUrlPayRequestData) -> Bool {
        if lhs.callback != rhs.callback {
            return false
        }
        if lhs.minSendable != rhs.minSendable {
            return false
        }
        if lhs.maxSendable != rhs.maxSendable {
            return false
        }
        if lhs.metadataStr != rhs.metadataStr {
            return false
        }
        if lhs.commentAllowed != rhs.commentAllowed {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.lnAddress != rhs.lnAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(callback)
        hasher.combine(minSendable)
        hasher.combine(maxSendable)
        hasher.combine(metadataStr)
        hasher.combine(commentAllowed)
        hasher.combine(domain)
        hasher.combine(lnAddress)
    }
}


public struct FfiConverterTypeLnUrlPayRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayRequestData {
        return try LnUrlPayRequestData(
            callback: FfiConverterString.read(from: &buf), 
            minSendable: FfiConverterUInt64.read(from: &buf), 
            maxSendable: FfiConverterUInt64.read(from: &buf), 
            metadataStr: FfiConverterString.read(from: &buf), 
            commentAllowed: FfiConverterUInt16.read(from: &buf), 
            domain: FfiConverterString.read(from: &buf), 
            lnAddress: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlPayRequestData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.callback, into: &buf)
        FfiConverterUInt64.write(value.minSendable, into: &buf)
        FfiConverterUInt64.write(value.maxSendable, into: &buf)
        FfiConverterString.write(value.metadataStr, into: &buf)
        FfiConverterUInt16.write(value.commentAllowed, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterOptionString.write(value.lnAddress, into: &buf)
    }
}


public func FfiConverterTypeLnUrlPayRequestData_lift(_ buf: RustBuffer) throws -> LnUrlPayRequestData {
    return try FfiConverterTypeLnUrlPayRequestData.lift(buf)
}

public func FfiConverterTypeLnUrlPayRequestData_lower(_ value: LnUrlPayRequestData) -> RustBuffer {
    return FfiConverterTypeLnUrlPayRequestData.lower(value)
}


public struct LspFee {
    public var channelMinimumFee: Amount
    public var channelFeePermyriad: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(channelMinimumFee: Amount, channelFeePermyriad: UInt64) {
        self.channelMinimumFee = channelMinimumFee
        self.channelFeePermyriad = channelFeePermyriad
    }
}


extension LspFee: Equatable, Hashable {
    public static func ==(lhs: LspFee, rhs: LspFee) -> Bool {
        if lhs.channelMinimumFee != rhs.channelMinimumFee {
            return false
        }
        if lhs.channelFeePermyriad != rhs.channelFeePermyriad {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channelMinimumFee)
        hasher.combine(channelFeePermyriad)
    }
}


public struct FfiConverterTypeLspFee: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LspFee {
        return try LspFee(
            channelMinimumFee: FfiConverterTypeAmount.read(from: &buf), 
            channelFeePermyriad: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LspFee, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.channelMinimumFee, into: &buf)
        FfiConverterUInt64.write(value.channelFeePermyriad, into: &buf)
    }
}


public func FfiConverterTypeLspFee_lift(_ buf: RustBuffer) throws -> LspFee {
    return try FfiConverterTypeLspFee.lift(buf)
}

public func FfiConverterTypeLspFee_lower(_ value: LspFee) -> RustBuffer {
    return FfiConverterTypeLspFee.lower(value)
}


public struct NodeInfo {
    public var nodePubkey: String
    public var peers: [String]
    public var onchainBalance: Amount
    public var channelsInfo: ChannelsInfo

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nodePubkey: String, peers: [String], onchainBalance: Amount, channelsInfo: ChannelsInfo) {
        self.nodePubkey = nodePubkey
        self.peers = peers
        self.onchainBalance = onchainBalance
        self.channelsInfo = channelsInfo
    }
}


extension NodeInfo: Equatable, Hashable {
    public static func ==(lhs: NodeInfo, rhs: NodeInfo) -> Bool {
        if lhs.nodePubkey != rhs.nodePubkey {
            return false
        }
        if lhs.peers != rhs.peers {
            return false
        }
        if lhs.onchainBalance != rhs.onchainBalance {
            return false
        }
        if lhs.channelsInfo != rhs.channelsInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodePubkey)
        hasher.combine(peers)
        hasher.combine(onchainBalance)
        hasher.combine(channelsInfo)
    }
}


public struct FfiConverterTypeNodeInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeInfo {
        return try NodeInfo(
            nodePubkey: FfiConverterString.read(from: &buf), 
            peers: FfiConverterSequenceString.read(from: &buf), 
            onchainBalance: FfiConverterTypeAmount.read(from: &buf), 
            channelsInfo: FfiConverterTypeChannelsInfo.read(from: &buf)
        )
    }

    public static func write(_ value: NodeInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.nodePubkey, into: &buf)
        FfiConverterSequenceString.write(value.peers, into: &buf)
        FfiConverterTypeAmount.write(value.onchainBalance, into: &buf)
        FfiConverterTypeChannelsInfo.write(value.channelsInfo, into: &buf)
    }
}


public func FfiConverterTypeNodeInfo_lift(_ buf: RustBuffer) throws -> NodeInfo {
    return try FfiConverterTypeNodeInfo.lift(buf)
}

public func FfiConverterTypeNodeInfo_lower(_ value: NodeInfo) -> RustBuffer {
    return FfiConverterTypeNodeInfo.lower(value)
}


public struct OfferInfo {
    public var offerKind: OfferKind
    public var amount: Amount
    public var lnurlw: String?
    public var createdAt: Date
    public var expiresAt: Date?
    public var status: OfferStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(offerKind: OfferKind, amount: Amount, lnurlw: String?, createdAt: Date, expiresAt: Date?, status: OfferStatus) {
        self.offerKind = offerKind
        self.amount = amount
        self.lnurlw = lnurlw
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.status = status
    }
}


extension OfferInfo: Equatable, Hashable {
    public static func ==(lhs: OfferInfo, rhs: OfferInfo) -> Bool {
        if lhs.offerKind != rhs.offerKind {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.lnurlw != rhs.lnurlw {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(offerKind)
        hasher.combine(amount)
        hasher.combine(lnurlw)
        hasher.combine(createdAt)
        hasher.combine(expiresAt)
        hasher.combine(status)
    }
}


public struct FfiConverterTypeOfferInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferInfo {
        return try OfferInfo(
            offerKind: FfiConverterTypeOfferKind.read(from: &buf), 
            amount: FfiConverterTypeAmount.read(from: &buf), 
            lnurlw: FfiConverterOptionString.read(from: &buf), 
            createdAt: FfiConverterTimestamp.read(from: &buf), 
            expiresAt: FfiConverterOptionTimestamp.read(from: &buf), 
            status: FfiConverterTypeOfferStatus.read(from: &buf)
        )
    }

    public static func write(_ value: OfferInfo, into buf: inout [UInt8]) {
        FfiConverterTypeOfferKind.write(value.offerKind, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.lnurlw, into: &buf)
        FfiConverterTimestamp.write(value.createdAt, into: &buf)
        FfiConverterOptionTimestamp.write(value.expiresAt, into: &buf)
        FfiConverterTypeOfferStatus.write(value.status, into: &buf)
    }
}


public func FfiConverterTypeOfferInfo_lift(_ buf: RustBuffer) throws -> OfferInfo {
    return try FfiConverterTypeOfferInfo.lift(buf)
}

public func FfiConverterTypeOfferInfo_lower(_ value: OfferInfo) -> RustBuffer {
    return FfiConverterTypeOfferInfo.lower(value)
}


public struct OpeningFeeParams {
    public var minMsat: UInt64
    public var proportional: UInt32
    public var validUntil: String
    public var maxIdleTime: UInt32
    public var maxClientToSelfDelay: UInt32
    public var promise: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(minMsat: UInt64, proportional: UInt32, validUntil: String, maxIdleTime: UInt32, maxClientToSelfDelay: UInt32, promise: String) {
        self.minMsat = minMsat
        self.proportional = proportional
        self.validUntil = validUntil
        self.maxIdleTime = maxIdleTime
        self.maxClientToSelfDelay = maxClientToSelfDelay
        self.promise = promise
    }
}


extension OpeningFeeParams: Equatable, Hashable {
    public static func ==(lhs: OpeningFeeParams, rhs: OpeningFeeParams) -> Bool {
        if lhs.minMsat != rhs.minMsat {
            return false
        }
        if lhs.proportional != rhs.proportional {
            return false
        }
        if lhs.validUntil != rhs.validUntil {
            return false
        }
        if lhs.maxIdleTime != rhs.maxIdleTime {
            return false
        }
        if lhs.maxClientToSelfDelay != rhs.maxClientToSelfDelay {
            return false
        }
        if lhs.promise != rhs.promise {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(minMsat)
        hasher.combine(proportional)
        hasher.combine(validUntil)
        hasher.combine(maxIdleTime)
        hasher.combine(maxClientToSelfDelay)
        hasher.combine(promise)
    }
}


public struct FfiConverterTypeOpeningFeeParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpeningFeeParams {
        return try OpeningFeeParams(
            minMsat: FfiConverterUInt64.read(from: &buf), 
            proportional: FfiConverterUInt32.read(from: &buf), 
            validUntil: FfiConverterString.read(from: &buf), 
            maxIdleTime: FfiConverterUInt32.read(from: &buf), 
            maxClientToSelfDelay: FfiConverterUInt32.read(from: &buf), 
            promise: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: OpeningFeeParams, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.minMsat, into: &buf)
        FfiConverterUInt32.write(value.proportional, into: &buf)
        FfiConverterString.write(value.validUntil, into: &buf)
        FfiConverterUInt32.write(value.maxIdleTime, into: &buf)
        FfiConverterUInt32.write(value.maxClientToSelfDelay, into: &buf)
        FfiConverterString.write(value.promise, into: &buf)
    }
}


public func FfiConverterTypeOpeningFeeParams_lift(_ buf: RustBuffer) throws -> OpeningFeeParams {
    return try FfiConverterTypeOpeningFeeParams.lift(buf)
}

public func FfiConverterTypeOpeningFeeParams_lower(_ value: OpeningFeeParams) -> RustBuffer {
    return FfiConverterTypeOpeningFeeParams.lower(value)
}


public struct Payment {
    public var paymentType: PaymentType
    public var paymentState: PaymentState
    public var failReason: PayErrorCode?
    public var hash: String
    public var amount: Amount
    public var invoiceDetails: InvoiceDetails
    public var createdAt: TzTime
    public var description: String
    public var preimage: String?
    public var networkFees: Amount?
    public var lspFees: Amount?
    public var offer: OfferKind?
    public var metadata: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentType: PaymentType, paymentState: PaymentState, failReason: PayErrorCode?, hash: String, amount: Amount, invoiceDetails: InvoiceDetails, createdAt: TzTime, description: String, preimage: String?, networkFees: Amount?, lspFees: Amount?, offer: OfferKind?, metadata: String) {
        self.paymentType = paymentType
        self.paymentState = paymentState
        self.failReason = failReason
        self.hash = hash
        self.amount = amount
        self.invoiceDetails = invoiceDetails
        self.createdAt = createdAt
        self.description = description
        self.preimage = preimage
        self.networkFees = networkFees
        self.lspFees = lspFees
        self.offer = offer
        self.metadata = metadata
    }
}


extension Payment: Equatable, Hashable {
    public static func ==(lhs: Payment, rhs: Payment) -> Bool {
        if lhs.paymentType != rhs.paymentType {
            return false
        }
        if lhs.paymentState != rhs.paymentState {
            return false
        }
        if lhs.failReason != rhs.failReason {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.invoiceDetails != rhs.invoiceDetails {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.networkFees != rhs.networkFees {
            return false
        }
        if lhs.lspFees != rhs.lspFees {
            return false
        }
        if lhs.offer != rhs.offer {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentType)
        hasher.combine(paymentState)
        hasher.combine(failReason)
        hasher.combine(hash)
        hasher.combine(amount)
        hasher.combine(invoiceDetails)
        hasher.combine(createdAt)
        hasher.combine(description)
        hasher.combine(preimage)
        hasher.combine(networkFees)
        hasher.combine(lspFees)
        hasher.combine(offer)
        hasher.combine(metadata)
    }
}


public struct FfiConverterTypePayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Payment {
        return try Payment(
            paymentType: FfiConverterTypePaymentType.read(from: &buf), 
            paymentState: FfiConverterTypePaymentState.read(from: &buf), 
            failReason: FfiConverterOptionTypePayErrorCode.read(from: &buf), 
            hash: FfiConverterString.read(from: &buf), 
            amount: FfiConverterTypeAmount.read(from: &buf), 
            invoiceDetails: FfiConverterTypeInvoiceDetails.read(from: &buf), 
            createdAt: FfiConverterTypeTzTime.read(from: &buf), 
            description: FfiConverterString.read(from: &buf), 
            preimage: FfiConverterOptionString.read(from: &buf), 
            networkFees: FfiConverterOptionTypeAmount.read(from: &buf), 
            lspFees: FfiConverterOptionTypeAmount.read(from: &buf), 
            offer: FfiConverterOptionTypeOfferKind.read(from: &buf), 
            metadata: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Payment, into buf: inout [UInt8]) {
        FfiConverterTypePaymentType.write(value.paymentType, into: &buf)
        FfiConverterTypePaymentState.write(value.paymentState, into: &buf)
        FfiConverterOptionTypePayErrorCode.write(value.failReason, into: &buf)
        FfiConverterString.write(value.hash, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
        FfiConverterTypeInvoiceDetails.write(value.invoiceDetails, into: &buf)
        FfiConverterTypeTzTime.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.preimage, into: &buf)
        FfiConverterOptionTypeAmount.write(value.networkFees, into: &buf)
        FfiConverterOptionTypeAmount.write(value.lspFees, into: &buf)
        FfiConverterOptionTypeOfferKind.write(value.offer, into: &buf)
        FfiConverterString.write(value.metadata, into: &buf)
    }
}


public func FfiConverterTypePayment_lift(_ buf: RustBuffer) throws -> Payment {
    return try FfiConverterTypePayment.lift(buf)
}

public func FfiConverterTypePayment_lower(_ value: Payment) -> RustBuffer {
    return FfiConverterTypePayment.lower(value)
}


public struct PaymentAmountLimits {
    public var maxReceive: Amount
    public var liquidityLimit: LiquidityLimit

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxReceive: Amount, liquidityLimit: LiquidityLimit) {
        self.maxReceive = maxReceive
        self.liquidityLimit = liquidityLimit
    }
}


extension PaymentAmountLimits: Equatable, Hashable {
    public static func ==(lhs: PaymentAmountLimits, rhs: PaymentAmountLimits) -> Bool {
        if lhs.maxReceive != rhs.maxReceive {
            return false
        }
        if lhs.liquidityLimit != rhs.liquidityLimit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxReceive)
        hasher.combine(liquidityLimit)
    }
}


public struct FfiConverterTypePaymentAmountLimits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentAmountLimits {
        return try PaymentAmountLimits(
            maxReceive: FfiConverterTypeAmount.read(from: &buf), 
            liquidityLimit: FfiConverterTypeLiquidityLimit.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentAmountLimits, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.maxReceive, into: &buf)
        FfiConverterTypeLiquidityLimit.write(value.liquidityLimit, into: &buf)
    }
}


public func FfiConverterTypePaymentAmountLimits_lift(_ buf: RustBuffer) throws -> PaymentAmountLimits {
    return try FfiConverterTypePaymentAmountLimits.lift(buf)
}

public func FfiConverterTypePaymentAmountLimits_lower(_ value: PaymentAmountLimits) -> RustBuffer {
    return FfiConverterTypePaymentAmountLimits.lower(value)
}


public struct Secret {
    public var mnemonic: [String]
    public var passphrase: String
    public var seed: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonic: [String], passphrase: String, seed: Data) {
        self.mnemonic = mnemonic
        self.passphrase = passphrase
        self.seed = seed
    }
}


extension Secret: Equatable, Hashable {
    public static func ==(lhs: Secret, rhs: Secret) -> Bool {
        if lhs.mnemonic != rhs.mnemonic {
            return false
        }
        if lhs.passphrase != rhs.passphrase {
            return false
        }
        if lhs.seed != rhs.seed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonic)
        hasher.combine(passphrase)
        hasher.combine(seed)
    }
}


public struct FfiConverterTypeSecret: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secret {
        return try Secret(
            mnemonic: FfiConverterSequenceString.read(from: &buf), 
            passphrase: FfiConverterString.read(from: &buf), 
            seed: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Secret, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.mnemonic, into: &buf)
        FfiConverterString.write(value.passphrase, into: &buf)
        FfiConverterData.write(value.seed, into: &buf)
    }
}


public func FfiConverterTypeSecret_lift(_ buf: RustBuffer) throws -> Secret {
    return try FfiConverterTypeSecret.lift(buf)
}

public func FfiConverterTypeSecret_lower(_ value: Secret) -> RustBuffer {
    return FfiConverterTypeSecret.lower(value)
}


public struct SwapAddressInfo {
    public var address: String
    public var minDeposit: Amount
    public var maxDeposit: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, minDeposit: Amount, maxDeposit: Amount) {
        self.address = address
        self.minDeposit = minDeposit
        self.maxDeposit = maxDeposit
    }
}


extension SwapAddressInfo: Equatable, Hashable {
    public static func ==(lhs: SwapAddressInfo, rhs: SwapAddressInfo) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.minDeposit != rhs.minDeposit {
            return false
        }
        if lhs.maxDeposit != rhs.maxDeposit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(minDeposit)
        hasher.combine(maxDeposit)
    }
}


public struct FfiConverterTypeSwapAddressInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwapAddressInfo {
        return try SwapAddressInfo(
            address: FfiConverterString.read(from: &buf), 
            minDeposit: FfiConverterTypeAmount.read(from: &buf), 
            maxDeposit: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: SwapAddressInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeAmount.write(value.minDeposit, into: &buf)
        FfiConverterTypeAmount.write(value.maxDeposit, into: &buf)
    }
}


public func FfiConverterTypeSwapAddressInfo_lift(_ buf: RustBuffer) throws -> SwapAddressInfo {
    return try FfiConverterTypeSwapAddressInfo.lift(buf)
}

public func FfiConverterTypeSwapAddressInfo_lower(_ value: SwapAddressInfo) -> RustBuffer {
    return FfiConverterTypeSwapAddressInfo.lower(value)
}


public struct TzConfig {
    public var timezoneId: String
    public var timezoneUtcOffsetSecs: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(timezoneId: String, timezoneUtcOffsetSecs: Int32) {
        self.timezoneId = timezoneId
        self.timezoneUtcOffsetSecs = timezoneUtcOffsetSecs
    }
}


extension TzConfig: Equatable, Hashable {
    public static func ==(lhs: TzConfig, rhs: TzConfig) -> Bool {
        if lhs.timezoneId != rhs.timezoneId {
            return false
        }
        if lhs.timezoneUtcOffsetSecs != rhs.timezoneUtcOffsetSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(timezoneId)
        hasher.combine(timezoneUtcOffsetSecs)
    }
}


public struct FfiConverterTypeTzConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TzConfig {
        return try TzConfig(
            timezoneId: FfiConverterString.read(from: &buf), 
            timezoneUtcOffsetSecs: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: TzConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.timezoneId, into: &buf)
        FfiConverterInt32.write(value.timezoneUtcOffsetSecs, into: &buf)
    }
}


public func FfiConverterTypeTzConfig_lift(_ buf: RustBuffer) throws -> TzConfig {
    return try FfiConverterTypeTzConfig.lift(buf)
}

public func FfiConverterTypeTzConfig_lower(_ value: TzConfig) -> RustBuffer {
    return FfiConverterTypeTzConfig.lower(value)
}


public struct TzTime {
    public var time: Date
    public var timezoneId: String
    public var timezoneUtcOffsetSecs: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(time: Date, timezoneId: String, timezoneUtcOffsetSecs: Int32) {
        self.time = time
        self.timezoneId = timezoneId
        self.timezoneUtcOffsetSecs = timezoneUtcOffsetSecs
    }
}


extension TzTime: Equatable, Hashable {
    public static func ==(lhs: TzTime, rhs: TzTime) -> Bool {
        if lhs.time != rhs.time {
            return false
        }
        if lhs.timezoneId != rhs.timezoneId {
            return false
        }
        if lhs.timezoneUtcOffsetSecs != rhs.timezoneUtcOffsetSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(time)
        hasher.combine(timezoneId)
        hasher.combine(timezoneUtcOffsetSecs)
    }
}


public struct FfiConverterTypeTzTime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TzTime {
        return try TzTime(
            time: FfiConverterTimestamp.read(from: &buf), 
            timezoneId: FfiConverterString.read(from: &buf), 
            timezoneUtcOffsetSecs: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: TzTime, into buf: inout [UInt8]) {
        FfiConverterTimestamp.write(value.time, into: &buf)
        FfiConverterString.write(value.timezoneId, into: &buf)
        FfiConverterInt32.write(value.timezoneUtcOffsetSecs, into: &buf)
    }
}


public func FfiConverterTypeTzTime_lift(_ buf: RustBuffer) throws -> TzTime {
    return try FfiConverterTypeTzTime.lift(buf)
}

public func FfiConverterTypeTzTime_lower(_ value: TzTime) -> RustBuffer {
    return FfiConverterTypeTzTime.lower(value)
}

public enum DecodeInvoiceError {

    
    
    case ParseError(msg: String)
    case SemanticError(msg: String)
    case NetworkMismatch(expected: Network, found: Network)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeDecodeInvoiceError.lift(error)
    }
}


public struct FfiConverterTypeDecodeInvoiceError: FfiConverterRustBuffer {
    typealias SwiftType = DecodeInvoiceError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecodeInvoiceError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ParseError(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .SemanticError(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .NetworkMismatch(
            expected: try FfiConverterTypeNetwork.read(from: &buf), 
            found: try FfiConverterTypeNetwork.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecodeInvoiceError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ParseError(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .SemanticError(msg):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .NetworkMismatch(expected,found):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNetwork.write(expected, into: &buf)
            FfiConverterTypeNetwork.write(found, into: &buf)
            
        }
    }
}


extension DecodeInvoiceError: Equatable, Hashable {}

extension DecodeInvoiceError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DecodedData {
    
    case bolt11Invoice(invoiceDetails: InvoiceDetails)
    case lnUrlPay(lnurlPayDetails: LnUrlPayDetails)
}

public struct FfiConverterTypeDecodedData: FfiConverterRustBuffer {
    typealias SwiftType = DecodedData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecodedData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bolt11Invoice(
            invoiceDetails: try FfiConverterTypeInvoiceDetails.read(from: &buf)
        )
        
        case 2: return .lnUrlPay(
            lnurlPayDetails: try FfiConverterTypeLnUrlPayDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecodedData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bolt11Invoice(invoiceDetails):
            writeInt(&buf, Int32(1))
            FfiConverterTypeInvoiceDetails.write(invoiceDetails, into: &buf)
            
        
        case let .lnUrlPay(lnurlPayDetails):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnUrlPayDetails.write(lnurlPayDetails, into: &buf)
            
        }
    }
}


public func FfiConverterTypeDecodedData_lift(_ buf: RustBuffer) throws -> DecodedData {
    return try FfiConverterTypeDecodedData.lift(buf)
}

public func FfiConverterTypeDecodedData_lower(_ value: DecodedData) -> RustBuffer {
    return FfiConverterTypeDecodedData.lower(value)
}


extension DecodedData: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EnvironmentCode {
    
    case local
    case dev
    case stage
    case prod
}

public struct FfiConverterTypeEnvironmentCode: FfiConverterRustBuffer {
    typealias SwiftType = EnvironmentCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnvironmentCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .local
        
        case 2: return .dev
        
        case 3: return .stage
        
        case 4: return .prod
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EnvironmentCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .local:
            writeInt(&buf, Int32(1))
        
        
        case .dev:
            writeInt(&buf, Int32(2))
        
        
        case .stage:
            writeInt(&buf, Int32(3))
        
        
        case .prod:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeEnvironmentCode_lift(_ buf: RustBuffer) throws -> EnvironmentCode {
    return try FfiConverterTypeEnvironmentCode.lift(buf)
}

public func FfiConverterTypeEnvironmentCode_lower(_ value: EnvironmentCode) -> RustBuffer {
    return FfiConverterTypeEnvironmentCode.lower(value)
}


extension EnvironmentCode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LiquidityLimit {
    
    case none
    case maxFreeReceive(amount: Amount)
    case minReceive(amount: Amount)
}

public struct FfiConverterTypeLiquidityLimit: FfiConverterRustBuffer {
    typealias SwiftType = LiquidityLimit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiquidityLimit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .maxFreeReceive(
            amount: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        case 3: return .minReceive(
            amount: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LiquidityLimit, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case let .maxFreeReceive(amount):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAmount.write(amount, into: &buf)
            
        
        case let .minReceive(amount):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAmount.write(amount, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLiquidityLimit_lift(_ buf: RustBuffer) throws -> LiquidityLimit {
    return try FfiConverterTypeLiquidityLimit.lift(buf)
}

public func FfiConverterTypeLiquidityLimit_lower(_ value: LiquidityLimit) -> RustBuffer {
    return FfiConverterTypeLiquidityLimit.lower(value)
}


extension LiquidityLimit: Equatable, Hashable {}



public enum LnError {

    
    
    case InvalidInput(msg: String)
    case RuntimeError(code: RuntimeErrorCode, msg: String)
    case PermanentFailure(msg: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeLnError.lift(error)
    }
}


public struct FfiConverterTypeLnError: FfiConverterRustBuffer {
    typealias SwiftType = LnError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidInput(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .RuntimeError(
            code: try FfiConverterTypeRuntimeErrorCode.read(from: &buf), 
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .PermanentFailure(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidInput(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .RuntimeError(code,msg):
            writeInt(&buf, Int32(2))
            FfiConverterTypeRuntimeErrorCode.write(code, into: &buf)
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .PermanentFailure(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension LnError: Equatable, Hashable {}

extension LnError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MaxRoutingFeeMode {
    
    case relative(maxFeePermyriad: UInt16)
    case absolute(maxFeeAmount: Amount)
}

public struct FfiConverterTypeMaxRoutingFeeMode: FfiConverterRustBuffer {
    typealias SwiftType = MaxRoutingFeeMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MaxRoutingFeeMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .relative(
            maxFeePermyriad: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 2: return .absolute(
            maxFeeAmount: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MaxRoutingFeeMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .relative(maxFeePermyriad):
            writeInt(&buf, Int32(1))
            FfiConverterUInt16.write(maxFeePermyriad, into: &buf)
            
        
        case let .absolute(maxFeeAmount):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAmount.write(maxFeeAmount, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMaxRoutingFeeMode_lift(_ buf: RustBuffer) throws -> MaxRoutingFeeMode {
    return try FfiConverterTypeMaxRoutingFeeMode.lift(buf)
}

public func FfiConverterTypeMaxRoutingFeeMode_lower(_ value: MaxRoutingFeeMode) -> RustBuffer {
    return FfiConverterTypeMaxRoutingFeeMode.lower(value)
}


extension MaxRoutingFeeMode: Equatable, Hashable {}



public enum MnemonicError {

    
    
    case BadWordCount(count: UInt64)
    case UnknownWord(index: UInt64)
    case BadEntropyBitCount
    case InvalidChecksum
    case AmbiguousLanguages

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeMnemonicError.lift(error)
    }
}


public struct FfiConverterTypeMnemonicError: FfiConverterRustBuffer {
    typealias SwiftType = MnemonicError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BadWordCount(
            count: try FfiConverterUInt64.read(from: &buf)
            )
        case 2: return .UnknownWord(
            index: try FfiConverterUInt64.read(from: &buf)
            )
        case 3: return .BadEntropyBitCount
        case 4: return .InvalidChecksum
        case 5: return .AmbiguousLanguages

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MnemonicError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .BadWordCount(count):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(count, into: &buf)
            
        
        case let .UnknownWord(index):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(index, into: &buf)
            
        
        case .BadEntropyBitCount:
            writeInt(&buf, Int32(3))
        
        
        case .InvalidChecksum:
            writeInt(&buf, Int32(4))
        
        
        case .AmbiguousLanguages:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension MnemonicError: Equatable, Hashable {}

extension MnemonicError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Network {
    
    case bitcoin
    case testnet
    case signet
    case regtest
}

public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet
        
        case 3: return .signet
        
        case 4: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .signet:
            writeInt(&buf, Int32(3))
        
        
        case .regtest:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}


extension Network: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OfferKind {
    
    case pocket(id: String, exchangeRate: ExchangeRate, topupValueMinorUnits: UInt64, exchangeFeeMinorUnits: UInt64, exchangeFeeRatePermyriad: UInt16, error: PocketOfferError?)
}

public struct FfiConverterTypeOfferKind: FfiConverterRustBuffer {
    typealias SwiftType = OfferKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pocket(
            id: try FfiConverterString.read(from: &buf), 
            exchangeRate: try FfiConverterTypeExchangeRate.read(from: &buf), 
            topupValueMinorUnits: try FfiConverterUInt64.read(from: &buf), 
            exchangeFeeMinorUnits: try FfiConverterUInt64.read(from: &buf), 
            exchangeFeeRatePermyriad: try FfiConverterUInt16.read(from: &buf), 
            error: try FfiConverterOptionTypePocketOfferError.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OfferKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .pocket(id,exchangeRate,topupValueMinorUnits,exchangeFeeMinorUnits,exchangeFeeRatePermyriad,error):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(id, into: &buf)
            FfiConverterTypeExchangeRate.write(exchangeRate, into: &buf)
            FfiConverterUInt64.write(topupValueMinorUnits, into: &buf)
            FfiConverterUInt64.write(exchangeFeeMinorUnits, into: &buf)
            FfiConverterUInt16.write(exchangeFeeRatePermyriad, into: &buf)
            FfiConverterOptionTypePocketOfferError.write(error, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOfferKind_lift(_ buf: RustBuffer) throws -> OfferKind {
    return try FfiConverterTypeOfferKind.lift(buf)
}

public func FfiConverterTypeOfferKind_lower(_ value: OfferKind) -> RustBuffer {
    return FfiConverterTypeOfferKind.lower(value)
}


extension OfferKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OfferStatus {
    
    case ready
    case failed
    case refunded
    case settled
}

public struct FfiConverterTypeOfferStatus: FfiConverterRustBuffer {
    typealias SwiftType = OfferStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ready
        
        case 2: return .failed
        
        case 3: return .refunded
        
        case 4: return .settled
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OfferStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ready:
            writeInt(&buf, Int32(1))
        
        
        case .failed:
            writeInt(&buf, Int32(2))
        
        
        case .refunded:
            writeInt(&buf, Int32(3))
        
        
        case .settled:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeOfferStatus_lift(_ buf: RustBuffer) throws -> OfferStatus {
    return try FfiConverterTypeOfferStatus.lift(buf)
}

public func FfiConverterTypeOfferStatus_lower(_ value: OfferStatus) -> RustBuffer {
    return FfiConverterTypeOfferStatus.lower(value)
}


extension OfferStatus: Equatable, Hashable {}



public enum PayError {

    
    
    case InvalidInput(msg: String)
    case RuntimeError(code: PayErrorCode, msg: String)
    case PermanentFailure(msg: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypePayError.lift(error)
    }
}


public struct FfiConverterTypePayError: FfiConverterRustBuffer {
    typealias SwiftType = PayError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidInput(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .RuntimeError(
            code: try FfiConverterTypePayErrorCode.read(from: &buf), 
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .PermanentFailure(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PayError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidInput(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .RuntimeError(code,msg):
            writeInt(&buf, Int32(2))
            FfiConverterTypePayErrorCode.write(code, into: &buf)
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .PermanentFailure(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension PayError: Equatable, Hashable {}

extension PayError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PayErrorCode {
    
    case invoiceExpired
    case alreadyUsedInvoice
    case payingToSelf
    case noRouteFound
    case recipientRejected
    case retriesExhausted
    case noMoreRoutes
    case unexpectedError
}

public struct FfiConverterTypePayErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = PayErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .invoiceExpired
        
        case 2: return .alreadyUsedInvoice
        
        case 3: return .payingToSelf
        
        case 4: return .noRouteFound
        
        case 5: return .recipientRejected
        
        case 6: return .retriesExhausted
        
        case 7: return .noMoreRoutes
        
        case 8: return .unexpectedError
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PayErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .invoiceExpired:
            writeInt(&buf, Int32(1))
        
        
        case .alreadyUsedInvoice:
            writeInt(&buf, Int32(2))
        
        
        case .payingToSelf:
            writeInt(&buf, Int32(3))
        
        
        case .noRouteFound:
            writeInt(&buf, Int32(4))
        
        
        case .recipientRejected:
            writeInt(&buf, Int32(5))
        
        
        case .retriesExhausted:
            writeInt(&buf, Int32(6))
        
        
        case .noMoreRoutes:
            writeInt(&buf, Int32(7))
        
        
        case .unexpectedError:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypePayErrorCode_lift(_ buf: RustBuffer) throws -> PayErrorCode {
    return try FfiConverterTypePayErrorCode.lift(buf)
}

public func FfiConverterTypePayErrorCode_lower(_ value: PayErrorCode) -> RustBuffer {
    return FfiConverterTypePayErrorCode.lower(value)
}


extension PayErrorCode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentState {
    
    case created
    case succeeded
    case failed
    case retried
    case invoiceExpired
}

public struct FfiConverterTypePaymentState: FfiConverterRustBuffer {
    typealias SwiftType = PaymentState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .created
        
        case 2: return .succeeded
        
        case 3: return .failed
        
        case 4: return .retried
        
        case 5: return .invoiceExpired
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .created:
            writeInt(&buf, Int32(1))
        
        
        case .succeeded:
            writeInt(&buf, Int32(2))
        
        
        case .failed:
            writeInt(&buf, Int32(3))
        
        
        case .retried:
            writeInt(&buf, Int32(4))
        
        
        case .invoiceExpired:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypePaymentState_lift(_ buf: RustBuffer) throws -> PaymentState {
    return try FfiConverterTypePaymentState.lift(buf)
}

public func FfiConverterTypePaymentState_lower(_ value: PaymentState) -> RustBuffer {
    return FfiConverterTypePaymentState.lower(value)
}


extension PaymentState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentType {
    
    case receiving
    case sending
}

public struct FfiConverterTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = PaymentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .receiving
        
        case 2: return .sending
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .receiving:
            writeInt(&buf, Int32(1))
        
        
        case .sending:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypePaymentType_lift(_ buf: RustBuffer) throws -> PaymentType {
    return try FfiConverterTypePaymentType.lift(buf)
}

public func FfiConverterTypePaymentType_lower(_ value: PaymentType) -> RustBuffer {
    return FfiConverterTypePaymentType.lower(value)
}


extension PaymentType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PermanentFailureCode {
    
    case thresholdExceeded
    case orderInactive
    case companiesUnsupported
    case countryUnsupported
    case otherRiskDetected
    case customerRequested
    case accountNotMatching
    case payoutExpired
}

public struct FfiConverterTypePermanentFailureCode: FfiConverterRustBuffer {
    typealias SwiftType = PermanentFailureCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PermanentFailureCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .thresholdExceeded
        
        case 2: return .orderInactive
        
        case 3: return .companiesUnsupported
        
        case 4: return .countryUnsupported
        
        case 5: return .otherRiskDetected
        
        case 6: return .customerRequested
        
        case 7: return .accountNotMatching
        
        case 8: return .payoutExpired
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PermanentFailureCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .thresholdExceeded:
            writeInt(&buf, Int32(1))
        
        
        case .orderInactive:
            writeInt(&buf, Int32(2))
        
        
        case .companiesUnsupported:
            writeInt(&buf, Int32(3))
        
        
        case .countryUnsupported:
            writeInt(&buf, Int32(4))
        
        
        case .otherRiskDetected:
            writeInt(&buf, Int32(5))
        
        
        case .customerRequested:
            writeInt(&buf, Int32(6))
        
        
        case .accountNotMatching:
            writeInt(&buf, Int32(7))
        
        
        case .payoutExpired:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypePermanentFailureCode_lift(_ buf: RustBuffer) throws -> PermanentFailureCode {
    return try FfiConverterTypePermanentFailureCode.lift(buf)
}

public func FfiConverterTypePermanentFailureCode_lower(_ value: PermanentFailureCode) -> RustBuffer {
    return FfiConverterTypePermanentFailureCode.lower(value)
}


extension PermanentFailureCode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PocketOfferError {
    
    case temporaryFailure(code: TemporaryFailureCode)
    case permanentFailure(code: PermanentFailureCode)
}

public struct FfiConverterTypePocketOfferError: FfiConverterRustBuffer {
    typealias SwiftType = PocketOfferError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PocketOfferError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .temporaryFailure(
            code: try FfiConverterTypeTemporaryFailureCode.read(from: &buf)
        )
        
        case 2: return .permanentFailure(
            code: try FfiConverterTypePermanentFailureCode.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PocketOfferError, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .temporaryFailure(code):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTemporaryFailureCode.write(code, into: &buf)
            
        
        case let .permanentFailure(code):
            writeInt(&buf, Int32(2))
            FfiConverterTypePermanentFailureCode.write(code, into: &buf)
            
        }
    }
}


public func FfiConverterTypePocketOfferError_lift(_ buf: RustBuffer) throws -> PocketOfferError {
    return try FfiConverterTypePocketOfferError.lift(buf)
}

public func FfiConverterTypePocketOfferError_lower(_ value: PocketOfferError) -> RustBuffer {
    return FfiConverterTypePocketOfferError.lower(value)
}


extension PocketOfferError: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RuntimeErrorCode {
    
    case authServiceUnavailable
    case offerServiceUnavailable
    case lspServiceUnavailable
    case nodeUnavailable
    case failedFundMigration
}

public struct FfiConverterTypeRuntimeErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = RuntimeErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RuntimeErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .authServiceUnavailable
        
        case 2: return .offerServiceUnavailable
        
        case 3: return .lspServiceUnavailable
        
        case 4: return .nodeUnavailable
        
        case 5: return .failedFundMigration
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RuntimeErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .authServiceUnavailable:
            writeInt(&buf, Int32(1))
        
        
        case .offerServiceUnavailable:
            writeInt(&buf, Int32(2))
        
        
        case .lspServiceUnavailable:
            writeInt(&buf, Int32(3))
        
        
        case .nodeUnavailable:
            writeInt(&buf, Int32(4))
        
        
        case .failedFundMigration:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeRuntimeErrorCode_lift(_ buf: RustBuffer) throws -> RuntimeErrorCode {
    return try FfiConverterTypeRuntimeErrorCode.lift(buf)
}

public func FfiConverterTypeRuntimeErrorCode_lower(_ value: RuntimeErrorCode) -> RustBuffer {
    return FfiConverterTypeRuntimeErrorCode.lower(value)
}


extension RuntimeErrorCode: Equatable, Hashable {}



public enum SimpleError {

    
    
    case Simple(msg: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeSimpleError.lift(error)
    }
}


public struct FfiConverterTypeSimpleError: FfiConverterRustBuffer {
    typealias SwiftType = SimpleError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Simple(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SimpleError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Simple(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension SimpleError: Equatable, Hashable {}

extension SimpleError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TemporaryFailureCode {
    
    case noRoute
    case invoiceExpired
    case unexpected
    case unknown(msg: String)
}

public struct FfiConverterTypeTemporaryFailureCode: FfiConverterRustBuffer {
    typealias SwiftType = TemporaryFailureCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TemporaryFailureCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .noRoute
        
        case 2: return .invoiceExpired
        
        case 3: return .unexpected
        
        case 4: return .unknown(
            msg: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TemporaryFailureCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .noRoute:
            writeInt(&buf, Int32(1))
        
        
        case .invoiceExpired:
            writeInt(&buf, Int32(2))
        
        
        case .unexpected:
            writeInt(&buf, Int32(3))
        
        
        case let .unknown(msg):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTemporaryFailureCode_lift(_ buf: RustBuffer) throws -> TemporaryFailureCode {
    return try FfiConverterTypeTemporaryFailureCode.lift(buf)
}

public func FfiConverterTypeTemporaryFailureCode_lower(_ value: TemporaryFailureCode) -> RustBuffer {
    return FfiConverterTypeTemporaryFailureCode.lower(value)
}


extension TemporaryFailureCode: Equatable, Hashable {}



fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for EventsCallback Callback Interface

public protocol EventsCallback : AnyObject {
    func paymentReceived(paymentHash: String) 
    func paymentSent(paymentHash: String, paymentPreimage: String) 
    func paymentFailed(paymentHash: String) 
    func channelClosed(channelId: String, reason: String) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceEventsCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokePaymentReceived(_ swiftCallbackInterface: EventsCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.paymentReceived(
                    paymentHash:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokePaymentSent(_ swiftCallbackInterface: EventsCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.paymentSent(
                    paymentHash:  try FfiConverterString.read(from: &reader), 
                    paymentPreimage:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokePaymentFailed(_ swiftCallbackInterface: EventsCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.paymentFailed(
                    paymentHash:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeChannelClosed(_ swiftCallbackInterface: EventsCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.channelClosed(
                    channelId:  try FfiConverterString.read(from: &reader), 
                    reason:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceEventsCallback.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: EventsCallback
            do {
                cb = try FfiConverterCallbackInterfaceEventsCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("EventsCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokePaymentReceived(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: EventsCallback
            do {
                cb = try FfiConverterCallbackInterfaceEventsCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("EventsCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokePaymentSent(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: EventsCallback
            do {
                cb = try FfiConverterCallbackInterfaceEventsCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("EventsCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokePaymentFailed(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 4:
            let cb: EventsCallback
            do {
                cb = try FfiConverterCallbackInterfaceEventsCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("EventsCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeChannelClosed(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceEventsCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_uniffi_lipalightninglib_fn_init_callback_eventscallback(foreignCallbackCallbackInterfaceEventsCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<EventsCallback>()
}

extension FfiConverterCallbackInterfaceEventsCallback : FfiConverter {
    typealias SwiftType = EventsCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeExchangeRate: FfiConverterRustBuffer {
    typealias SwiftType = ExchangeRate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeExchangeRate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeExchangeRate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFiatValue: FfiConverterRustBuffer {
    typealias SwiftType = FiatValue?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFiatValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFiatValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOpeningFeeParams: FfiConverterRustBuffer {
    typealias SwiftType = OpeningFeeParams?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOpeningFeeParams.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOpeningFeeParams.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOfferKind: FfiConverterRustBuffer {
    typealias SwiftType = OfferKind?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOfferKind.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOfferKind.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePayErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = PayErrorCode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePayErrorCode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePayErrorCode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePocketOfferError: FfiConverterRustBuffer {
    typealias SwiftType = PocketOfferError?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePocketOfferError.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePocketOfferError.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFailedSwapInfo: FfiConverterRustBuffer {
    typealias SwiftType = [FailedSwapInfo]

    public static func write(_ value: [FailedSwapInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFailedSwapInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FailedSwapInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [FailedSwapInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFailedSwapInfo.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeOfferInfo: FfiConverterRustBuffer {
    typealias SwiftType = [OfferInfo]

    public static func write(_ value: [OfferInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOfferInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OfferInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [OfferInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOfferInfo.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = [Payment]

    public static func write(_ value: [Payment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Payment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Payment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayment.read(from: &buf))
        }
        return seq
    }
}

public func acceptTermsAndConditions(environment: EnvironmentCode, seed: Data) throws {
    try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_func_accept_terms_and_conditions(
        FfiConverterTypeEnvironmentCode.lower(environment),
        FfiConverterData.lower(seed),$0)
}
}



public func generateSecret(passphrase: String) throws -> Secret {
    return try  FfiConverterTypeSecret.lift(
        try rustCallWithError(FfiConverterTypeSimpleError.lift) {
    uniffi_uniffi_lipalightninglib_fn_func_generate_secret(
        FfiConverterString.lower(passphrase),$0)
}
    )
}

public func mnemonicToSecret(mnemonicString: [String], passphrase: String) throws -> Secret {
    return try  FfiConverterTypeSecret.lift(
        try rustCallWithError(FfiConverterTypeMnemonicError.lift) {
    uniffi_uniffi_lipalightninglib_fn_func_mnemonic_to_secret(
        FfiConverterSequenceString.lower(mnemonicString),
        FfiConverterString.lower(passphrase),$0)
}
    )
}

public func recoverLightningNode(environment: EnvironmentCode, seed: Data, localPersistencePath: String, enableFileLogging: Bool) throws {
    try rustCallWithError(FfiConverterTypeLnError.lift) {
    uniffi_uniffi_lipalightninglib_fn_func_recover_lightning_node(
        FfiConverterTypeEnvironmentCode.lower(environment),
        FfiConverterData.lower(seed),
        FfiConverterString.lower(localPersistencePath),
        FfiConverterBool.lower(enableFileLogging),$0)
}
}



public func wordsByPrefix(prefix: String)  -> [String] {
    return try!  FfiConverterSequenceString.lift(
        try! rustCall() {
    uniffi_uniffi_lipalightninglib_fn_func_words_by_prefix(
        FfiConverterString.lower(prefix),$0)
}
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 24
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_uniffi_lipalightninglib_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_accept_terms_and_conditions() != 8141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_generate_secret() != 21258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_mnemonic_to_secret() != 57197) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_recover_lightning_node() != 12517) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_func_words_by_prefix() != 60220) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_accept_pocket_terms_and_conditions() != 23597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_background() != 28178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_calculate_lsp_fee() != 45291) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_change_fiat_currency() != 45001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_change_timezone_config() != 57386) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_create_invoice() != 54850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_decode_data() != 25610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_decode_invoice() != 15690) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_foreground() != 21792) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_generate_swap_address() != 4902) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_exchange_rate() != 49547) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_latest_payments() != 59043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_node_info() != 317) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_payment() != 16303) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_payment_amount_limits() != 55816) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_payment_max_routing_fee_mode() != 17096) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_payment_uuid() != 30652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_unresolved_failed_swaps() != 8758) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_get_wallet_pubkey_id() != 19158) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_hide_topup() != 47963) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_list_currency_codes() != 24226) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_log_debug_info() != 32021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_pay_invoice() != 29249) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_pay_lnurlp() != 36530) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_pay_open_invoice() != 21669) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_query_lsp_fee() != 32123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_query_onchain_fee_rate() != 14720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_query_uncompleted_offers() != 12739) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_register_fiat_topup() != 14793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_register_notification_token() != 50051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_request_offer_collection() != 59716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_resolve_failed_swap() != 33836) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_lightningnode_sweep() != 38276) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_constructor_lightningnode_new() != 348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_eventscallback_payment_received() != 64243) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_eventscallback_payment_sent() != 26372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_eventscallback_payment_failed() != 7221) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_uniffi_lipalightninglib_checksum_method_eventscallback_channel_closed() != 22287) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}